<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GEVIS - Gene Expression VIS</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <script src="d3.v7.8.5.min.js"></script>
    <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
    <script src="//cdn.opencpu.org/opencpu-0.4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/7.0.0/simple-statistics.min.js"></script>
    <script src='https://cdn.jsdelivr.net/gh/kdpsingh/rjs@master/r.js'></script>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js"
        integrity="sha512-5mCB0Kvv97yTzqo0174qxPjMisck/WlK51+mw/RV7UfYbtHI8LuLR82BzZuxHUKSfbh75u9cZHgUcqrZDaBJuA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js"
        integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
        crossorigin="anonymous"></script>

    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <script src="css/bootstrap.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-color/3.0.0/d3-color.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-interpolate/1.5.0/d3-interpolate.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-scale/3.2.2/d3-scale.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-scale-chromatic/1.6.0/d3-scale-chromatic.min.js"></script>
    <link rel="stylesheet" href="https://cdn.datatables.net/2.0.7/css/dataTables.dataTables.css" />
    <script src="https://cdn.datatables.net/2.0.7/js/dataTables.js"></script>

    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/dist/tippy.css" />
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>


    <style>
        /*------ Style 1 ------*/
        #style1 {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 50px;
            height: 30px;
            background-color: transparent;
            border: none;
            cursor: pointer;
        }

        #style1::-webkit-color-swatch {
            border-radius: 5px;
            border: none;
        }

        #style1::-moz-color-swatch {
            border-radius: 5px;
            border: none;
        }

        /* Additional styles to adjust layout */
        .color-input-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
        }

        .input-wrapper {
            margin-left: 10px;
            /* Adjust the margin to fine-tune the distance */
        }

        .value-span {
            flex: 1;
            text-align: center;
            /* Center the text */
        }

        .color-input-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0px 24px;
            gap: 0px;
            /* Adjust gap to bring elements closer */
        }

        .input-wrapper {
            display: inline-block;
            margin-right: 70px;
        }

        .value-span {
            margin-right: 10px;
            /* Optional: Adjust right margin to bring it closer to the input */
        }

        .category-container {
            margin-bottom: 10px;
            /* Add some space between category containers */
        }

        #csvTableData2_wrapper {
            overflow-x: hidden;
            /* Hide the x scrollbar */
        }


        .value-span {
            display: inline-block;
            text-align: left;
            /* Center the unique value */
            margin-left: 40px;
            /* Add some space between the value and the color input */
        }

        .highlight {
            background-color: rgba(var(--dt-row-hover), 0.052) !important;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            /* Change to fixed for better centering */
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            position: absolute;
            /* Change to absolute */
            left: 50%;
            /* Move content to the horizontal center */
            top: 50%;
            /* Move content to the vertical center */
            transform: translate(-50%, -50%);
            /* Adjust to center the content */
            background-color: #0e0d0d;
            padding: 20px;
            border: 1px solid #888;
            width: auto;
            /* Adjust width based on content */
            height: auto;
        }


        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            width: 28px;

        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .axis-label {
            cursor: pointer;
            /* Cursor style when hovering over the axis label */
        }

        .dragging {
            cursor: move;
            /* Cursor style during dragging */
        }


        #thresholdSlider {
            width: 5%;
        }

        .flex {
            display: flex;
            flex-direction: row;
            max-width: space-between;
            height: 100%;
            width: 100%
        }

        .flex1 {
            display: flex;
            flex-direction: row;
            max-width: space-between;
            height: auto;
            width: 50%;

        }

        .flex-container {
            display: flex;
            flex-direction: column;
            max-width: fit-content;

        }

        .flex-container>div {
            margin-right: 3.2px;
            /* Add spacing between items */
        }


        body {
            background-color: black;
            margin: 0;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }

        #style_scatter {
            border: 2px solid #ddd;
            /* Border color */
            /* Border radius for rounded corners */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            /* Shadow effect */
            background-color: rgb(33, 33, 33);
        }


        input.range1 {
            --c: grey;
            /* active color */
            --l: 8px;
            /* line thickness */
            --h: 30px;
            /* thumb height */
            --w: 10px;
            /* thumb width */

            width: 400px;
            height: var(--h);
            /* needed for Firefox */
            --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
            cursor: pointer;
            overflow: hidden;
        }

        input.range1:focus-visible,
        input.range1:hover {
            --p: 25%;
        }

        /* chromium */
        input.range1[type="range" i]::-webkit-slider-thumb {
            height: var(--h);
            width: var(--w);
            background: var(--_c);
            border-image: linear-gradient(90deg, var(--_c) 50%, orange 0) 0 1/calc(50% - var(--l)/2) 100vw/0 100vw;
            -webkit-appearance: none;
            appearance: none;
            transition: .3s;
        }

        /* Second range slider with a different color scheme */
        input.range2 {
            --c: grey;
            /* active color */
            --l: 8px;
            /* line thickness */
            --h: 30px;
            /* thumb height */
            --w: 10px;
            /* thumb width */

            width: 400px;
            height: var(--h);
            /* needed for Firefox */
            --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
            cursor: pointer;
            overflow: hidden;
        }

        input.range2:focus-visible,
        input.range2:hover {
            --p: 25%;
        }

        /* chromium */
        input.range2[type="range" i]::-webkit-slider-thumb {
            height: var(--h);
            width: var(--w);
            background: var(--_c);
            border-image: linear-gradient(90deg, var(--_c) 50%, darkgreen 0) 0 1/calc(50% - var(--l)/2) 100vw/0 100vw;
            -webkit-appearance: none;
            appearance: none;
            transition: .3s;
        }

        @supports not (color: color-mix(in srgb, red, red)) {
            input {
                --_c: var(--c);
            }
        }

        @keyframes pulseAnimation {
            0% {
                fill: green;
                r: 2;
            }

            50% {
                fill: lime;
                /* Color during the pulse */
                r: 4
            }

            100% {
                fill: green;
                r: 2
            }
        }

        .pulse {
            animation: pulseAnimation 1s infinite;
            /* You can adjust the duration as needed */
        }

        @keyframes pulseAnimation1 {
            0% {

                r: 2;
            }

            50% {

                r: 4
            }

            100% {

                r: 2
            }
        }

        .pulse1 {
            animation: pulseAnimation1 1s infinite;
            /* You can adjust the duration as needed */
        }

        @keyframes pulseRedAnimation {
            0% {
                stroke: aqua;
                /* Initial color */
                stroke-width: 2;
                /* Initial stroke width */
            }

            50% {
                stroke: rgb(198, 255, 255);
                /* Color during the pulse */
                stroke-width: 3;
                /* Increased stroke width during the pulse */
            }

            100% {
                stroke: aqua;
                /* Back to initial color */
                stroke-width: 2;
                /* Back to initial stroke width */
            }
        }

        .pulse-red {
            animation: pulseRedAnimation 1s infinite;
            /* Adjust duration as needed */
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            /* Semi-transparent black background */
            z-index: 9999;
            /* Ensure the overlay appears above other elements */
            display: block;
            /* Initially hidden */
        }

        /* You can customize the loading indicator style here */
        #loadingIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            /* Add more styles as needed */
        }

        #radioBoxContainer::-webkit-scrollbar-track {
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            background-color: #F5F5F5;
        }

        #radioBoxContainer::-webkit-scrollbar {
            width: 8px;
            background-color: #F5F5F5;
        }

        #radioBoxContainer::-webkit-scrollbar-thumb {
            border-radius: 10px;
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            background-color: #6c757d;
        }

        #checkboxContainer::-webkit-scrollbar-track {
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            background-color: #F5F5F5;
        }

        #checkboxContainer::-webkit-scrollbar {
            width: 8px;
            background-color: #F5F5F5;
        }

        #checkboxContainer::-webkit-scrollbar-thumb {
            border-radius: 10px;
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            background-color: #6c757d;
        }

        .category-label-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0px 24px;
            /* Adjust padding to control spacing */
            gap: 0px;
            position: relative;
            /* Ensure relative positioning for absolute button placement */
        }

        .resort-button {
            margin-right: 16px;
            /* Move the button 16px to the left */
        }

        .dropdown-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            /* Space between each category block */
        }

        .radio-label {
            flex-shrink: 0;
            margin-right: 20px;
            /* Space between the label and the dropdowns */
        }

        .dropdowns-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }

        .dropdowns-container select {
            margin: 0 5px;
        }

        .vs-text {
            margin: 0 10px;
        }

        /* Additional styles for dropdowns if needed */
        select[name="dropdown1"],
        select[name="dropdown2"] {
            min-width: 150px;
            /* Ensure dropdowns have a minimum width */
        }

        #controlPanel {
            display: flex;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        .search-container {
            display: flex;
            align-items: center;
            margin-left: 10px;
            position: relative;
        }

        #searchInput {
            width: 150px;
        }

        #searchButton {
            margin-left: 10px;
        }

        #searchResultsDropdown {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ccc;
            max-height: 200px;
            display: none;

            overflow-y: auto;
            z-index: 2;
        }

        .result-item {
            cursor: pointer;
            /* Change cursor to pointer */
            background-color: white;
            transition: background-color 0.3s ease;
            /* Smooth transition effect */
            /* padding: 5px; Optional: Add padding for better appearance */
            display: block;
            /* Ensures the element behaves like a block-level element */
            text-decoration: none;
            /* Remove underline for links if any */
            color: black;
            /* Set text color */
            margin-bottom: 5px;
            /* Add margin for spacing between items */
        }

        .result-item:hover {
            background-color: grey;
            /* Change background color on hover */
        }

        #tooltip {
            position: absolute;
            text-align: center;
            width: 120px;
            /* Adjust width as needed */
            padding: 10px;
            font: 12px sans-serif;
            background: rgba(0, 0, 0, 0.8);
            /* Semi-transparent background */
            color: #000000;
            /* White text color */
            border-radius: 5px;
            /* Rounded corners */
            pointer-events: none;
            /* Prevent mouse events */
            opacity: 0;
            /* Initially hidden */
            transition: opacity 0.3s;
            /* Smooth transition */
        }

        .tab {
            overflow: hidden;
            background-color: #f1f1f1;
        }

        .tab button {
            background-color: inherit;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            color: #000;
            /* Default text color */
        }

        .tab button:hover {
            background-color: #ddd;
            /* Light gray background on hover */
            color: #000;
            /* Text color remains black on hover */
        }

        .tab button.active {
            background-color: #ccc;
            /* Active tab background color */
            color: #000;
            /* Active tab text color */
        }

        .tabcontent {
            display: none;
            padding: 20px;
        }
    </style>
</head>

<body>
    <div id="overlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; display: none;">

        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 400px; text-align: center;">

            <h2 style="margin-bottom: 20px; font-size: 20px; color: #333;">What would you like to do?</h2>

            <p style="margin-bottom: 30px; font-size: 16px; color: #555;">Choose one of the following options to
                proceed:</p>

            <div style="display: flex; justify-content: center; gap: 20px;">
                <button id="loadDatasetBtn"
                    style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Load
                    Dataset</button>
                <button id="tryExampleBtn"
                    style="padding: 10px 20px; background-color: #2196F3; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Try
                    Example</button>
            </div>
            <!-- Adjusted the help button styling and position -->
            <div style="margin-top: 20px;">
                <button id="helpBtn"
                    style="padding: 10px 20px; background-color: #FF9800; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Help</button>
            </div>
        </div>
    </div>

    <div id="helpOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; display: none;">

        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 500px; text-align: center;">

            <h2 style="margin-bottom: 20px; font-size: 20px; color: #333;">Help - How to Use GEVIS</h2>

            <p style="margin-bottom: 30px; font-size: 16px; color: #555;">
                GEVIS allows you to conduct differential gene expression analysis through a user-friendly interface.
                Here’s how to use the application:
            </p>

            <ul style="text-align: left; margin: 0 auto; padding: 0; max-width: 400px; font-size: 16px; color: #555;">
                <li><strong>Load Dataset:</strong> Upload your gene expression matrix and metadata files in CSV format,
                    or try the example dataset provided.</li>
                <li><strong>Select Analysis Type:</strong> Choose between statistical methods like t-test, Limma, or
                    DESeq2 for your analysis.</li>
                <li><strong>Interactive Visualization:</strong> Explore the results through various plots such as
                    scatterplots and volcano plots.</li>
                <li><strong>Enrichment & Survival Analysis:</strong> Utilize the built-in tools for enrichment and
                    survival analysis based on your results.</li>
                <li><strong>Export Results:</strong> Export your significant genes and analysis results for further
                    processing or reporting.</li>
            </ul>

            <p style="margin-top: 20px; font-size: 16px; color: #555;">
                For more information, visit the official <a href="https://github.com/francesco-fortunato/GEVIS"
                    target="_blank" style="color: #2196F3; text-decoration: none;">GitHub repository</a>.
            </p>

            <button id="closeHelpOverlayBtn"
                style="padding: 10px 20px; background-color: #f44336; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; margin-top: 20px;">Close</button>
        </div>
    </div>

    <div id="loadDatasetOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1001; display: none;">

        <div id="containeDatasetOverlay"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 600px;">

            <h2 style="margin-bottom: 20px;">Load Raw RNA-Seq CSV Files</h2>
            <ul style="margin-bottom: 30px; font-size: 16px; color: #333;">
                <li>
                    <strong>File 1:</strong> Expression Data
                    <button class="tippyBtn"
                        data-tippy-content="This file should contain gene expression values for each sample, with genes as rows and samples as columns.<br><br><strong>Example:</strong><br><br>ID_REF,Sample 1,Sample 2,Sample 3<br>Gene A,230,300,240<br>Gene B,518,551,569"
                        style="background-color: transparent; border: none; cursor: pointer; margin-left: 5px;">
                        <span
                            style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background-color: #2196F3; color: white; text-align: center; line-height: 20px; font-weight: bold;">?</span>
                    </button>
                </li>
                <div style="margin-bottom: 20px;">
                    <input type="file" id="fileInput1" accept=".csv"
                        style="display: block; margin-bottom: 10px; width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <li>
                    <strong>File 2:</strong> Metadata
                    <button class="tippyBtn"
                        data-tippy-content="This file should contain sample information such as conditions, replicates, and other relevant metadata.<br><br><strong>Example:</strong><br><br>Metadata,Sample 1,Sample 2,Sample 3<br>Type,Cancer,Healthy,Cancer<br>Gender,Male,Female,Male"
                        style="background-color: transparent; border: none; cursor: pointer; margin-left: 5px;">
                        <span
                            style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background-color: #2196F3; color: white; text-align: center; line-height: 20px; font-weight: bold;">?</span>
                    </button>
                </li>
                <div>
                    <input type="file" id="fileInput2" accept=".csv"
                        style="display: block; width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                </div>

            </ul>

            <div id="notification" style="margin-top: 10px; font-size: 16px; text-align: center; color: #555;">
                Please upload two CSV files.
            </div>

            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <button id="loadCsvBtn"
                    style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: not-allowed; opacity: 0.6;"
                    disabled>Load
                    Dataset</button>
                <button id="backBtn"
                    style="padding: 10px 20px; background-color: #F44336; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Back</button>
            </div>

        </div>
    </div>

    <!-- Try Example Overlay -->
    <div id="tryExampleOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1002; display: none;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 600px; text-align: center;">
            <h2 style="margin-bottom: 20px; font-size: 20px; color: #333;">Try Example Data</h2>
            <p style="margin-bottom: 30px; font-size: 16px; color: #555;">Select an example dataset to use:</p>

            <div style="text-align: left; margin-bottom: 30px;">
                <label style="display: block; margin-bottom: 15px; font-size: 16px;">
                    <input type="radio" name="exampleOption" value="example1" style="margin-right: 10px;">
                    <strong>Example 1:</strong> Gene expression signature of cigarette smoking and lung
                    adenocarcinoma development. Based on GEO Series GSE10072.
                </label>
                <label style="display: block; margin-bottom: 15px; font-size: 16px;">
                    <input type="radio" name="exampleOption" value="example2" style="margin-right: 10px;">
                    <strong>Example 2:</strong> Gene expression profiles of pre-treatment bone marrow aspirates from
                    multiple myeloma patients. This dataset includes attributes (event, time to follow-up) for
                    comprehensive survival analysis. Suggested differential expression analysis: [Subgrp7=HY] vs.
                    [Subgrp7=MS]. Based on GEO Series GSE4581.
                </label>
                <label style="display: block; margin-bottom: 15px; font-size: 16px;">
                    <input type="radio" name="exampleOption" value="example3" style="margin-right: 10px;">
                    <strong>Example 3:</strong> MicroRNA expression profiles in 63 patients with intrahepatic
                    cholangiocarcinoma (ICC) and 9 normal intrahepatic bile ducts. The study identified a miRNA
                    signature for predicting prognosis in ICC. Based on GEO Series GSE53870.
                </label>
                <label style="display: block; margin-bottom: 15px; font-size: 16px;">
                    <input type="radio" name="exampleOption" value="example4" style="margin-right: 10px;">
                    <strong>Example 4:</strong> Gene expression profiling of raw RNA-Seq data from airway smooth muscle
                    cells treated with dexamethasone, investigating transcriptomic changes. This dataset is suitable for
                    DESeq2 analysis. Based on GEO series GSE52778.
                </label>
            </div>

            <div style="display: flex; justify-content: center; gap: 20px;">
                <button id="chooseExampleBtn"
                    style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Choose
                    Example</button>
                <button id="closeExampleOverlayBtn"
                    style="padding: 10px 20px; background-color: #F44336; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Back</button>
            </div>
        </div>
    </div>


    <div id="displayCsvOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1002; display: none;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 90%; max-width: 1200px;">

            <h2 style="margin-bottom: 20px; font-size: 24px; color: #333; text-align: center;">CSV Data (First 5
                Columns)</h2>

            <div style="display: flex; gap: 20px; margin-bottom: 20px; overflow-x: auto;">
                <div style="flex: 1; min-width: 0; overflow-x: auto;">
                    <table id="csvTableData1" class="display"
                        style="width: 100%; border-collapse: collapse; border: 1px solid #ddd; border-radius: 4px; overflow: hidden;">
                        <!-- Table content will be dynamically injected -->
                    </table>
                </div>
                <div style="flex: 1; min-width: 0; overflow-x: auto;">
                    <table id="csvTableData2" class="display"
                        style="width: 100%; border-collapse: collapse; border: 1px solid #ddd; border-radius: 4px; overflow: hidden;">
                        <!-- Table content will be dynamically injected -->
                    </table>
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
                <p style="margin: 0; font-size: 16px; color: #555;">Total Columns File 1: <span
                        id="totalColumns1"></span></p>
                <p style="margin: 0; font-size: 16px; color: #555;">Total Columns File 2: <span
                        id="totalColumns2"></span></p>
            </div>

            <button id="quantileNormalizeBtn"
                style="display: block; margin: 20px auto; padding: 10px 20px; background-color: #008CBA; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);">
                Perform Quantile Normalization
            </button>

            <button id="selectMetadataBtn"
                style="display: block; margin: 0 auto; padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Select
                Metadata Rows</button>

            <!-- Message container -->
            <div id="messageContainer" style="margin-top: 20px; font-size: 16px; text-align: center;"></div>

        </div>
    </div>

    <div id="geneOverlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 1000;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 800px;">

            <!-- Tabs -->
            <div class="tab">
                <button class="tablinks active" id="diffExpressedTab">Differential Expressed Genes</button>
                <button class="tablinks" id="selectedGenesTab">Selected Genes</button>
                <button class="tablinks" id="selectedGSMTab">Selected GSM Genes</button>
            </div>

            <!-- Scrollable container for tables -->
            <div style="overflow-x: auto; max-width: 100%; margin-top: 20px;">
                <!-- Table for Differential Expressed Genes -->
                <div id="diffExpressedGenes" class="tabcontent" style="display: block;">
                    <h2 style="margin: 0 0 20px; text-align: center;">Differential Expressed Genes</h2>

                    <!-- Checkbox for PCA information -->
                    <div style="text-align: center; margin-bottom: 10px;">
                        <input type="checkbox" id="includePCA" />
                        <label for="includePCA" style="color: black;">Include PCA Information</label>
                    </div>

                    <table id="diffExpressedTable" class="display" style="width: 100%;"></table>
                </div>

                <!-- Table for Selected Genes -->
                <div id="selectedGenes" class="tabcontent" style="display: none;">
                    <h2 style="margin: 0 0 20px; text-align: center;">Selected Genes</h2>

                    <!-- Checkbox for PCA information -->
                    <div style="text-align: center; margin-bottom: 10px;">
                        <input type="checkbox" id="includePCA2" />
                        <label for="includePCA2" style="color: black;">Include PCA Information</label>
                    </div>

                    <table id="selectedGenesTable" class="display" style="width: 100%;"></table>
                </div>

                <!-- Table for Selected GSM Genes -->
                <div id="selectedGSM" class="tabcontent" style="display: none;">
                    <h2 style="margin: 0 0 20px; text-align: center;">Selected Samples with Selected Genes</h2>
                    <table id="selectedGSMTable" class="display" style="width: 100%;"></table>
                </div>
            </div>

            <!-- Buttons for download and close -->
            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <button id="confirmDownloadButton"
                    style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Download
                    CSV</button>
                <button id="closeOverlayButton"
                    style="padding: 10px 20px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
            </div>
        </div>
    </div>


    <nav class="navbar navbar-expand-lg navbar-light bg-light" id="nav" style="display: none;">
        <a class="navbar-brand" href="#" style="color:white">GEVis - GeneExpressionVIS</a>
        <button class="btn btn-secondary" id="importDatasetButton">Import Dataset</button>
        <span style="margin-left: 10px;"></span> <!-- Adjust the margin as needed -->
        <button class="btn btn-secondary" id="openModalBtn">Enrichment Analysis</button>
        <span style="margin-left: 10px;"></span> <!-- Adjust the margin as needed -->
        <button class="btn btn-secondary" id="openModalBtn1">Survival Analysis</button>
        <button class="btn btn-secondary" id="exportGenesButton" style="margin-left: 10px;">Export DEGs</button>
        <div
            style="position: absolute; right: 2%; top: 50%; transform: translateY(-50%); display: flex; gap: 20px; justify-content: center; align-items: center;">
            <span id="currentAnalysis" style="font-weight: bold; color: white; text-align: center;">Analysis N/A</span>
            <span id="currentMethod" style="font-weight: bold; color: white; text-align: center;">Method N/A</span>
            <span id="geneRegulationInfo" style="font-weight: bold; color: white; text-align: center;">Gene Regulation
                Info N/A</span>
        </div>
    </nav>
    <div id="loadingOverlay" style="display: flex; justify-content: center; align-items: center;">
        <div style="display: flex; justify-content: center; align-items: center; width: 100%; height: 100%;">

            <svg version="1.1" id="L1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                x="0px" y="0px" viewBox="0 0 50 50" enable-background="new 0 0 100 100" xml:space="preserve"
                style="width: 50px; height: 50px;">
                <circle fill="none" stroke="#98AFC7" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="10,10"
                    cx="25" cy="25" r="21">
                    <animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="2s"
                        from="0 25 25" to="360 25 25" repeatCount="indefinite" />
                </circle>
                <circle fill="none" stroke="#98AFC7" stroke-width="1" stroke-miterlimit="10" stroke-dasharray="10,10"
                    cx="25" cy="25" r="18">
                    <animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="2s"
                        from="0 25 25" to="-360 25 25" repeatCount="indefinite" />
                </circle>
                <g fill="#98AFC7">
                    <rect x="15" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.1" />
                    </rect>
                    <rect x="20" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.2" />
                    </rect>
                    <rect x="25" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.3" />
                    </rect>
                    <rect x="30" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.4" />
                    </rect>
                    <rect x="35" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.5" />
                    </rect>
                </g>
            </svg>
        </div>
    </div>

    <div class="flex" id="main_div" style="display: none;"> <!-- div(1) che mette in colonna-->

        <div class="flex-container" style="margin-top : 6px; margin-left : 6px"><!--div(2) che mette in riga iqr e FC-->
            <div id="style_scatter">

                <div id="IQR" style="width: 100%; margin-top: 2%;"></div><!--div(4) IQR-->
                <div> <!--div(3) bottoni IQR-->
                    <input type="range" id="thresholdSlider" class="range2" min="0.1" max="0.99" step="0.01" value="0.2"
                        style="width: 200px;">
                    <span id="thresholdValue"
                        style="color: white; vertical-align: middle; display: inline-block; margin-top: -24px;">20%</span>
                </div><!-- div(3)-->
                <div id="logFCHistogram" style="margin-top:1%;"></div> <!-- div(5) FC-->

                <div><!-- div(6) bottoni FC-->

                    <input type="range" id="log_thresholdSlider" class="range1" min="1.1" max="9.9" step="0.01"
                        value="1.1" style="width: 200px;">
                    <!-- Replacing the span with an input placeholder -->
                    <input type="text" id="log_thresholdSliderValue" value="1.1" readonly
                        style="width: 35px; color: white; background-color: transparent; border: none; vertical-align: middle; display: inline-block; text-align: center; margin-top: -24px; margin-left: -5px;">
                    <div id="boxPlot" style="margin-top:1%;"></div>
                    <!-- Initialize a select button -->
                    <select id="selectButton" class="btn btn-secondary dropdown-toggle">
                        <option value="SPP1" selected>MostUp</option>
                        <option value="AGER">MostdDown</option>
                    </select>

                </div><!--div(6)-->


            </div>
        </div><!--div(2)-->

        <div>
            <div class="flex-container" style="margin-top : 6px;">
                <div id="style_scatter">
                    <div id="scatterPlot" style="position: relative">
                    </div>
                    <div id="controlPanel">
                        <button id="resetButton" class="btn btn-secondary"
                            style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin-left:20px">Reset Zoom</button>
                        <button id="switchButton" class="btn btn-secondary"
                            style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin-left:20px">Switch Plot</button>
                        <label for="thresholdSelect">
                            <span
                                style="margin: 0; padding: 0; color: #ddd; margin-left:30px; margin-top: 10px; margin-bottom: 7px; display: inline-block;">Select
                                Threshold:</span>
                        </label>
                        <select id="thresholdSelect" class="btn btn-secondary dropdown-toggle"
                            style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin-left:10px">
                            <option value="0.05" selected>0.05</option>
                            <option value="0.01">0.01</option>
                        </select>
                        <div class="search-container">
                            <div id="searchInputContainer" style="position: relative;">
                                <input type="text" id="searchInput" class="form-control" placeholder="Search"
                                    style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin-left:40px">
                                <div id="searchResults" class="dropdown-content"
                                    style="display: none; position: absolute; top: 100%; left: 0; right: 0; z-index: 1000000; background-color: white;">
                                </div>
                            </div>
                            <!-- <button id="searchButton" class="btn btn-primary">Search</button> -->
                        </div>
                        <button id="toggleZoomButton" class="btn btn-secondary"
                            style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin-left:20px">Toggle Zoom/Brush
                            Mode</button>

                    </div>
                </div>
                <div id="style_scatter">
                    <div class="flex">
                        <div id="checkboxContainer"
                            style="overflow-y:scroll; max-height: 70px; color: white; width: 450px;margin-left: 0%; visibility: hidden;">
                            <!-- Checkboxes will be dynamically added here -->
                        </div>

                        <div id="checkbox" class="btn-group btn-group-toggle" data-toggle="buttons"
                            style="visibility: hidden; display: none;">
                            <label for="vehicle1" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle1" name="vehicle1" value="Age" checked
                                    onchange="handleCheckboxChange()">
                                Age</label>

                            <label for="vehicle2" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle2" name="vehicle2" value="Smoker"
                                    onchange="handleCheckboxChangeCigarettes()">
                                Smoker class</label>

                            <label for="vehicle3" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle3" name="vehicle3" value="Gender"
                                    onchange="handleCheckboxChangeGender()">
                                Gender</label>

                            <label for="vehicle4" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle4" name="vehicle4" value="Stage"
                                    onchange="handleCheckboxChangeStage()">
                                Stage</label>

                            <label for="vehicle5" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle5" name="vehicle5" value="type"
                                    onchange="handleCheckboxChangeType()">
                                Type</label>
                        </div>
                        <div id="radioBoxContainer"
                            style="overflow-y:scroll; max-height: 70px; color: white; width: 450px;margin-left: 10%; visibility: hidden;">
                            <!-- Checkboxes will be dynamically added here -->
                        </div>

                        <div id="radiobox" class="btn-group btn-group-toggle" data-toggle="buttons"
                            style="visibility: hidden; margin-left: 10%; display: none;">

                            <label for="variable1" class="btn btn-secondary active"
                                style="color: #ddd;  margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable1" name="variable" autocomplete="off" value="case"
                                    checked>
                                Case/Normal</label>


                            <label for="variable2" class="btn btn-secondary"
                                style="color: #ddd; margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable2" name="variable" autocomplete="off" value="Smoker">
                                Smoker class</label>


                            <label for="variable3" class="btn btn-secondary"
                                style="color: #ddd; margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable3" name="variable" autocomplete="off" value="Gender">
                                Gender</label>


                            <label for="variable4" class="btn btn-secondary"
                                style="color: #ddd; margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable4" name="variable" autocomplete="off" value="Stage">
                                Stage</label>
                        </div>
                        <!-- Add this div for the legend -->
                    </div>
                    <div id="parallelLegend" style="margin-top: 2px; color: #ddd;"></div>
                    <div id="parallelcoordinates" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <div class="flex-container" style="margin-top : 6px;">

            <div id="style_scatter">
                <div>
                    <div id="pca"></div>

                    <div style="display: flex; align-items: center; margin-bottom: 0px;"> <!-- Flex container -->
                        <!-- Dropdown for X-axis selection -->
                        <label for="x-axis-select" style="color: white; margin-right: 10px;">Select X-axis:</label>
                        <select id="x-axis-select" class="btn btn-secondary dropdown-toggle"
                            style="padding: 0.25rem 0.5rem; font-size: 0.875rem;">
                            <option value="pc1">PC1</option>
                            <option value="pc2">PC2</option>
                            <option value="pc3">PC3</option>
                            <option value="pc4">PC4</option>
                            <option value="pc5">PC5</option>
                            <option value="pc6">PC6</option>
                        </select>

                        <!-- Dropdown for Y-axis selection -->
                        <label for="y-axis-select" style="color: white; margin: 0 10px;">Select Y-axis:</label>
                        <select id="y-axis-select" class="btn btn-secondary dropdown-toggle"
                            style="padding: 0.25rem 0.5rem; font-size: 0.875rem;">
                            <option value="pc2">PC2</option>
                            <option value="pc1">PC1</option>
                            <option value="pc3">PC3</option>
                            <option value="pc4">PC4</option>
                            <option value="pc5">PC5</option>
                            <option value="pc6">PC6</option>
                        </select>

                        <!-- Update plot button -->
                        <button id="update-plot" class="btn btn-secondary"
                            style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin-left: 10px;">Update
                            Plot</button>

                        <!-- Placeholder with +/- buttons -->
                        <div style="display: flex; align-items: center; margin-left: 20px;">
                            <button id="decrease" class="btn btn-secondary"
                                style="padding: 0.25rem 0.5rem; font-size: 0.875rem;">-</button>
                            <span id="value-placeholder" style="margin: 0 10px; color: white;">6</span>
                            <!-- Placeholder value -->
                            <button id="increase" class="btn btn-secondary"
                                style="padding: 0.25rem 0.5rem; font-size: 0.875rem;">+</button>
                        </div>
                    </div>
                </div>
                <div id="heatmap"></div>

            </div>

            <div id="style_scatter"
                style="display: flex; justify-content: center; align-items: center; height: 100%; width: 99.5%;">
                <div class="flex"
                    style="display: flex; justify-content: center; align-items: center; height: 100%; width: 100%;">
                    <div id="counter"
                        style="color: white; border: 0.01px solid #ddd; border-bottom: none; border-right: none; border-left: none; width: 65%; height: 100%; box-sizing: border-box; text-align: left; justify-content: space-evenly;">
                    </div>
                    <div id="counter1"
                        style="color: white; border: 0.01px solid #ddd; border-bottom: none; border-right: none; width: 50%; height: 100%; box-sizing: border-box; text-align: left; justify-content: space-evenly;">
                    </div>
                </div>
            </div>

        </div>

    </div> <!-- div(1)-->

    <!-- Modal -->
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div class="flex1">

                <div>
                    <div id="dotplot"></div>
                    <div id="slider_dot_polot"></div>
                    <div id="select_dot"></div>
                </div>

                <div>
                    <div id="dotplot1"></div>
                    <div id="slider_dot_polot1"></div>
                    <div id="select_dot1"></div>

                </div>


            </div>


        </div>
    </div>
    <div id="myModal1"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 1000;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 800px;">
            <span class="close1"
                style="position: absolute; top: 10px; right: 20px; font-size: 24px; font-weight: bold; cursor: pointer;">&times;</span>

            <h2 style="margin-bottom: 20px; text-align: center; color: #333;">Select Clinical Data for Survival
                Analysis
            </h2>

            <form id="dropdownForm" style="margin-bottom: 20px;">
                <!-- Dropdown options go here -->
            </form>

            <form id="dropdownForm1" style="margin-bottom: 20px;">
                <!-- Additional dropdown options go here -->
            </form>

            <button id="submission" type="button" class="btn btn-secondary"
                style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;"
                disabled>Submit</button>

            <div id="survival" style="margin-top: 20px;">
                <!-- Survival analysis content goes here -->
            </div>
        </div>
    </div>


    </div>
    <script>

        try {
            ocpu.seturl("//localhost:8004/ocpu/lib/GEVIS/R");
        } catch (error) {
            // If an error occurs (e.g., ocpu is not defined), reload the page
            window.location.reload();
        }

        let chosen_statistic = ''

        let table1;
        let table2;

        let chosen_meta1
        let chosen_meta2
        let selectedRowName

        // This is for storing COLORS CHOSEN BY USER
        let colorScaleValues = {};
        let displayed_rows = 6;
        let case_number
        let normal_number
        let genes
        let variation_data;
        let variation_data_copy;
        let initial_num_genes;
        let data_upd
        let prc_IQR = 0.2;
        let thr_prc;
        let filteredData;
        let matrix;
        let data_original = [];
        let dataC_original = [];
        let dataN_original = [];
        let data_copy = [];
        let dataC_copy = [];
        let dataN_copy = [];
        let data_copy1 = [];
        let dataC_copy1 = [];
        let dataN_copy1 = [];
        let thr_fc = 1.1;
        let logFC_data;
        let log_thr_fc = Math.log2(thr_fc);
        let parsedLogFC;
        let parsedLogFC_origin;
        let parsedLogFC_origin1;
        let newdataJSON
        let newdataCJSON
        let first_filter_number_genes;
        let p_val_adj;
        let explainedVariance;
        let availablePCs
        let threshold = 0.05;
        let averageExpressions10C;
        let averageExpressions10N;
        let averageExpressionsC;
        let averageExpressionsN;
        let selectedGeneData = [];
        let greencircles = []
        let old_p_adj
        let transposedData = [];
        let ordering
        let metadata;
        let combinedData = []
        let combinedData1 = []
        let gsmList = []
        let data1;
        var json = []
        //info box plot
        let sumstat1
        var scatter;
        let sumstat
        var geneNameUP
        var geneNameDown
        let first_box = true
        /////////
        var currentCircleFill
        var first_dims = ['Age at Diagnosis']

        // Remove entries corresponding to ind from dataN
        let dataC_copy_pval

        // Remove entries corresponding to ind from dataN
        let dataN_copy_pval


        let data_copy_pval

        let deseq_p_adj = []

        // Remove entries corresponding to ind from logFC
        var parsedLogFC_pval
        var color_by = 'case'
        let pca_data = []
        let heatmap_data = []
        let square;

        let selectedVariable = "case"
        // Flag to track the current plot
        let currentPlot = 'volcano';

        let zoomEnabled = true; // Flag to control zoom functionality

        showOverlay()

        // Get the modal element
        var modal = document.getElementById("myModal");

        // Get the button that opens the modal
        var btn = document.getElementById("openModalBtn");

        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];

        // Function to display loading message inside the modal
        function showLoadingMessage() {
            var dotplotContainer = document.getElementById("dotplot");
            var dotplotContainer1 = document.getElementById("dotplot1");
            var slider = document.getElementById("slider_dot_polot");
            var selector = document.getElementById("select_dot");

            var slider1 = document.getElementById("slider_dot_polot1");
            var selector1 = document.getElementById("select_dot1");
            selector.innerHTML = "";
            slider.innerHTML = "";
            selector1.innerHTML = "";
            slider1.innerHTML = "";
            dotplotContainer1.innerHTML = "";
            dotplotContainer.innerHTML = "<h3 style='color: white'>Loading data from EnrichR.. </h3>";
        }

        // Function to create the dot plot inside the modal
        function createDotPlotInsideModal() {
            // Display loading message inside the modal
            showLoadingMessage();

            // Call your function to create the dot plot here
            DEG(data_copy_pval, parsedLogFC_pval, old_p_adj);
        }


        document.getElementById("openModalBtn").addEventListener("click", function () {
            const data = { data_copy_pval, parsedLogFC_pval, old_p_adj }; // Assuming you have these arrays defined elsewhere

            // Send data to server using fetch
            fetch('/enrichment', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ data: data })
            })
                .then(response => response.json())
                .then(response => {
                    // Redirect to /enrichment with unique identifier (sessionId)
                    window.open(`/enrichment?sessionId=${response.sessionId}`, '_blank');
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Failed to store enrichment data');
                });
        });

        // When the user clicks on <span> (x), close the modal
        span.onclick = function () {
            modal.style.display = "none";
            // Clear the content of the modal when it is closed
            var dotplotContainer = document.getElementById("dotplot");
            var dotplotContainer1 = document.getElementById("dotplot1");
            dotplotContainer.innerHTML = "";
            dotplotContainer1.innerHTML = "";
        }

        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function (event) {
            if (event.target == modal) {
                modal.style.display = "none";
                // Clear the content of the modal when it is closed
                var dotplotContainer = document.getElementById("dotplot");
                var dotplotContainer1 = document.getElementById("dotplot1");
                dotplotContainer.innerHTML = "";
                dotplotContainer1.innerHTML = "";
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////

        // Get the modal element
        var modal1 = document.getElementById("myModal1");

        // Get the button that opens the modal
        var btn1 = document.getElementById("openModalBtn1");

        // Get the button that opens the modal
        var btn2 = document.getElementById("submission");

        // Get the <span> element that closes the modal
        var span1 = document.getElementsByClassName("close1")[0];

        let second_time = false;

        // Function to display loading message inside the modal
        function showLoadingMessageSurv() {
            var survivalContainer = document.getElementById("survival");
            console.log(selectedGeneData)
        }

        // Function to create the dot plot inside the modal
        function createSurvivalPlotInsideModal() {
            // Display loading message inside the modal
            showLoadingMessageSurv();
        }


        document.getElementById("openModalBtn1").addEventListener("click", function () {
            modal1.style.display = "block";

            console.log(metadata);

            // Clear previous form contents
            const form = document.getElementById("dropdownForm");
            const form1 = document.getElementById("dropdownForm1");
            form.innerHTML = '';
            form1.innerHTML = '';

            // First dropdown label and menu
            const label = document.createElement('label');
            label.textContent = "Select the Event: Event Status: Death (0 = Alive, 1 = Deceased) ";
            label.style.display = 'block';
            label.style.color = '#333';  // Use a more subtle color than black
            label.style.marginBottom = '8px';  // Add spacing between the label and dropdown
            label.style.fontSize = '16px';  // Increase font size for better readability
            label.setAttribute('for', 'metadataDropdown1');
            form.appendChild(label);

            const select = document.createElement('select');
            select.id = 'metadataDropdown1';
            select.name = 'metadataSelection1';
            select.style.width = '100%';  // Make the dropdown take up the full width
            select.style.padding = '10px';  // Add padding for better appearance
            select.style.borderRadius = '4px';  // Rounded corners
            select.style.border = '1px solid #ccc';  // Light gray border
            select.style.marginBottom = '20px';  // Add space between this dropdown and the next element
            select.style.fontSize = '14px';  // Improve font size

            metadata.forEach((item) => {
                const option = document.createElement('option');
                option.value = item.Sample_geo_accession;
                option.textContent = item.Sample_geo_accession;
                select.appendChild(option);
            });

            form.appendChild(select);

            // Second dropdown label and menu
            const label1 = document.createElement('label');
            label1.textContent = "Select Time to Follow Up: (days)";
            label1.style.display = 'block';
            label1.style.color = '#333';
            label1.style.marginBottom = '8px';
            label1.style.fontSize = '16px';
            label1.setAttribute('for', 'metadataDropdown2');
            form1.appendChild(label1);

            const select1 = document.createElement('select');
            select1.id = 'metadataDropdown2';
            select1.name = 'metadataSelection2';
            select1.style.width = '100%';
            select1.style.padding = '10px';
            select1.style.borderRadius = '4px';
            select1.style.border = '1px solid #ccc';
            select1.style.marginBottom = '20px';
            select1.style.fontSize = '14px';

            metadata.forEach((item) => {
                const option = document.createElement('option');
                option.value = item.Sample_geo_accession;
                option.textContent = item.Sample_geo_accession;
                select1.appendChild(option);
            });

            form1.appendChild(select1);

            btn2.addEventListener('click', filterMetadata);
        });

        function filterMetadata() {
            const selectedEvent = document.getElementById('metadataDropdown1').value;
            const selectedTime = document.getElementById('metadataDropdown2').value;

            console.log("Metadata", metadata)

            // Filter the metadata based on the selections
            const filteredMetadata = metadata.filter(item => {
                // Get the first key dynamically
                const firstKey = Object.keys(item)[0];

                // Check if the first key's value matches the selected event or time
                return item[firstKey] === selectedEvent || item[firstKey] === selectedTime;
            });


            console.log('Filtered Metadata:', filteredMetadata);

            // Function to clean filteredMetadata by removing keys with empty values
            const cleanFilteredMetadata = (filteredMetadata) => {
                return filteredMetadata.map(item => {
                    // Create a new object to store cleaned entries
                    const cleanedItem = {};

                    for (const [key, value] of Object.entries(item)) {
                        // Check if the value is a valid number (float or integer) or not an empty string
                        const numValue = parseFloat(value); // Convert to float

                        if (value !== "" && !isNaN(numValue)) {
                            cleanedItem[key] = value;
                        }
                    }

                    return cleanedItem;
                });
            };


            // Clean the filteredMetadata
            const cleanedMetadata = cleanFilteredMetadata(filteredMetadata);

            // Log the result
            console.log(cleanedMetadata);

            // Extract gene names from dataC_copy_pval
            const geneNamesInDataC = dataC_copy_pval.map(item => item.gene);

            // Filter old_p_adj to only include genes present in dataC_copy_pval
            const filteredOldPAdj = old_p_adj.filter(item => geneNamesInDataC.includes(item.Gene));

            console.log('Filtered Old P Adj:', filteredOldPAdj);

            // Now you can send only the filtered data
            const data = { filteredMetadata: cleanedMetadata, dataC_copy_pval, old_p_adj: filteredOldPAdj };

            // Send data to server using fetch
            fetch('/survival', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ data: data })
            })
                .then(response => response.json())
                .then(response => {
                    // Redirect to /enrichment with unique identifier (sessionId)
                    window.open(`/survival?sessionId=${response.sessionId}`, '_blank');
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Failed to store survival data');
                });

            // You can further process or display the filteredMetadata here
        }

        //When the user clicks the button, open the modal and create the dot plot inside it
        btn1.onclick = function () {
            modal1.style.display = "block";
            // Display loading message inside the modal
            showLoadingMessageSurv();
            // Call function to create dot plot inside modal
            createSurvivalPlotInsideModal();
            btn2.disabled = false
        }

        // When the user clicks on <span> (x), close the modal
        span1.onclick = function () {
            modal1.style.display = "none";
            // Clear the content of the modal when it is closed
            var survivalContainer = document.getElementById("survival");
            survivalContainer.innerHTML = "";
        }

        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function (event) {
            if (event.target == modal1) {
                modal1.style.display = "none";
                // Clear the content of the modal when it is closed
                var survivalContainer = document.getElementById("survival");
                survivalContainer.innerHTML = "";
            }
        }

        let interval; // Variable to hold the interval ID

        // Function to increase the number of displayed rows
        function increaseRows() {
            if (displayed_rows < heatmap_data.length) {
                if (displayed_rows < 10 && displayed_rows >= 6) {
                    displayed_rows = 10; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                } else if (displayed_rows < 10 && displayed_rows < 6) {
                    displayed_rows++; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                }
                else if (displayed_rows >= 10) {
                    displayed_rows += 5; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                }
            }
        }

        // Function to decrease the number of displayed rows
        function decreaseRows() {
            if (displayed_rows > 2) {
                if (displayed_rows < 10 && displayed_rows >= 6) {
                    displayed_rows--; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                } else if (displayed_rows < 10 && displayed_rows <= 6) {
                    displayed_rows--; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                }
                else if (displayed_rows >= 10) {
                    displayed_rows -= 5; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                }
            }
        }

        // Add event listener for the "+" button to increase rows
        document.getElementById("increase").addEventListener("mousedown", function () {
            increaseRows(); // Call the increase function once
            interval = setInterval(increaseRows, 500); // Set interval to continuously increase
        });

        document.getElementById("increase").addEventListener("mouseup", function () {
            clearInterval(interval); // Clear the interval when the mouse is released
        });

        document.getElementById("increase").addEventListener("mouseleave", function () {
            clearInterval(interval); // Clear the interval if the mouse leaves the button
        });

        // Add event listener for the "-" button to decrease rows
        document.getElementById("decrease").addEventListener("mousedown", function () {
            decreaseRows(); // Call the decrease function once
            interval = setInterval(decreaseRows, 500); // Set interval to continuously decrease
        });

        document.getElementById("decrease").addEventListener("mouseup", function () {
            clearInterval(interval); // Clear the interval when the mouse is released
        });

        document.getElementById("decrease").addEventListener("mouseleave", function () {
            clearInterval(interval); // Clear the interval if the mouse leaves the button
        });



        ///////////////////////////////////////////////////////////////////////////////////////////

        function calculateLogFC(dataC, dataN) {
            const logFCData = [];

            // Iterate over each gene
            Object.keys(dataC).forEach(gene => {
                // Get the values for the current gene from dataC and dataN
                let valuesC = Object.values(dataC[gene]);
                let valuesN = Object.values(dataN[gene]);

                // Pop the last value if it's a gene string
                let geneValueC;
                if (isNaN(valuesC[valuesC.length - 1])) {
                    geneValueC = valuesC.pop(); // Remove and store the last value as the gene for dataC
                }
                let geneValueN;
                if (isNaN(valuesN[valuesN.length - 1])) {
                    geneValueN = valuesN.pop(); // Remove and store the last value as the gene for dataN
                }

                // Calculate the row mean for dataC and dataN
                const rowMeanC = valuesC.reduce((acc, val) => acc + val, 0) / valuesC.length;
                const rowMeanN = valuesN.reduce((acc, val) => acc + val, 0) / valuesN.length;

                // Calculate the log fold change
                const logFC = rowMeanC - rowMeanN;

                // Push the gene and its logFC to logFCData
                logFCData.push({ "Gene": geneValueC, "logFC": logFC });
            });

            return logFCData

        }

        function fetchJSON(url) {
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    // Rename the key '_row' to 'Gene' in each object of the JSON array
                    return data.map(obj => {
                        const newObj = { ...obj };
                        newObj['gene'] = newObj['_row'];
                        delete newObj['_row']; // Delete the old key
                        return newObj;
                    });
                })
                .catch(error => {
                    console.error('Error fetching JSON:', error);
                });
        }

        function fetchMeta(url) {
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('Error fetching JSON:', error);
                });
        }

        // Define a function to fetch data from a file with no header
        function fetchData(filename) {
            return fetch(filename)
                .then(response => response.text())
                .then(text => {
                    // Parse the data
                    const rows = text.trim().split('\n');

                    // Extract sample GSM identifiers from the first row (excluding the first element)
                    const sampleGSMs = rows[0].trim().split('\t').slice(1);

                    // Map each row to an object representing gene expression for each sample
                    matrix = rows.slice(1).map(row => {
                        const [gene, ...expressions] = row.trim().split('\t');

                        // Create an object with gene code as the key and an object with sample GSMs and expressions as the value
                        return {
                            gene: gene,
                            expressions: expressions.map(parseFloat)
                        };
                    });

                    // Create a matrix with GSMs as headers
                    const matrixWithHeaders = matrix.reduce((result, entry) => {
                        const geneObj = {
                            Gene: entry.gene, // Optional: Change the key to "Gene" if needed
                            ...Object.fromEntries(sampleGSMs.map((gsm, index) => [gsm, entry.expressions[index]]))
                        };
                        result.push(geneObj);
                        return result;
                    }, []);
                    return matrixWithHeaders; // Return the matrix with headers
                });
        }

        var width = 100,
            height = 100,
            n = 18,
            r = 5,
            π = Math.PI,
            p = 1000;
        const margin = { top: 10, right: 20, bottom: 30, left: 130 };

        var svg = d3.select("#scatterPlot").append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("background", "none")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        var gScatter = svg.selectAll("g")
            .data(d3.range(0, 2 * π, 2 * π / n))
            .enter().append("g")
            .attr("transform", function (d) {
                var x = width * (0.35 * Math.cos(d) + 0.5),
                    y = height * (0.35 * Math.sin(d) + 0.5);
                return "translate(" + [x, y] + ")rotate(" + d * 180 / π + ")";
            });
        var moonsScatter = gScatter.append("path")
            .attr("fill", "#808080");
        d3.timer(function (t) {
            var θ = 2 * π * (t % p / p);
            moonsScatter.attr("d", function (d) { return moon((θ + d) % (2 * π)); });
        });

        const margin1 = { top: 10, right: 20, bottom: 30, left: 5 };
        var svg1 = d3.select("#boxPlot").append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("background", "none")
            .attr("transform", `translate(${margin1.left},${margin1.top})`);

        var gBoxPlot = svg1.selectAll("g")
            .data(d3.range(0, 2 * π, 2 * π / n))
            .enter().append("g")
            .attr("transform", function (d) {
                var x = width * (0.35 * Math.cos(d) + 0.5),
                    y = height * (0.35 * Math.sin(d) + 0.5);
                return "translate(" + [x, y] + ")rotate(" + d * 180 / π + ")";
            });
        var moonsBoxPlot = gBoxPlot.append("path")
            .attr("fill", "#808080");
        d3.timer(function (t) {
            var θ = 2 * π * (t % p / p);
            moonsBoxPlot.attr("d", function (d) { return moon((θ + d) % (2 * π)); });
        });

        function moon(θ) {
            var rx0 = θ < π ? r : -r,
                s0 = θ < π ? 0 : 1,
                rx1 = r * Math.cos(θ),
                s1 = θ < π / 2 || (π <= θ && θ < 3 * π / 2) ? 0 : 1;
            return "M" + [0, r] +
                "A" + [rx0, r, 0, 0, s0, 0, -r] +
                "A" + [rx1, r, 0, 0, s1, 0, r];
        }

        document.getElementById("loadingOverlay").style.display = "none";

        document.getElementById("loadDatasetBtn").addEventListener("click", function () {
            hideOverlay();
            // Add your code to load the dataset here
        });


        // Function to show the overlay and modal
        function showOverlay() {
            document.getElementById("overlay").style.display = "block";
        }

        // Function to hide the overlay and modal
        function hideOverlay() {
            document.getElementById("overlay").style.display = "none";
        }

        // Function to show the CSV file loading overlay
        function showLoadCsvOverlay() {
            document.getElementById("loadDatasetOverlay").style.display = "block";
        }

        // Function to hide the CSV file loading overlay
        function hideLoadCsvOverlay() {
            document.getElementById("loadDatasetOverlay").style.display = "none";
        }

        // Event listener for the "Back" button
        document.getElementById('backBtn').addEventListener('click', () => {
            hideLoadCsvOverlay()
            showOverlay()
        });

        // Show help overlay
        document.getElementById('helpBtn').addEventListener('click', function () {
            document.getElementById('helpOverlay').style.display = 'block';
        });

        // Close help overlay
        document.getElementById('closeHelpOverlayBtn').addEventListener('click', function () {
            document.getElementById('helpOverlay').style.display = 'none';
        });

        // Optional: Close overlay when clicking outside of it
        document.getElementById('helpOverlay').addEventListener('click', function (event) {
            if (event.target === this) {
                this.style.display = 'none';
            }
        });



        // File paths
        const filePath1 = 'examples/matrix_lung.csv';
        const filePath2 = 'examples/metadata_lung.csv';

        // Fetch file data and create File objects
        function preloadFile(filePath, inputElement) {
            fetch(filePath)
                .then(response => response.blob())
                .then(blob => {
                    // Create a File object from the blob
                    const file = new File([blob], filePath, { type: blob.type });

                    // Create a DataTransfer to hold the File object
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);

                    // Assign the File object to the file input
                    inputElement.files = dataTransfer.files;
                })
                .catch(error => console.error('Error preloading file:', error));
        }

        // Preload the files into the file inputs
        document.addEventListener('DOMContentLoaded', () => {
            const loadCsvBtn = document.getElementById('loadCsvBtn');
            const fileInput1 = document.getElementById('fileInput1');
            const fileInput2 = document.getElementById('fileInput2');
            const notification = document.getElementById('notification');

            // // Initial notification
            // notification.textContent = "Please upload two CSV files.";
            // notification.style.color = '#555'; // Default color


            function checkFileType() {
                console.log(checkFileType)
                const file1 = fileInput1.files[0];
                const file2 = fileInput2.files[0];
                const isFile1Csv = file1 && (file1.name.endsWith('.csv') || file1.name.endsWith('.CSV'));
                const isFile2Csv = file2 && (file2.name.endsWith('.csv') || file2.name.endsWith('.CSV'));
                console.log("File 1 is CSV", isFile1Csv)
                console.log("File 2 is CSV", isFile2Csv)
                if (!file1 || !file2) {
                    notification.textContent = "Please upload two CSV files.";
                    notification.style.color = '#555'; // Default color
                }
                else if (isFile1Csv && isFile2Csv) {
                    loadCsvBtn.style.cursor = 'pointer';
                    loadCsvBtn.style.opacity = '1';
                    loadCsvBtn.disabled = false;
                    notification.textContent = "Both files are valid CSV files.";
                    notification.style.color = 'green';
                } else {
                    loadCsvBtn.style.cursor = 'not-allowed';
                    loadCsvBtn.style.opacity = '0.6';
                    loadCsvBtn.disabled = true;
                    notification.textContent = "Please ensure both files are valid CSV files.";
                    notification.style.color = 'red';

                }
            }

            fileInput1.addEventListener('change', checkFileType);
            fileInput2.addEventListener('change', checkFileType);
            tippy('.tippyBtn', {
                content: (reference) => reference.getAttribute('data-tippy-content'),
                arrow: true,
                animation: 'fade',
                duration: [200, 300],
                theme: 'light', // Optional: change the tooltip theme
                maxWidth: 300, // Optional: set maximum width for the tooltip
                allowHTML: true // Allows HTML content in tooltips

            });

            // preloadFile(filePath1, fileInput1);
            // preloadFile(filePath2, fileInput2);
        });


        document.getElementById("loadCsvBtn").addEventListener("click", function () {
            var fileInput1 = document.getElementById("fileInput1");
            var fileInput2 = document.getElementById("fileInput2");
            var file1 = fileInput1.files[0];
            var file2 = fileInput2.files[0];

            // Check if both files are selected
            if (!file1 && !file2) {
                alert("Please select at least one file");
                return;
            }

            if (file1 && !file2) {
                // If only the first file is selected, read and display it
                var reader1 = new FileReader();
                reader1.onload = function (e) {
                    var contents1 = e.target.result;
                    var data1 = parseCsv(contents1);
                    hideLoadCsvOverlay();
                    showDisplayCsvOverlay(data1);
                };
                reader1.readAsText(file1);
            } else {
                // If both files are selected, read and display both files
                var reader1 = new FileReader();
                var reader2 = new FileReader();
                var contents1; // Define contents1 in the outer scope

                reader1.onload = function (e) {
                    contents1 = e.target.result; // Assign contents1 in the onload function of reader1
                    reader2.readAsText(file2); // Read the second file once the first is loaded
                };

                reader2.onload = function (e) {
                    var contents2 = e.target.result;
                    data1 = parseCsv(contents1); // Use contents1 here
                    var data2 = parseCsv(contents2);
                    hideLoadCsvOverlay();
                    showDisplayCsvOverlay(data1, data2);
                };

                reader1.readAsText(file1); // Read the first file
            }
        });

        function parseCsv(contents) {
            var lines = contents.split('\n');
            var data = [];

            // Function to detect the delimiter (assuming this is already defined)
            var delimiter = detectDelimiter(lines[0]);
            console.log("Detected delimiter:", delimiter);

            // Parse headers and apply transformations
            var headers = lines[0].split(delimiter).map(header => header.trim()); // Trim headers

            // Transform headers: Ensure each header starts with 'X' and replace '-' with '.'
            headers = headers.map(header => {
                // Replace '-' with '.'
                header = header.replace(/-/g, '.');
                // Add 'X' at the beginning if the header starts with a number
                if (/^\d/.test(header)) {
                    header = 'X' + header;
                }
                return header;
            });

            for (var i = 1; i < lines.length; i++) {
                var obj = {};
                var currentline = lines[i].split(delimiter);
                if (currentline.length !== headers.length) {
                    continue; // Skip this line if the number of columns doesn't match the number of headers
                }
                for (var j = 0; j < headers.length; j++) {
                    obj[headers[j]] = currentline[j].trim(); // Trim data values
                    obj[headers[j]] = obj[headers[j]].replace(/\r/g, ''); // Remove carriage return characters
                }
                data.push(obj);
            }
            return data;
        }
        // Function to detect the delimiter in the CSV data
        function detectDelimiter(line) {
            // Check if the line contains a comma or a semicolon
            if (line.includes(',')) {
                return ',';
            } else if (line.includes(';')) {
                return ';';
            } else {
                // Default to comma if neither comma nor semicolon is found
                return ',';
            }
        }

        // Event listener for the "Load Dataset" button
        document.getElementById("loadDatasetBtn").addEventListener("click", function () {
            hideOverlay();
            showLoadCsvOverlay();
        });

        // Get references to the buttons and overlays
        var tryExampleBtn = document.getElementById("tryExampleBtn");
        var exampleOverlay = document.getElementById("tryExampleOverlay");

        // Function to show the example overlay
        function showExampleOverlay() {
            hideOverlay();
            exampleOverlay.style.display = "flex"; // Show the overlay
        }

        // Function to hide the example overlay
        function hideExampleOverlay() {
            exampleOverlay.style.display = "none"; // Hide the overlay
        }

        // Add event listener to the "Try Example" button
        tryExampleBtn.addEventListener("click", showExampleOverlay);

        // Add event listener to close the overlay if clicked outside the content
        exampleOverlay.addEventListener("click", function (event) {
            if (event.target === exampleOverlay) {
                hideExampleOverlay();
            }
        });

        document.getElementById('chooseExampleBtn').addEventListener('click', () => {
            const selectedExample = document.querySelector('input[name="exampleOption"]:checked');

            if (selectedExample) {
                const exampleValue = selectedExample.value;

                let filePath1 = '';
                let filePath2 = '';

                // Set file paths based on selected example
                if (exampleValue === 'example1') {
                    filePath1 = 'examples/matrix_lung.csv';
                    filePath2 = 'examples/metadata_lung.csv';
                } else if (exampleValue === 'example2') {
                    filePath1 = 'examples/matrix_myeloma.csv';
                    filePath2 = 'examples/metadata_myeloma.csv';
                } else if (exampleValue === 'example3') {
                    filePath1 = 'examples/matrix_CCA.csv';
                    filePath2 = 'examples/metadata_CCA.csv';
                } else if (exampleValue === 'example4') {
                    filePath1 = 'examples/airway_scaledcounts.csv';
                    filePath2 = 'examples/airway_metadata.csv';
                }


                // Load the first file
                fetch(filePath1)
                    .then(response => response.text())
                    .then(contents1 => {
                        const data1 = parseCsv(contents1);

                        // Load the second file
                        fetch(filePath2)
                            .then(response => response.text())
                            .then(contents2 => {
                                const data2 = parseCsv(contents2);

                                // Hide the overlay
                                document.getElementById('tryExampleOverlay').style.display = 'none';

                                // Display the CSV contents
                                showDisplayCsvOverlay(data1, data2);

                            })
                            .catch(error => {
                                console.error('Error loading the second file:', error);
                            });
                    })
                    .catch(error => {
                        console.error('Error loading the first file:', error);
                    });

            } else {
                alert('Please select an example to proceed.');
            }
        });


        // Event listener for the "Back" button
        document.getElementById('closeExampleOverlayBtn').addEventListener('click', () => {
            document.getElementById('tryExampleOverlay').style.display = 'none';
            showOverlay();
        });



        //**********************     INIZIO VECCHIA FUNZIONE INIZIALE LOADING DI TUTTI I VARI FILE  ******************************//
        /*
            document.getElementById("tryExampleBtn").addEventListener("click", function () {
                hideOverlay();
                document.getElementById("loadingOverlay").style.display = "block";
    
                Promise.all([fetchJSON('dataC_log.json'), fetchJSON('dataN_log.json'), fetchJSON('data_log.json'), fetchMeta('metadata.json')])
                    .then(([dataC, dataN, data, meta]) => {
                        dataC_original = dataC
                        dataN_original = dataN
                        data_original = data
                        console.log(data)
                        metadata = meta
                        fetch('variation_lung.txt')
                            .then(response => response.text())
                            .then(text => {
                                // Parse the data
                                const rows = text.split('\n');
                                variation_data = rows.slice(1).map(row => {
                                    const [gene, variation] = row.trim().split('\t');
                                    return parseFloat(variation);
                                });
                                console.log(variation_data)
                                const row_length = rows.length - 1
                                initial_num_genes = row_length
                                variation_data_copy = (variation_data);
                                console.log("numero di geni iniziali prima di qualsiasi filtro " + row_length)
    
                                thr_prc = ss.quantile(variation_data, prc_IQR);
                                updateHistogram(variation_data);
    
                                const ind = variation_data_copy.reduce((result, entry, index) => {
    
                                    if (entry < thr_prc) {
                                        result.push(index);
                                    }
                                    return result;
                                }, []);
    
                                if (ind.length > 0) {
    
                                    // Remove entries corresponding to ind from dataN
                                    data_copy1 = data_original.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from dataC
                                    dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from data
                                    dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from genes
                                    //genes = genes.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from logFC
                                    //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));
    
                                }
    
                                dataN_copy = dataN_copy1
                                dataC_copy = dataC_copy1
                                data_copy = data_copy1
                                console.log("geni tolti dal primo filtering del IQR", ind.length)
    
                                // Update the gene count display
                                // const geneCountDiv = document.getElementById('geneCount');
                                // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;
    
                                first_filter_number_genes = data_copy.length
                                console.log(dataC_original)
                                parsedLogFC_origin1 = calculateLogFC(dataC_original, dataN_original)
                                parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
                                parsedLogFC = parsedLogFC_origin
    
                                //  console.log("first parsed origin after",parsedLogFC_origin.length)
                                //  console.log("first data orign afterN ",dataN_copy.length)
                                //  console.log("first data orign afterC ",dataC_copy.length)
    
                                averageExpressions10C = calculateAverageLog10Expressions(dataC_copy);
                                averageExpressions10N = calculateAverageLog10Expressions(dataN_copy);
    
    
                                fetch('genes_and_pval_adj.json')
                                    .then(response => response.json())
                                    .then(data => {
                                        p_val_adj = data
    
                                        // Calculate the quantile
                                        log_thr_fc = Math.log2(1.1);
                                        //console.log(log_thr_fc)
                                        const ind = parsedLogFC_origin.reduce((result, entry, index) => {
    
                                            if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                                result.push(index);
    
                                            }
                                            return result;
                                        }, []);
                                        console.log("geni tolti dal primo filtering del LOGFC", ind.length)
    
                                        // console.log("parsed log before ",parsedLogFC.length)
                                        // console.log("data copy beforeC ",dataC_copy.length)
                                        // console.log("data copy beforeN ",dataN_copy.length)
    
                                        // console.log("parsed log origin ",parsedLogFC_origin.length)
                                        /////////////////////// 
    
                                        //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE
    
                                        //////////////////////
                                        // console.log(parsedLogFC_origin)
                                        // console.log(data_copy)
                                        if (ind.length > 0) {
    
                                            // Remove entries corresponding to ind from dataN
                                            dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));
    
                                            // Remove entries corresponding to ind from dataN
                                            dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));
    
                                            data_copy = data_copy1.filter((entry, index) => !ind.includes(index));
    
                                            parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
                                        }
    
                                        //////// DATI FILTRATI DAL PRIMO FOLD-CHANGE//////////////////
                                        // console.log(parsedLogFC)
                                        // console.log(data_copy)
    
                                        updateLogFCHistogram(parsedLogFC_origin)
    
                                        var req = ocpu.call("hello", {
                                            data: data_copy
                                        }, function (session) {
                                            var filteredDataURL = session.loc + "/R/.val/json";
                                            //console.log(session);
                                            // Fetch the filtered data from the URL
                                            fetch(filteredDataURL)
                                                .then(response => response.json())
                                                .then(data => {
                                                    old_p_adj = data
                                                    const ind = old_p_adj.reduce((result, entry, index) => {
    
                                                        if (entry.pval_adj > threshold) {
                                                            result.push(index);
                                                        }
                                                        return result;
                                                    }, []);
    
    
                                                    console.log("geni tolti dal primo filtering del pval", ind.length)
    
                                                    if (ind.length > 0) {
    
                                                        //console.log(parsedLogFC.length)
    
                                                        // Remove entries corresponding to ind from dataN
    
                                                        // Remove entries corresponding to ind from dataN
                                                        dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));
    
                                                        // Remove entries corresponding to ind from dataN
                                                        dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));
    
    
                                                        data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));
    
                                                        console.log("geni rimamenti dal primo filtering", data_copy.length)
                                                        // Remove entries corresponding to ind from logFC
                                                        parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));
    
                                                        parsedLogFC_pval = parsedLogFC
                                                        updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
    
                                                        console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)
    
                                                        var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);
    
                                                        var mostUpregulatedGene = sortedLogFC[0];
                                                        var secondMostUpregulatedGene = sortedLogFC[1];
    
                                                        var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                        var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];
    
                                                        var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                                                        //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                                                        var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                                                        //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene
    
    
                                                        genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
    
                                                        selectedGeneData.push(mostUpregulatedGeneName)
                                                        selectedGeneData.push(mostDownregulatedGeneName)
    
    
    
                                                        updateParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)
    
                                                        updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
    
                                                        updateCounter()
    
                                                        scatter.selectAll("circle")
                                                            .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
                                                            .style("fill", d => {
                                                                // Check if logFC is greater than or equal to the threshold
                                                                return "green";
    
                                                            })
                                                            .classed('pulse', true);
    
    
                                                        document.getElementById("checkbox").style.visibility = "visible";
                                                        document.getElementById("radiobox").style.visibility = "visible";
    
    
                                                    }
                                                    console.log(dataN_copy.length)
                                                    var pc1Values = [];
                                                    var pc2Values = [];
                                                    var groupValues = [];
                                                    var req = ocpu.call("pca", {
                                                        data: data_copy_pval,
                                                        dataN: dataN_copy_pval,
                                                        dataC: dataC_copy_pval
                                                    }, function (session) {
                                                        var filteredDataURL = session.loc + "/R/.val/json";
                                                        //console.log(session);
                                                        // Fetch the filtered data from the URL
                                                        fetch(filteredDataURL)
                                                            .then(response => response.json())
                                                            .then(data => {
                                                                json = data
                                                                console.log(filteredDataURL)
                                                                console.log(json)
    
                                                                var pc1Key = "PC1";
                                                                var pc2Key = "PC2";
                                                                var groupKey = "Group";
    
                                                                // Arrays to store PC1 and PC2 values
    
    
                                                                // Iterate over each object in the JSON array
                                                                json.scores_df.forEach(function (obj) {
                                                                    // Push PC1, PC2, and Group values to the arrays
                                                                    pc1Values.push(obj[pc1Key]);
                                                                    pc2Values.push(obj[pc2Key]);
                                                                    groupValues.push(obj[groupKey]);
                                                                });
                                                                // console.log(pc1Values)
    
                                                                pca_data = [];
    
                                                                // Iterate over each object in the JSON array
                                                                json.scores_df.forEach(function (obj) {
                                                                    // Retrieve additional data from metadata based on _row
                                                                    var gsm = obj._row;
                                                                    var group = obj.Group;
    
                                                                    // Retrieve smokerclass, stage, pc1, and pc2 from metadata
                                                                    var smokerclass = metadata['Cigarette Smoking Status:ch1'][metadata.geo_accession.indexOf(gsm)];
                                                                    var stage = metadata['Stage:ch1'][metadata.geo_accession.indexOf(gsm)];
                                                                    var pc1 = obj.PC1;
                                                                    var pc2 = obj.PC2;
    
                                                                    // Create an object with the required fields
                                                                    var newObj = {
                                                                        GSM: gsm,
                                                                        group: group,
                                                                        smokerclass: smokerclass,
                                                                        stage: stage,
                                                                        pc1: pc1,
                                                                        pc2: pc2
                                                                    };
    
                                                                    // Push the new object to the newData array
                                                                    pca_data.push(newObj);
    
    
                                                                });
                                                                heatmap_data = []
                                                                json.scores_var.forEach(function (obj) {
                                                                    // Push PC1, PC2, and Group values to the arrays
                                                                    var gene = obj._row
                                                                    var pc1 = obj.PC1
                                                                    var pc2 = obj.PC2
                                                                    var pc3 = obj.PC3
                                                                    var pc4 = obj.PC4
                                                                    var pc5 = obj.PC5
                                                                    var pc6 = obj.PC6
    
                                                                    var newObj = {
                                                                        gene: gene,
                                                                        pc1: pc1,
                                                                        pc2: pc2,
                                                                        pc3: pc3,
                                                                        pc4: pc4,
                                                                        pc5: pc5,
                                                                        pc6: pc6
                                                                    };
                                                                    heatmap_data.push(newObj);
                                                                })
                                                                // Display the newData array
                                                                console.log("PCA first computing", pca_data);
    
    
                                                                pca(pca_data);
                                                                heatmap(heatmap_data);
    
                                                            })
    
    
    
    
    
                                                    })
                                                    // DEG(data_copy_pval,parsedLogFC,old_p_adj)
                                                    // var req = ocpu.call("enrichment", {
                                                    //     data: data_copy
                                                    //     }, function (session) {
    
                                                    // })
                                                });
    
    
                                        })
                                        ///// DATI FILTRATI DAL PRIMO PVALUE, GIA' FILTRATI DAL PRIMO LOGFC, CHE ERANO GIA FILTRATI DA PRIMO IQR IN dataC_copy dataN_copy data_copy parsedLogFC ///////
    
    
                                        // Calculate the quantile
                                        log_thr_fc = Math.log2(thr_fc);
    
                                    })
                                const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
    
                                    if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                        result.push(index);
                                    }
                                    return result;
                                }, []);
    
                                // const geneCountDiv2 = document.getElementById('geneCount2');
                                // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;
    
    
                            })
                            .catch(error => console.error('Error reading file:', error));
    
                    });
            });*/

        //**********************     FINE VECCHIA FUNZIONE INIZIALE LOADING DI TUTTI I VARI FILE  ******************************//
        function isInteger(value) {
            return Number.isInteger(parseFloat(value));
        }


        async function quantileNormalize(data) {
            // Step 1: Extract sample values (ignoring the first key 'ID_REF')
            const sampleValues = data.map(row => Object.values(row).slice(1).map(parseFloat));

            // Step 2: Initialize rank matrix
            const rankMatrix = Array.from({ length: sampleValues[0].length }, () => new Array(sampleValues.length));

            // Step 3: Rank the values for each column
            for (let col = 0; col < sampleValues[0].length; col++) {
                const values = sampleValues.map(row => row[col]);
                const sortedIndices = Array.from(values.keys()).sort((a, b) => values[a] - values[b]);

                let currentRank = 1; // Start ranking from 1
                for (let i = 0; i < sortedIndices.length; i++) {
                    let tieCount = 1; // Count how many values are the same
                    while (i + 1 < sortedIndices.length && values[sortedIndices[i]] === values[sortedIndices[i + 1]]) {
                        tieCount++;
                        i++;
                    }
                    // Assign the same rank to all tied values
                    for (let j = 0; j < tieCount; j++) {
                        rankMatrix[col][sortedIndices[i - tieCount + 1 + j]] = currentRank;
                    }
                    // Move to the next rank
                    currentRank += tieCount;
                }
            }

            console.log("Rank Matrix:", rankMatrix);

            // Step 4: Rearranging the values in each column
            const rearrangedSamples = [];
            for (let col = 0; col < sampleValues[0].length; col++) {
                const columnValues = sampleValues.map(row => row[col]);
                rearrangedSamples[col] = columnValues.slice().sort((a, b) => a - b);
            }

            console.log("Rearranged Samples:", rearrangedSamples);

            // Step 5: Calculate the mean of the rearranged samples for each gene (row)
            const means = rearrangedSamples[0].map((_, rowIndex) => {
                const sum = rearrangedSamples.reduce((acc, curr) => acc + curr[rowIndex], 0);
                return sum / rearrangedSamples.length; // Average across the samples
            });

            console.log("Means:", means);

            // Step 6: Substitute the ranks with their corresponding mean values
            const normalizedData = data.map((row, rowIndex) => {
                let newRow = { [Object.keys(row)[0]]: row[Object.keys(row)[0]] }; // Keep the gene ID intact
                Object.keys(row).slice(1).forEach((_, colIndex) => {
                    // Get the rank for the current row from the rank matrix
                    const rank = rankMatrix[colIndex][rowIndex]; // Rank can be from 1 to the number of rows
                    // Use the mean value corresponding to the rank
                    newRow[Object.keys(row)[colIndex + 1]] = means[rank - 1]; // Subtract 1 for zero-based index
                });
                return newRow;
            });

            console.log("Normalized Data:", normalizedData);
            return normalizedData;
        }


        // Function to update the table with normalized data
        function updateTableWithNormalizedData(normalizedData) {
            // Clear the existing table content
            let tableBody1 = document.querySelector("#csvTableData1 tbody");
            tableBody1.innerHTML = ''; // Clear previous rows for table 1

            // Create header for normalized data
            const headers = Object.keys(normalizedData[0]).slice(0, 5);
            let tableData1 = "<thead><tr>";

            // Function to truncate headers longer than 8 characters
            function truncateHeader(header) {
                return header.length > 8 ? header.slice(0, 8) + "..." : header;
            }

            // Function to create a header with a tooltip
            function createHeaderCell(header) {
                const truncated = truncateHeader(header);
                return `<th title="${header}">${truncated}</th>`;
            }

            // Display headers for normalized data
            headers.forEach(function (key) {
                tableData1 += createHeaderCell(key);
            });
            tableData1 += "</tr></thead><tbody>";

            // Function to truncate text longer than a given length
            function truncateText(text, maxLength) {
                // Convert non-string values to string
                const textString = String(text);
                return textString.length > maxLength ? textString.slice(0, maxLength) + "..." : textString;
            }

            // Function to create a cell with a tooltip
            function createCell(text, maxLength) {
                const truncated = truncateText(text, maxLength);
                return `<td title="${text}">${truncated}</td>`;
            }

            // Display data rows for normalized data
            for (let i = 0; i < normalizedData.length; i++) {
                tableData1 += "<tr>";
                headers.forEach(function (key) {
                    let value = normalizedData[i][key]; // Get the value
                    tableData1 += createCell(value !== undefined ? value : '', 8); // Handle undefined
                });
                tableData1 += "</tr>";
            }
            tableData1 += "</tbody>";

            // Insert the created HTML into the table
            document.getElementById("csvTableData1").innerHTML = tableData1;

            // Reinitialize DataTables
            if (table1) {
                table1.destroy(); // Destroy the previous instance if it exists
            }
            table1 = $('#csvTableData1').DataTable({
                "paging": true,
                "pageLength": 5,
                ordering: false,
                searching: false,
                "lengthChange": false
            });
        }

        async function showDisplayCsvOverlay(data1, data2) {
            console.log(data1)

            document.getElementById("displayCsvOverlay").style.display = "block";

            // Display the first 10 columns of each CSV data in a table side by side
            var tableData1 = "<thead><tr>";
            var tableData2 = "<thead><tr>";

            // Determine the headers and data to display based on the presence of data1 and data2
            var headersData1 = [];
            var headersData2 = [];

            if (data1) {
                headersData1 = Object.keys(data1[0]).slice(0, 5);
                document.getElementById("totalColumns1").textContent = Object.keys(data1[0]).length;
            }

            if (data2) {
                headersData2 = Object.keys(data2[0]).slice(0, 5);
                document.getElementById("totalColumns2").textContent = Object.keys(data2[0]).length;
            }

            // Function to truncate headers longer than 8 characters
            function truncateHeader(header) {
                return header.length > 8 ? header.slice(0, 8) + "..." : header;
            }

            // Function to create a header with a tooltip
            function createHeaderCell(header) {
                const truncated = truncateHeader(header);
                return `<th title="${header}">${truncated}</th>`;
            }

            // Display headers for data1
            headersData1.forEach(function (key) {
                tableData1 += createHeaderCell(key);
            });
            tableData1 += "</tr></thead><tbody>";

            // Display headers for data2
            headersData2.forEach(function (key) {
                tableData2 += createHeaderCell(key);
            });
            tableData2 += "</tr></thead><tbody>";

            // Function to truncate text longer than a given length
            function truncateText(text, maxLength) {
                return text.length > maxLength ? text.slice(0, maxLength) + "..." : text;
            }

            // Function to create a cell with a tooltip
            function createCell(text, maxLength) {
                const truncated = truncateText(text, maxLength);
                return `<td title="${text}">${truncated}</td>`;
            }

            // Display data rows for data1
            for (var i = 0; i < data1.length; i++) {
                tableData1 += "<tr>";
                headersData1.forEach(function (key) {
                    tableData1 += createCell(data1[i][key] || '', 8);
                });
                tableData1 += "</tr>";
            }
            tableData1 += "</tbody>";

            // Display data rows for data2
            for (var i = 0; i < data2.length; i++) {
                tableData2 += "<tr>";
                headersData2.forEach(function (key) {
                    tableData2 += createCell(data2[i][key] || '', 8);
                });
                tableData2 += "</tr>";
            }
            tableData2 += "</tbody>";

            document.getElementById("csvTableData1").innerHTML = tableData1;
            document.getElementById("csvTableData2").innerHTML = tableData2;

            if (table1) {
                table1.destroy();
                table2.destroy();
            }

            table1 = $('#csvTableData1').DataTable({
                "paging": true, // Enable pagination
                "pageLength": 5, // Number of rows per page
                ordering: false,
                searching: false,
                "lengthChange": false
                // "scrollY": "200px", // Height of the scrolling container
                // "scrollCollapse": true // Collapse the table height to fit the scrolling container
            });

            // Initialize DataTable for the second table with virtual scrolling
            table2 = $('#csvTableData2').DataTable({
                "paging": true, // Enable pagination
                "pageLength": 5, // Number of rows per page
                ordering: false,
                searching: false,
                "lengthChange": false

                // "scrollY": "200px", // Height of the scrolling container
                // "scrollCollapse": true // Collapse the table height to fit the scrolling container
            });

            // Add CSS to hide the x-axis scrollbar
            $('#csvTableData2_wrapper .dataTables_scrollBody').css('overflow-x', 'hidden');


            // $('#csvTableData1_wrapper').css('margin-right', '40px');

            // Compare the headers excluding the first element
            var headers1ToCompare = Object.keys(data1[0]).slice(1);
            var headers2ToCompare = Object.keys(data2[0]).slice(1);
            var headersMatch = JSON.stringify(headers1ToCompare) === JSON.stringify(headers2ToCompare);

            // Create the message container and message element
            var messageContainer = document.getElementById('messageContainer');
            var messageElement = document.createElement('span');

            if (headersMatch) {
                messageElement.style.color = '#228B22'; // Better green color
                messageElement.innerHTML = '<span style="color: #228B22; font-weight: bold;">&#10003;</span> <strong>Everything looks good!</strong> The headers match, and the files are ready for analysis.';
                document.getElementById("selectMetadataBtn").disabled = false;
            } else {
                messageElement.style.color = 'red';
                messageElement.innerHTML = '<span style="color: red; font-weight: bold;">&#10008;</span> <strong>Heads up!</strong> The headers do not match. Please check the files and try again.';
                document.getElementById("selectMetadataBtn").disabled = true;
            }

            // Clear any existing message and add the new message
            messageContainer.innerHTML = ''; // Clear previous message
            messageContainer.appendChild(messageElement);

            // Make sure the message container is visible
            document.getElementById("displayCsvOverlay").style.display = "block";

            // Define the quantile normalization logic as a string
            const workerScript = `
                self.onmessage = function (event) {
                    const data = event.data;

                    function quantileNormalize(data) {
                        const sampleValues = data.map(row => Object.values(row).slice(1).map(parseFloat));
                        const rankMatrix = Array.from({ length: sampleValues[0].length }, () => new Array(sampleValues.length));

                        for (let col = 0; col < sampleValues[0].length; col++) {
                            const values = sampleValues.map(row => row[col]);
                            const sortedIndices = Array.from(values.keys()).sort((a, b) => values[a] - values[b]);

                            let currentRank = 1;
                            for (let i = 0; i < sortedIndices.length; i++) {
                                let tieCount = 1;
                                while (i + 1 < sortedIndices.length && values[sortedIndices[i]] === values[sortedIndices[i + 1]]) {
                                    tieCount++;
                                    i++;
                                }
                                for (let j = 0; j < tieCount; j++) {
                                    rankMatrix[col][sortedIndices[i - tieCount + 1 + j]] = currentRank;
                                }
                                currentRank += tieCount;
                            }
                        }

                        const rearrangedSamples = [];
                        for (let col = 0; col < sampleValues[0].length; col++) {
                            const columnValues = sampleValues.map(row => row[col]);
                            rearrangedSamples[col] = columnValues.slice().sort((a, b) => a - b);
                        }

                        const means = rearrangedSamples[0].map((_, rowIndex) => {
                            const sum = rearrangedSamples.reduce((acc, curr) => acc + curr[rowIndex], 0);
                            return sum / rearrangedSamples.length;
                        });

                        const normalizedData = data.map((row, rowIndex) => {
                            let newRow = { [Object.keys(row)[0]]: row[Object.keys(row)[0]] };
                            Object.keys(row).slice(1).forEach((_, colIndex) => {
                                const rank = rankMatrix[colIndex][rowIndex];
                                newRow[Object.keys(row)[colIndex + 1]] = means[rank - 1];
                            });
                            return newRow;
                        });

                        return normalizedData;
                    }

                    const normalizedData = quantileNormalize(data);
                    self.postMessage(normalizedData);
                };
                `;

            // Create a blob from the worker script
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            const workerURL = URL.createObjectURL(blob);

            // Initialize Tippy.js for 'quantileNormalizeBtn'
            var quantileNormalizeBtn = document.getElementById("quantileNormalizeBtn");

            var tippyInstanceQuantile = tippy(quantileNormalizeBtn, {
                content: "Quantile normalization ensures that the distribution of expression values is the same across all samples. If you choose to apply quantile normalization, DESeq2 will no longer be available as it requires raw, unnormalized count data.",
                placement: 'top',
                theme: 'light',
                interactive: true,  // Allow interaction with the tooltip
            });

            // Button click event for performing quantile normalization
            document.getElementById("quantileNormalizeBtn").addEventListener("click", function () {
                // Show loading overlay
                document.getElementById("loadingOverlay").style.display = "block";

                // Create a new Web Worker
                const worker = new Worker(workerURL);

                // Listen for messages from the worker
                worker.onmessage = function (event) {
                    data1 = event.data;

                    // Update the table with the normalized data
                    updateTableWithNormalizedData(data1);

                    // Remove the button after it's clicked
                    document.getElementById("quantileNormalizeBtn").style.display = 'none';

                    // Hide loading overlay
                    document.getElementById("loadingOverlay").style.display = "none";

                    // Terminate the worker
                    worker.terminate();
                    URL.revokeObjectURL(workerURL); // Clean up the object URL
                };

                // Send data to the worker for normalization
                worker.postMessage(data1);
            });


            document.getElementById("selectMetadataBtn").addEventListener("click", function () {

                // Create the all_int variable
                let all_int = data1.every(item => {
                    // Exclude the first field, typically 'ID_REF'
                    return Object.values(item).slice(1).every(isInteger);
                });

                console.log(all_int); // This will be true if all values (excluding the first) are integers

                // Hide the current overlay
                document.getElementById("displayCsvOverlay").style.display = "none";

                // Create a new overlay for selecting metadata rows
                var selectMetadataOverlay = document.createElement("div");
                selectMetadataOverlay.setAttribute("id", "selectMetadataOverlay");
                selectMetadataOverlay.setAttribute("style", "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; display: flex; justify-content: center; align-items: center;");
                document.body.appendChild(selectMetadataOverlay);

                // Create content for the overlay
                var selectMetadataContent = document.createElement("div");
                selectMetadataContent.setAttribute("style", "background-color: white; padding: 30px; border-radius: 8px; width: 80%; max-width: 800px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);");
                selectMetadataContent.innerHTML = `
        <h2 style="margin-bottom: 20px; font-size: 24px; color: #333; text-align: center;">Select Metadata Category</h2>
        <p style="margin-bottom: 20px; font-size: 16px; color: #555;">Please choose the category within the metadata that contains binary classifications (e.g., case vs. normal, male vs. female) for conducting the Differential Expression Gene (DEG) analysis:</p>
    `;


                // Create an array to keep track of all dropdown pairs
                var dropdownPairs = [];

                // Variables to store the selected values from the dropdowns
                var selectedValue1 = "";
                var selectedValue2 = "";


                // Create dropdown menus for each row in data2
                data2.forEach(function (row, index) {
                    var dropdownContainer = document.createElement("div");
                    dropdownContainer.setAttribute("style", "display: flex; align-items: center; margin-bottom: 10px;");

                    // Create radio button label
                    var radioLabel = document.createElement("label");
                    radioLabel.setAttribute("style", "margin-right: 10px;");
                    var radioButton = document.createElement("input");
                    radioButton.setAttribute("type", "radio");
                    radioButton.setAttribute("name", "metadataRow"); // Set the same name for all radio buttons to make them mutually exclusive
                    radioButton.setAttribute("value", index); // Use the index as the value for identifying the selected row
                    if (index === 0) {
                        radioButton.setAttribute("checked", "checked"); // Check the first radio button by default
                    }
                    radioLabel.appendChild(radioButton);
                    radioLabel.appendChild(document.createTextNode(row[Object.keys(row)[0]])); // Display the value of the first column
                    dropdownContainer.appendChild(radioLabel);

                    // Get the values of the selected row
                    var rowData = Object.values(data2[index]);
                    var values = rowData.slice(1); // Exclude the first value (name of the row)
                    var uniqueValues = Array.from(new Set(values)); // Convert Set to array for easier manipulation

                    // Create the first dropdown menu (dropdown1)
                    var dropdown1 = document.createElement("select");
                    dropdown1.setAttribute("name", "dropdown1");
                    dropdown1.setAttribute("style", "margin-left: 10px; width: 150px;");

                    // Create options for dropdown1
                    uniqueValues.forEach(function (value) {
                        var option = document.createElement("option");
                        option.textContent = value;
                        option.setAttribute("value", value);
                        dropdown1.appendChild(option);
                    });

                    // Set the first value as selected in dropdown1
                    dropdown1.selectedIndex = 0;
                    if (index === 0) {
                        selectedValue1 = dropdown1.options[0].value;
                    }

                    // Create the second dropdown menu (dropdown2)
                    var dropdown2 = document.createElement("select");
                    dropdown2.setAttribute("name", "dropdown2");
                    dropdown2.setAttribute("style", "width: 150px;");

                    // Create options for dropdown2 (same options as dropdown1)
                    uniqueValues.forEach(function (value) {
                        var option = document.createElement("option");
                        option.textContent = value;
                        option.setAttribute("value", value);
                        dropdown2.appendChild(option);
                    });

                    // Set the second value as selected in dropdown2
                    dropdown2.selectedIndex = 1;

                    if (index === 0) {
                        selectedValue2 = dropdown2.options[1].value;
                    }

                    // Disable dropdowns initially (except for the first pair)
                    if (index !== 0) {
                        dropdown1.disabled = true;
                        dropdown2.disabled = true;
                    }

                    // Add event listeners to synchronize dropdown values
                    dropdown1.addEventListener("change", function () {
                        selectedValue1 = dropdown1.value;
                        synchronizeDropdowns(dropdown1, dropdown2);
                    });

                    dropdown2.addEventListener("change", function () {
                        selectedValue2 = dropdown2.value;
                        synchronizeDropdowns(dropdown2, dropdown1);
                    });

                    // Function to synchronize dropdown values
                    function synchronizeDropdowns(dropdown1n, dropdown2n) {
                        var selectedValue = dropdown1n.value;
                        var selectedValuesec = dropdown2n.value;
                        if (selectedValuesec === selectedValue) {
                            dropdown2n.selectedIndex = (dropdown2n.selectedIndex + 1) % dropdown2n.options.length;
                            selectedValue2 = dropdown2n.value;
                        }
                    }

                    // Add event listener to radio button to enable/disable dropdowns
                    radioButton.addEventListener("change", function () {
                        if (radioButton.checked) {
                            enableDropdowns(index);
                        }
                    });

                    // Function to enable/disable dropdowns based on radio button selection
                    function enableDropdowns(selectedIndex) {
                        dropdownPairs.forEach(function (pair, i) {
                            var isSelected = (i === selectedIndex);
                            pair.dropdown1.disabled = !isSelected;
                            pair.dropdown2.disabled = !isSelected;
                            if (isSelected) {
                                // Update the selected values
                                selectedValue1 = pair.dropdown1.value;
                                selectedValue2 = pair.dropdown2.value;
                            }
                        });
                    }

                    // Create a span for the "vs" text
                    var vsText = document.createElement("span");
                    vsText.textContent = " vs ";
                    vsText.setAttribute("style", "margin: 0 10px;");

                    dropdownContainer.appendChild(dropdown1);
                    dropdownContainer.appendChild(vsText); // Add "vs" text between dropdowns
                    dropdownContainer.appendChild(dropdown2);

                    dropdownPairs.push({ dropdown1: dropdown1, dropdown2: dropdown2 });

                    selectMetadataContent.appendChild(dropdownContainer);
                });

                var buttonContainer = document.createElement("div");
                buttonContainer.setAttribute("style", "margin-top: 20px; display: flex; justify-content: space-between; gap: 10px;");

                var selectRowBtn = document.createElement("button");
                selectRowBtn.textContent = "Perform DEG with t-test\n(This may take a while. Don't panic if it seems stuck)";
                selectRowBtn.setAttribute("style", "flex: 1; padding: 10px; background-color: #CE2029; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: not-allowed; white-space: pre-line; opacity: 0.6;");
                selectRowBtn.disabled = true;

                var selectRowBtn2 = document.createElement("button");
                selectRowBtn2.textContent = "Perform DEG with limma\n(This may take a while. Don't panic if it seems stuck)";
                selectRowBtn2.setAttribute("style", "flex: 1; padding: 10px; background-color: #CE2029; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: not-allowed; white-space: pre-line; opacity: 0.6;");
                selectRowBtn2.disabled = true;

                var selectRowBtn3 = document.createElement("button");
                selectRowBtn3.textContent = "Perform DEG with deseq2\n(This may take a while. Don't panic if it seems stuck)";
                selectRowBtn3.setAttribute("style", "flex: 1; padding: 10px; background-color: #CE2029; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: not-allowed; white-space: pre-line; opacity: 0.6;");
                selectRowBtn3.disabled = true;

                // Create div containers for each disabled button
                var div1 = document.createElement("div");
                div1.style.display = "inline-block";  // Ensure inline display for proper alignment
                div1.style.pointerEvents = "auto";    // Allow pointer events on the div
                div1.appendChild(selectRowBtn);

                var div2 = document.createElement("div");
                div2.style.display = "inline-block";
                div2.style.pointerEvents = "auto";
                div2.appendChild(selectRowBtn2);

                var div3 = document.createElement("div");
                div3.style.display = "inline-block";
                div3.style.pointerEvents = "auto";
                div3.appendChild(selectRowBtn3);


                // Initialize Tippy.js for tooltips on div containers
                var tippyInstance1 = tippy(div1, {
                    content: "Select a color scheme for the visualization before proceeding. The t-test is a parametric test that compares the means of two groups to identify statistically significant differences. It assumes that the data follows a normal distribution and is suitable for comparing two conditions.",
                    placement: 'bottom',
                    theme: 'light',
                    interactive: true,  // Allow interaction with the tooltip
                });

                var tippyInstance2 = tippy(div2, {
                    content: "Select a color scheme for the visualization before proceeding. Limma (Linear Models for Microarray Data) is an advanced statistical method that borrows information across genes to improve detection power in differential expression analysis.",
                    placement: 'bottom',
                    theme: 'light',
                    interactive: true,  // Allow interaction with the tooltip
                });

                var tippyInstance3 = tippy(div3, {
                    content: "Select a color scheme for the visualization before proceeding. DESeq2 (Differential Expression using RNA-Seq 2) is a popular tool for analyzing RNA-Seq data. It requires raw count data with integer values. If your data contains non-integer or pre-processed values, DESeq2 will be disabled.",
                    placement: 'bottom',
                    theme: 'light',
                    interactive: true,  // Allow interaction with the tooltip
                });

                var selectColors = document.createElement("button");
                selectColors.textContent = "Select Color";
                selectColors.setAttribute("style", "padding: 10px; background-color: #FFC107; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;");

                selectColors.addEventListener("click", function () {

                    // Modify the content of the t-test tooltip
                    tippyInstance1.setContent("The t-test is a statistical test that compares the means of two groups to identify significant differences. Make sure to select a color scheme for visualization.");

                    // Modify the content of the t-test tooltip
                    tippyInstance2.setContent("Limma (Linear Models for Microarray Data) is an advanced statistical method that borrows information across genes to improve detection power in differential expression analysis.");

                    // Modify the content of the t-test tooltip
                    tippyInstance3.setContent("DESeq2 (Differential Expression using RNA-Seq 2) is a popular tool for analyzing RNA-Seq data. It requires raw count data with integer values. If your data contains non-integer or pre-processed values, DESeq2 will be disabled.");

                    // Create a new overlay for selecting colors
                    var selectColorOverlay = document.createElement("div");
                    selectColorOverlay.setAttribute("id", "selectColorOverlay");
                    selectColorOverlay.setAttribute("style", "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1003; display: flex; justify-content: center; align-items: center;");

                    var selectColorContent = document.createElement("div");
                    selectColorContent.setAttribute("style", "background-color: white; padding: 20px; border-radius: 5px;");

                    // Here you can add the logic to display the rows of metadata from the second file
                    // For now, let's just display a message
                    selectColorContent.innerHTML = "<h2>Select Colors</h2><p>Select a color for each unique value in the metadata categories:</p>";
                    console.log(data2)

                    data2.forEach(function (category, i) {
                        var rowData = Object.values(data2[i]); // Get the values of the selected row
                        var rowName = rowData[0];
                        var values = rowData.slice(1); // Exclude the first value (name of the row)
                        // Create an object to store the colors for this category
                        var categoryColors = {};

                        // Create a container for each category
                        var categoryContainer = document.createElement("div");
                        categoryContainer.classList.add("category-container");

                        // Create a label for the category
                        var categoryLabelContainer = document.createElement("div");
                        categoryLabelContainer.classList.add("category-label-container");

                        var categoryLabel = document.createElement("label");
                        categoryLabel.textContent = rowName + ": ";
                        categoryLabel.classList.add("category-label");
                        categoryLabelContainer.appendChild(categoryLabel);

                        // Create a "Resort Scale" button
                        var resortButton = document.createElement("button");
                        resortButton.textContent = "Resort Scale";
                        resortButton.classList.add("resort-button");
                        resortButton.addEventListener('click', function () {
                            // Resort the colors based on the current order
                            var colorInputs = categoryContainer.querySelectorAll('.color-input-container');
                            colorInputs.forEach(function (colorInputContainer, index) {
                                var value = colorInputContainer.querySelector('.value-span').textContent;
                                var colorInput = colorInputContainer.querySelector('.color-input');

                                // Reapply colors based on the order
                                if (uniqueValues.size >= 4) {
                                    var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                    colorInput.value = colorScale(index);
                                } else {
                                    colorInput.value = d3.schemeSet1[index % d3.schemeSet1.length];
                                }

                                // Update colorScaleValues
                                categoryColors[value] = colorInput.value;
                            });

                            // Update colorScaleValues object
                            colorScaleValues[rowName] = categoryColors;
                        });

                        resortButton.addEventListener('dblclick', function () {
                            // Reverse the colors based on the current order
                            var colorInputs = Array.from(categoryContainer.querySelectorAll('.color-input-container')).reverse();
                            colorInputs.forEach(function (colorInputContainer, index) {
                                var value = colorInputContainer.querySelector('.value-span').textContent;
                                var colorInput = colorInputContainer.querySelector('.color-input');

                                // Reapply colors based on the order
                                if (uniqueValues.size >= 4) {
                                    var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                    colorInput.value = colorScale(index);
                                } else {
                                    colorInput.value = d3.schemeSet1[index % d3.schemeSet1.length];
                                }

                                // Update colorScaleValues
                                categoryColors[value] = colorInput.value;
                            });

                            // Update colorScaleValues object
                            colorScaleValues[rowName] = categoryColors;
                        });

                        categoryLabelContainer.appendChild(resortButton);
                        categoryContainer.appendChild(categoryLabelContainer);

                        // Filter values that contain 'I' or 'IA'
                        var filteredValues = values.filter(value => {
                            return value === 'I' || value === 'IA' || value === 'II' || value === 'IB';
                        });

                        if (filteredValues.length > 0) {
                            values.sort();
                            values.reverse();
                        }

                        // Get unique values for the current category
                        var uniqueValues = new Set(values);

                        // Check if there are fewer than 9 unique values
                        if (uniqueValues.size < 9) {
                            // Create a Sortable instance for this group of unique values
                            var sortable = new Sortable(categoryContainer, {
                                draggable: '.color-input-container',
                                animation: 150,
                                onEnd: function (evt) {
                                    updateColorScaleValues();
                                }
                            });
                            // Create color inputs for each unique value
                            let colorIndex = 0;
                            uniqueValues.forEach(function (value) {
                                var colorInputContainer = document.createElement("div");
                                colorInputContainer.classList.add("color-input-container");

                                // Create a span to hold the unique value (centered)
                                var valueSpan = document.createElement("span");
                                valueSpan.textContent = value;
                                valueSpan.classList.add("value-span");
                                colorInputContainer.appendChild(valueSpan);

                                // Create a wrapper div for the color input
                                var inputWrapper = document.createElement("div");
                                inputWrapper.classList.add("input-wrapper");

                                // Create a color input (aligned to the right)
                                var colorInput = document.createElement("input");
                                colorInput.type = "color";
                                colorInput.id = "style1"; // Apply the style by setting the id
                                colorInput.name = category + "_" + value; // Use a unique name for each color input

                                // Assign specific colors for "female" and "male"
                                if (value === selectedValue1) {
                                    colorInput.value = d3.schemeSet1[0]
                                } else if (value === selectedValue2) {
                                    colorInput.value = d3.schemeSet1[2]
                                } else if (value.toLowerCase().includes("female")) {
                                    colorInput.value = d3.schemeSet1[7]; // Eighth color of the schemeSet1 for "female"
                                } else if (value.toLowerCase().includes("male")) {
                                    colorInput.value = d3.schemeSet1[1]; // Second color of the schemeSet1 for "male"
                                } else if (uniqueValues.size >= 4) {
                                    var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                    colorInput.value = colorScale(colorIndex);
                                    colorIndex++;
                                } else {
                                    colorInput.value = d3.schemeSet1[colorIndex % d3.schemeSet1.length]; // Default to cycling through the schemeSet1 colors
                                    colorIndex++;
                                }

                                colorInput.classList.add("color-input");
                                inputWrapper.appendChild(colorInput);

                                // Add an event listener to update colorScaleValues on color change
                                colorInput.addEventListener('input', updateColorScaleValues);

                                // Add the wrapper div to the color input container
                                colorInputContainer.appendChild(inputWrapper);

                                // Add the color input container to the category container
                                categoryContainer.appendChild(colorInputContainer);

                                // Store the category information in the colorScaleValues object
                                categoryColors[value] = colorInput.value;
                            });

                            // Add the category container to the selectColorContent element
                            selectColorContent.appendChild(categoryContainer);

                            // Store the initial colors for the category
                            colorScaleValues[rowName] = categoryColors;
                        }
                    });



                    // Function to update the color scale values
                    function updateColorScaleValues() {
                        // Clear the colorScaleValues object
                        colorScaleValues = {};

                        // Iterate over each category container
                        var categoryContainers = document.querySelectorAll('.category-container');
                        categoryContainers.forEach(function (container) {
                            // Get the category name
                            var categoryName = container.querySelector('.category-label').textContent.replace(':', '').trim();

                            // Create an object to store the colors for this category
                            var categoryColors = {};

                            // Iterate over each color input container in the category container
                            var colorInputContainers = container.querySelectorAll('.color-input-container');
                            colorInputContainers.forEach(function (colorInputContainer) {
                                // Get the value and color of the color input
                                var value = colorInputContainer.querySelector('.value-span').textContent;
                                var colorInput = colorInputContainer.querySelector('.color-input');
                                var color = colorInput.value;

                                // Store the value and color in the categoryColors object
                                categoryColors[value] = color;
                            });

                            // Store the categoryColors object in the colorScaleValues object
                            colorScaleValues[categoryName] = categoryColors;
                        });
                    }

                    // Add the overlay to the body
                    document.body.appendChild(selectColorOverlay);
                    selectColorOverlay.appendChild(selectColorContent);

                    console.log(colorScaleValues);
                    // Add a back button to go back to the previous step
                    var backBtn = document.createElement("button");
                    backBtn.textContent = "Save";
                    backBtn.addEventListener("click", function () {
                        selectColorOverlay.remove();
                        selectRowBtn.disabled = false; // Enable the button once colors are confirme
                        selectRowBtn.setAttribute("style", "flex: 1; padding: 10px; background-color: #CE2029; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; white-space: pre-line; opacity: 1.0;");
                        selectRowBtn2.disabled = false; // Enable the button once colors are confirmed
                        selectRowBtn2.setAttribute("style", "flex: 1; padding: 10px; background-color: #CE2029; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; white-space: pre-line; opacity: 1.0;");
                        if (all_int) {
                            selectRowBtn3.disabled = false;
                            selectRowBtn3.setAttribute("style", "flex: 1; padding: 10px; background-color: #CE2029; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; white-space: pre-line; opacity: 1.0;");
                        }
                        document.body.appendChild(selectMetadataOverlay);
                    });

                    selectColorContent.appendChild(backBtn);

                    selectColorOverlay.appendChild(selectColorContent);
                    document.body.appendChild(selectColorOverlay);

                });

                // console.log(data2)
                // console.log(data1)

                selectRowBtn2.addEventListener("click", async function () {
                    chosen_statistic = 'limma'
                    event.stopPropagation(); // Prevent event bubbling
                    var selectedRowIndex = document.querySelector('input[name="metadataRow"]:checked').value;
                    var rowData = Object.values(data2[selectedRowIndex]); // Get the values of the selected row
                    selectedRowName = rowData[0]
                    selectedVariable = selectedRowName
                    // console.log(selectedRowName)
                    first_dims = [selectedRowName]
                    var values = rowData.slice(1); // Exclude the first value (name of the row)

                    console.log("Two groups of values found:\SelectedValue 1: " + selectedValue1 + "\SelectedValue 2: " + selectedValue2);

                    // Hide the overlay
                    var selectMetadataOverlay = document.getElementById("selectMetadataOverlay");
                    if (selectMetadataOverlay) {
                        selectMetadataOverlay.style.display = "none";
                        selectMetadataOverlay.style.visibility = "hidden"; // Optional, if necessary
                        // Alternatively: $("selectMetadataOverlay").hide(); if using jQuery
                    }

                    // Show the loading overlay
                    document.getElementById("loadingOverlay").style.display = "block";

                    console.log("REMOVED")

                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulating async operation

                    var selectedValue = selectedValue1; // or group2[0] depending on which group represents the selected value
                    chosen_meta1 = selectedValue1
                    chosen_meta2 = selectedValue2


                    // Show the loading // Assuming you have already obtained the selected row index and values from data2
                    var dataC = [];
                    var dataN = [];


                    // console.log(data1, data2, selectedRowIndex, selectedValue)

                    // Convert function to string to create the worker
                    const workerCode = `
                        // Function to perform data transformations
                        function performDataTransformations(data1, data2, selectedRowIndex, selectedValue) {
                            var dataC = [];
                            var dataN = [];

                            // console.log(data1, data2, selectedRowIndex, selectedValue)

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the gene name from the first property of the object

                                // Create new objects for dataC and dataN
                                var newObjC = { "gene": gene };
                                var newObjN = { "gene": gene };

                                // Loop through the keys in the object and add values to newObjC and newObjN accordingly
                                for (var key in obj) {
                                    if (key !== Object.keys(obj)[0]) {
                                        // Check if the value in data2 matches the selected value
                                        if (data2[selectedRowIndex][key] === selectedValue) {
                                            newObjC[key] = obj[key]; // Add value to newObjC
                                        } else {
                                            newObjN[key] = obj[key]; // Add value to newObjN
                                        }
                                    }
                                }

                                // Push the new objects to dataC and dataN
                                dataC.push(newObjC);
                                dataN.push(newObjN);
                            }

                            // Create a new array to hold the reordered data
                            var reorderedData = [];

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the first value of the object

                                // Find the corresponding row in dataC and dataN
                                var rowDataN = dataN.find(row => row.gene === gene);
                                var rowDataC = dataC.find(row => row.gene === gene);

                                // Construct the new object with the desired structure
                                var reorderedObj = { "gene": gene };

                                // Add GSM values from dataN to reorderedObj
                                for (var key in rowDataN) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataN[key];
                                    }
                                }

                                // Add GSM values from dataC to reorderedObj
                                for (var key in rowDataC) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataC[key];
                                    }
                                }

                                // Push the new object to the reorderedData array
                                reorderedData.push(reorderedObj);
                            }

                            // Now, reorderedData contains the desired structure

                            data1 = reorderedData

                            case_number = Object.keys(dataC[0]).length - 1
                            normal_number = Object.keys(dataN[0]).length - 1

                            // console.log(case_number, normal_number)

                            // console.log(Object.keys(dataC[0]).length - 1)
                            // console.log(Object.keys(dataN[0]).length - 1)

                            // Assuming you have obtained genes from data1
                            var genes = data1.map(obj => obj[Object.keys(obj)[0]]);


                            // Calculate overall mean for data1
                            var overall_mean = data1.map(obj => {
                                var values = Object.values(obj).slice(1).map(parseFloat);
                                return values.reduce((acc, val) => acc + val, 0) / values.length;
                            });

                            // Filter out rows with overall mean equal to 0
                            var ind = overall_mean.reduce((acc, val, index) => {
                                if (val === 0) {
                                    // console.log("VALUE 0");
                                    acc.push(index);
                                }
                                return acc;
                            }, []);

                            // Filter dataC, dataN, data1, and genes based on ind
                            if (ind.length > 0) {
                                dataN = dataN.filter((_, index) => !ind.includes(index));
                                dataC = dataC.filter((_, index) => !ind.includes(index));
                                data1 = data1.filter((_, index) => !ind.includes(index));
                                genes = genes.filter((_, index) => !ind.includes(index));
                            }

                            // Logarithmic transformation for dataN, dataC, and data1
                            dataN = dataN.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            dataC = dataC.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            data1 = data1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            console.log("CIAO")

                            // Return the processed data
                            return {
                                dataC: dataC,
                                dataN: dataN,
                                data1: data1,
                                genes: genes, // Assuming genes are extracted from data1
                                case_number: case_number,
                                normal_number: normal_number
                            };
                        }

                        // Listen for messages from the main thread
                        self.addEventListener('message', function(e) {
                            // Retrieve data from the message
                            var { data1, data2, selectedRowIndex, selectedValue } = e.data;

                            // Perform data transformations
                            var result = performDataTransformations(data1, data2, selectedRowIndex, selectedValue);

                            // Send the result back to the main thread
                            postMessage(result);
                        }, false);
                    `;

                    // Create a Blob object from the worker code string
                    const blob = new Blob([workerCode], { type: 'application/javascript' });

                    // Create a URL for the blob object
                    const blobURL = URL.createObjectURL(blob);

                    // Create a new web worker from the blob URL
                    const worker = new Worker(blobURL);

                    // Promisify the web worker
                    function runWorker(worker, message) {
                        return new Promise((resolve, reject) => {
                            worker.onmessage = resolve;
                            worker.onerror = reject;
                            worker.postMessage(message);
                        });
                    }

                    // Start the data transformation process in the worker
                    runWorker(worker, {
                        data1: data1,
                        data2: data2,
                        selectedRowIndex: selectedRowIndex,
                        selectedValue: selectedValue1 // Change this to selectedValue2 if needed
                    }).then(result => {
                        console.log(result)
                        // Process the returned data
                        dataC = result.data.dataC;
                        dataN = result.data.dataN;
                        data1 = result.data.data1;
                        case_number = result.data.case_number;
                        normal_number = result.data.normal_number;
                        genes = result.data.genes;
                        // dataC, dataN, data1, genes, case_number, normal_number = result.data;

                        // Update your UI or further process the data as needed
                        console.log(dataC);
                        console.log(dataN);
                        console.log(data1);
                        console.log(genes);
                        console.log(case_number);
                        console.log(normal_number);

                        // Hide the loading overlay after all operations are complete
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();

                        // Start the next step
                        start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic, second_time);

                    }).catch(error => {
                        console.error('Error in web worker:', error);

                        // Hide the loading overlay on error
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();
                    });

                })

                selectRowBtn3.addEventListener("click", async function () {
                    chosen_statistic = 'deseq2'
                    document.getElementById("thresholdSlider").style.display = "none"
                    document.getElementById("thresholdValue").style.display = "none"
                    event.stopPropagation(); // Prevent event bubbling
                    var selectedRowIndex = document.querySelector('input[name="metadataRow"]:checked').value;
                    var rowData = Object.values(data2[selectedRowIndex]); // Get the values of the selected row
                    selectedRowName = rowData[0]
                    selectedVariable = selectedRowName
                    // console.log(selectedRowName)
                    first_dims = [selectedRowName]
                    var values = rowData.slice(1); // Exclude the first value (name of the row)

                    console.log("Two groups of values found:\SelectedValue 1: " + selectedValue1 + "\SelectedValue 2: " + selectedValue2);

                    // Hide the overlay
                    var selectMetadataOverlay = document.getElementById("selectMetadataOverlay");
                    if (selectMetadataOverlay) {
                        selectMetadataOverlay.style.display = "none";
                        selectMetadataOverlay.style.visibility = "hidden"; // Optional, if necessary
                        // Alternatively: $("selectMetadataOverlay").hide(); if using jQuery
                    }

                    // Show the loading overlay
                    document.getElementById("loadingOverlay").style.display = "block";

                    console.log("REMOVED")

                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulating async operation

                    var selectedValue = selectedValue1; // or group2[0] depending on which group represents the selected value
                    chosen_meta1 = selectedValue1
                    chosen_meta2 = selectedValue2


                    // Show the loading // Assuming you have already obtained the selected row index and values from data2
                    var dataC = [];
                    var dataN = [];


                    // console.log(data1, data2, selectedRowIndex, selectedValue)

                    // Convert function to string to create the worker
                    const workerCode = `
                        // Function to perform data transformations
                        function performDataTransformations(data1, data2, selectedRowIndex, selectedValue) {
                            var dataC = [];
                            var dataN = [];

                            // console.log(data1, data2, selectedRowIndex, selectedValue)

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the gene name from the first property of the object

                                // Create new objects for dataC and dataN
                                var newObjC = { "gene": gene };
                                var newObjN = { "gene": gene };

                                // Loop through the keys in the object and add values to newObjC and newObjN accordingly
                                for (var key in obj) {
                                    if (key !== Object.keys(obj)[0]) {
                                        // Check if the value in data2 matches the selected value
                                        if (data2[selectedRowIndex][key] === selectedValue) {
                                            newObjC[key] = obj[key]; // Add value to newObjC
                                        } else {
                                            newObjN[key] = obj[key]; // Add value to newObjN
                                        }
                                    }
                                }

                                // Push the new objects to dataC and dataN
                                dataC.push(newObjC);
                                dataN.push(newObjN);
                            }

                            // Create a new array to hold the reordered data
                            var reorderedData = [];

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the first value of the object

                                // Find the corresponding row in dataC and dataN
                                var rowDataN = dataN.find(row => row.gene === gene);
                                var rowDataC = dataC.find(row => row.gene === gene);

                                // Construct the new object with the desired structure
                                var reorderedObj = { "gene": gene };

                                // Add GSM values from dataN to reorderedObj
                                for (var key in rowDataN) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataN[key];
                                    }
                                }

                                // Add GSM values from dataC to reorderedObj
                                for (var key in rowDataC) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataC[key];
                                    }
                                }

                                // Push the new object to the reorderedData array
                                reorderedData.push(reorderedObj);
                            }

                            // Now, reorderedData contains the desired structure

                            data1 = reorderedData

                            case_number = Object.keys(dataC[0]).length - 1
                            normal_number = Object.keys(dataN[0]).length - 1

                            // console.log(case_number, normal_number)

                            // console.log(Object.keys(dataC[0]).length - 1)
                            // console.log(Object.keys(dataN[0]).length - 1)

                            // Assuming you have obtained genes from data1
                            var genes = data1.map(obj => obj[Object.keys(obj)[0]]);

                            // Return the processed data
                            return {
                                dataC: dataC,
                                dataN: dataN,
                                data1: data1,
                                genes: genes, // Assuming genes are extracted from data1
                                case_number: case_number,
                                normal_number: normal_number
                            };
                        }

                        // Listen for messages from the main thread
                        self.addEventListener('message', function(e) {
                            // Retrieve data from the message
                            var { data1, data2, selectedRowIndex, selectedValue } = e.data;

                            // Perform data transformations
                            var result = performDataTransformations(data1, data2, selectedRowIndex, selectedValue);

                            // Send the result back to the main thread
                            postMessage(result);
                        }, false);
                    `;

                    // Create a Blob object from the worker code string
                    const blob = new Blob([workerCode], { type: 'application/javascript' });

                    // Create a URL for the blob object
                    const blobURL = URL.createObjectURL(blob);

                    // Create a new web worker from the blob URL
                    const worker = new Worker(blobURL);

                    // Promisify the web worker
                    function runWorker(worker, message) {
                        return new Promise((resolve, reject) => {
                            worker.onmessage = resolve;
                            worker.onerror = reject;
                            worker.postMessage(message);
                        });
                    }

                    // Start the data transformation process in the worker
                    runWorker(worker, {
                        data1: data1,
                        data2: data2,
                        selectedRowIndex: selectedRowIndex,
                        selectedValue: selectedValue1 // Change this to selectedValue2 if needed
                    }).then(result => {
                        console.log(result)
                        // Process the returned data
                        dataC = result.data.dataC;
                        dataN = result.data.dataN;
                        data1 = result.data.data1;
                        case_number = result.data.case_number;
                        normal_number = result.data.normal_number;
                        genes = result.data.genes;
                        // dataC, dataN, data1, genes, case_number, normal_number = result.data;

                        // Update your UI or further process the data as needed
                        console.log(dataC);
                        console.log(dataN);
                        console.log(data1);
                        console.log(genes);
                        console.log(case_number);
                        console.log(normal_number);

                        // Hide the loading overlay after all operations are complete
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();

                        // Start the next step
                        start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic, second_time);

                    }).catch(error => {
                        console.error('Error in web worker:', error);

                        // Hide the loading overlay on error
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();
                    });

                })


                selectRowBtn.addEventListener("click", async function () {

                    chosen_statistic = 't-test'
                    event.stopPropagation(); // Prevent event bubbling
                    var selectedRowIndex = document.querySelector('input[name="metadataRow"]:checked').value;
                    var rowData = Object.values(data2[selectedRowIndex]); // Get the values of the selected row
                    selectedRowName = rowData[0]
                    selectedVariable = selectedRowName
                    // console.log(selectedRowName)
                    first_dims = [selectedRowName]
                    var values = rowData.slice(1); // Exclude the first value (name of the row)

                    console.log("Two groups of values found:\SelectedValue 1: " + selectedValue1 + "\SelectedValue 2: " + selectedValue2);

                    // Hide the overlay
                    var selectMetadataOverlay = document.getElementById("selectMetadataOverlay");
                    if (selectMetadataOverlay) {
                        selectMetadataOverlay.style.display = "none";
                        selectMetadataOverlay.style.visibility = "hidden"; // Optional, if necessary
                        // Alternatively: $("selectMetadataOverlay").hide(); if using jQuery
                    }

                    // Show the loading overlay
                    document.getElementById("loadingOverlay").style.display = "block";

                    console.log("REMOVED")

                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulating async operation

                    var selectedValue = selectedValue1; // or group2[0] depending on which group represents the selected value
                    chosen_meta1 = selectedValue1
                    chosen_meta2 = selectedValue2


                    // Show the loading // Assuming you have already obtained the selected row index and values from data2
                    var dataC = [];
                    var dataN = [];

                    // Convert function to string to create the worker
                    const workerCode = `
                        // Function to perform data transformations
                        function performDataTransformations(data1, data2, selectedRowIndex, selectedValue) {
                            var dataC = [];
                            var dataN = [];

                            // console.log(data1, data2, selectedRowIndex, selectedValue)

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the gene name from the first property of the object

                                // Create new objects for dataC and dataN
                                var newObjC = { "gene": gene };
                                var newObjN = { "gene": gene };

                                // Loop through the keys in the object and add values to newObjC and newObjN accordingly
                                for (var key in obj) {
                                    if (key !== Object.keys(obj)[0]) {
                                        // Check if the value in data2 matches the selected value
                                        if (data2[selectedRowIndex][key] === selectedValue) {
                                            newObjC[key] = obj[key]; // Add value to newObjC
                                        } else {
                                            newObjN[key] = obj[key]; // Add value to newObjN
                                        }
                                    }
                                }

                                // Push the new objects to dataC and dataN
                                dataC.push(newObjC);
                                dataN.push(newObjN);
                            }

                            // Create a new array to hold the reordered data
                            var reorderedData = [];

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the first value of the object

                                // Find the corresponding row in dataC and dataN
                                var rowDataN = dataN.find(row => row.gene === gene);
                                var rowDataC = dataC.find(row => row.gene === gene);

                                // Construct the new object with the desired structure
                                var reorderedObj = { "gene": gene };

                                // Add GSM values from dataN to reorderedObj
                                for (var key in rowDataN) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataN[key];
                                    }
                                }

                                // Add GSM values from dataC to reorderedObj
                                for (var key in rowDataC) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataC[key];
                                    }
                                }

                                // Push the new object to the reorderedData array
                                reorderedData.push(reorderedObj);
                            }

                            // Now, reorderedData contains the desired structure

                            data1 = reorderedData

                            case_number = Object.keys(dataC[0]).length - 1
                            normal_number = Object.keys(dataN[0]).length - 1

                            // console.log(case_number, normal_number)

                            // console.log(Object.keys(dataC[0]).length - 1)
                            // console.log(Object.keys(dataN[0]).length - 1)

                            // Assuming you have obtained genes from data1
                            var genes = data1.map(obj => obj[Object.keys(obj)[0]]);


                            // Calculate overall mean for data1
                            var overall_mean = data1.map(obj => {
                                var values = Object.values(obj).slice(1).map(parseFloat);
                                return values.reduce((acc, val) => acc + val, 0) / values.length;
                            });

                            // Filter out rows with overall mean equal to 0
                            var ind = overall_mean.reduce((acc, val, index) => {
                                if (val === 0) {
                                    // console.log("VALUE 0");
                                    acc.push(index);
                                }
                                return acc;
                            }, []);

                            // Filter dataC, dataN, data1, and genes based on ind
                            if (ind.length > 0) {
                                dataN = dataN.filter((_, index) => !ind.includes(index));
                                dataC = dataC.filter((_, index) => !ind.includes(index));
                                data1 = data1.filter((_, index) => !ind.includes(index));
                                genes = genes.filter((_, index) => !ind.includes(index));
                            }

                            // Logarithmic transformation for dataN, dataC, and data1
                            dataN = dataN.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            dataC = dataC.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            data1 = data1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            console.log("CIAO")

                            // Return the processed data
                            return {
                                dataC: dataC,
                                dataN: dataN,
                                data1: data1,
                                genes: genes, // Assuming genes are extracted from data1
                                case_number: case_number,
                                normal_number: normal_number
                            };
                        }

                        // Listen for messages from the main thread
                        self.addEventListener('message', function(e) {
                            // Retrieve data from the message
                            var { data1, data2, selectedRowIndex, selectedValue } = e.data;

                            // Perform data transformations
                            var result = performDataTransformations(data1, data2, selectedRowIndex, selectedValue);

                            // Send the result back to the main thread
                            postMessage(result);
                        }, false);
                    `;

                    // Create a Blob object from the worker code string
                    const blob = new Blob([workerCode], { type: 'application/javascript' });

                    // Create a URL for the blob object
                    const blobURL = URL.createObjectURL(blob);

                    // Create a new web worker from the blob URL
                    const worker = new Worker(blobURL);

                    // Promisify the web worker
                    function runWorker(worker, message) {
                        return new Promise((resolve, reject) => {
                            worker.onmessage = resolve;
                            worker.onerror = reject;
                            worker.postMessage(message);
                        });
                    }

                    // Start the data transformation process in the worker
                    runWorker(worker, {
                        data1: data1,
                        data2: data2,
                        selectedRowIndex: selectedRowIndex,
                        selectedValue: selectedValue1 // Change this to selectedValue2 if needed
                    }).then(result => {
                        console.log(result)
                        // Process the returned data
                        dataC = result.data.dataC;
                        dataN = result.data.dataN;
                        data1 = result.data.data1;
                        case_number = result.data.case_number;
                        normal_number = result.data.normal_number;
                        genes = result.data.genes;
                        // dataC, dataN, data1, genes, case_number, normal_number = result.data;

                        // Update your UI or further process the data as needed
                        console.log(dataC);
                        console.log(dataN);
                        console.log(data1);
                        console.log(genes);
                        console.log(case_number);
                        console.log(normal_number);

                        // Hide the loading overlay after all operations are complete
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();

                        // Start the next step
                        start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic, second_time);

                    }).catch(error => {
                        console.error('Error in web worker:', error);

                        // Hide the loading overlay on error
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();
                    });


                });
                buttonContainer.appendChild(div1);
                buttonContainer.appendChild(div2);
                buttonContainer.appendChild(div3);

                selectMetadataContent.appendChild(selectColors);
                selectMetadataContent.appendChild(buttonContainer);
                selectMetadataOverlay.appendChild(selectMetadataContent);

            });
        }


        function start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic, second) {
            if (second) {
                document.getElementById("loadingOverlay").style.display = "block";
            }
            document.getElementById("overlay").style.display = "none";
            // Hide all elements with the ID 'selectMetadataOverlay'
            const overlays = document.querySelectorAll('#selectMetadataOverlay');
            overlays.forEach(function (overlay) {
                overlay.style.display = 'none';
            });
            document.getElementById("myModal1").style.display = "none";
            updateChosenAnalysis()
            dataC_original = dataC
            dataN_original = dataN
            data_original = data1
            metadata = data2

            document.getElementById("nav").style.display = "flex"
            document.getElementById("main_div").style.display = "flex"

            if (chosen_statistic == 'deseq2') {

                updateStatisticalMethod('DESeq2');

                console.log(dataC_original)
                console.log(dataN_original)

                var dataN_or = dataN_original

                var dataC_or = dataC_original
                dataN_copy = dataN_original

                dataC_copy = dataC_original
                data_copy = data_original

                console.log(dataC_or)
                console.log(dataN_or)

                var req = ocpu.call("deseq2DE", {
                    dataC: dataC_or,  // Pass your processed case data
                    dataN: dataN_or   // Pass your processed normal data
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    //console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            console.log(session);
                            var data = data.filter(row => !isNaN(row.pval_adj));
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                                entry.logFC = parseFloat(entry.logFC); // Convert string to number if necessary
                            });
                            console.log(data_original)
                            console.log(data)

                            parsedLogFC = data.map(row => ({
                                "Gene": row.Gene,
                                "logFC": row.logFC
                            }));

                            // Step 1: Create a set of Gene values from the `data` array (these are genes remaining from the thres)
                            const geneSet = new Set(data.map(entry => entry.Gene));

                            // Step 2: Filter `data_original` to create `data_copy1` with only matching gene values
                            data_copy1 = data_original.filter(entry => geneSet.has(entry.gene));
                            dataC_copy1 = dataC_original.filter(entry => geneSet.has(entry.gene));
                            dataN_copy1 = dataN_original.filter(entry => geneSet.has(entry.gene));

                            console.log(data_copy1);

                            // Now, data*_copy1 contains the original data filtered by deseq2DE

                            parsedLogFC_origin1 = parsedLogFC
                            parsedLogFC_origin = parsedLogFC
                            console.log(parsedLogFC)

                            //  console.log("first parsed origin after",parsedLogFC_origin.length)
                            //  console.log("first data orign afterN ",dataN_copy.length)
                            //  console.log("first data orign afterC ",dataC_copy.length)

                            // This logarithmic transformation is needed for the scatter plot
                            var data_log = data_copy1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            var dataN_log = dataN_copy1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            var dataC_log = dataC_copy1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_log);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_log);

                            // Now is time to filter out the genes using the logFC

                            // Step 1: Initialize the geneset and log threshold
                            log_thr_fc = Math.log2(1.1);

                            // Step 2: Create a geneset of genes to keep based on the filtering condition
                            const geneset = new Set();
                            parsedLogFC_origin.forEach(entry => {
                                if (Math.abs(entry.logFC) >= log_thr_fc) {
                                    geneset.add(entry.Gene);  // Add the gene to the set if it passes the filter
                                }
                            });

                            console.log("Number of genes passing the LOGFC filter", geneset.size);

                            // Step 3: Filter dataC_copy1, dataN_copy1, data_copy1, and parsedLogFC_origin using the geneset
                            if (geneset.size > 0) {
                                dataC_copy = dataC_copy1.filter(entry => geneset.has(entry.gene));
                                dataN_copy = dataN_copy1.filter(entry => geneset.has(entry.gene));
                                data_copy = data_copy1.filter(entry => geneset.has(entry.gene));
                                parsedLogFC = parsedLogFC_origin.filter(entry => geneset.has(entry.Gene));
                            }

                            console.log("Filtered logFC dataC_copy", dataC_copy.length);
                            console.log("Filtered logFC dataN_copy", dataN_copy.length);
                            console.log("Filtered logFC data_copy", data_copy.length);
                            console.log("Filtered logFC parsedLogFC", parsedLogFC.length);

                            updateLogFCHistogram(parsedLogFC_origin)

                            // Rename '_row' to 'Gene'
                            data.forEach(entry => {
                                if (entry.hasOwnProperty('_row')) {
                                    entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                    delete entry._row; // Remove '_row' property
                                }
                            });

                            old_p_adj = data.filter(entry => geneset.has(entry.Gene))
                            deseq_p_adj = old_p_adj

                            // Step 1: Initialize the geneset and the p-value threshold
                            const geneset_pval = new Set();

                            // Step 2: Create a geneset of genes to keep based on the p-value condition
                            old_p_adj.forEach(entry => {
                                if (entry.pval_adj <= threshold) {  // Adjust condition according to your filtering logic
                                    geneset_pval.add(entry.Gene);  // Assuming 'Gene' is the property name
                                }
                            });

                            console.log("Number of genes passing the pval_adj filter", geneset_pval.size);

                            // Step 3: Filter dataC_copy, dataN_copy, and data_copy using the geneset_pval
                            if (geneset_pval.size > 0) {

                                //console.log(parsedLogFC.length)

                                dataC_copy_pval = dataC_copy.filter(entry => geneset_pval.has(entry.gene));

                                dataN_copy_pval = dataN_copy.filter(entry => geneset_pval.has(entry.gene));

                                data_copy_pval = data_copy.filter(entry => geneset_pval.has(entry.gene));

                                console.log("geni rimamenti dal primo filtering", data_copy.length)

                                // Remove entries corresponding to ind from logFC
                                //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                parsedLogFC_pval = parsedLogFC
                                console.log(log_thr_fc)
                                console.log(parsedLogFC_origin1)
                                console.log(old_p_adj)

                                if (parsedLogFC.length == 0) {
                                    alert("No deg found!")
                                }

                                console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                console.log(sortedLogFC)

                                var mostUpregulatedGene = sortedLogFC[0];

                                var secondMostUpregulatedGene = sortedLogFC[1];

                                var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                console.log(mostUpregulatedGene)

                                // Function to find the adjusted p-value for a given gene
                                function getAdjustedPValue(geneName) {
                                    const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                    return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                }

                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostUpregulatedGeneName);
                                }

                                if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostDownregulatedGeneName);
                                }

                                // Find the select element
                                var selectElement = document.getElementById("selectButton");

                                // Clear existing options
                                selectElement.innerHTML = "";

                                if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                    // Add the new options dynamically
                                    var option1 = document.createElement("option");
                                    option1.value = mostUpregulatedGene.Gene;
                                    option1.text = `${mostUpregulatedGene.Gene}`;
                                    option1.selected = true;
                                    selectElement.appendChild(option1);
                                }

                                if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                    var option2 = document.createElement("option");
                                    option2.value = mostDownregulatedGene.Gene;
                                    option2.text = `${mostDownregulatedGene.Gene}`;
                                    selectElement.appendChild(option2);
                                }

                                // updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)

                                data_copy = data_log.filter(entry => geneset.has(entry.gene))
                                dataC_copy = dataC_log.filter(entry => geneset.has(entry.gene))
                                dataN_copy = dataN_log.filter(entry => geneset.has(entry.gene))

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                                console.log(dataN_log[0])

                                updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                                updateCounter();
                                updateUpandDown();

                                scatter.selectAll("circle")
                                    .filter(circleData => circleData.Gene === mostUpregulatedGeneName || circleData.Gene === mostDownregulatedGeneName)
                                    .style("fill", d => {
                                        // Check if logFC is greater than or equal to the threshold
                                        return "green";

                                    })
                                    .classed('pulse', true);

                                // Function to handle checkbox change event
                                function handleCheckboxChange(event) {
                                    var isChecked = event.target.checked;
                                    var category = event.target.value;

                                    if (isChecked) {
                                        // Add category to first_dims array
                                        first_dims.unshift(category);
                                    } else {
                                        // Remove category from first_dims array
                                        var index = first_dims.indexOf(category);
                                        if (index !== -1) {
                                            first_dims.splice(index, 1);
                                        }
                                    }

                                    // Log the updated first_dims array
                                    console.log("Updated first_dims:", first_dims);

                                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                }


                                var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);

                                // Get the container element
                                var checkboxContainer = document.getElementById("checkboxContainer");

                                // Initialize a variable to count the number of checkboxes added to the current row
                                var checkboxesInRow = 0;

                                // Iterate through metadataCategories to create checkboxes
                                metadataCategories.forEach(function (category) {
                                    // Create a checkbox element
                                    var checkbox = document.createElement("input");
                                    checkbox.type = "checkbox";
                                    checkbox.value = category;
                                    checkbox.id = "checkbox_" + category; // Set a unique ID for each checkbox

                                    // Set the checked attribute based on condition
                                    if (category === selectedRowName) {
                                        checkbox.checked = true;
                                    }

                                    // Create a label for the checkbox
                                    var label = document.createElement("label");
                                    label.htmlFor = checkbox.id;
                                    label.appendChild(document.createTextNode(category));

                                    // Add event listener to the checkbox to handle change event
                                    checkbox.addEventListener("change", handleCheckboxChange);

                                    // Append the checkbox and label to the container element
                                    checkboxContainer.appendChild(checkbox);
                                    checkboxContainer.appendChild(label);

                                    // Increment the count of checkboxes in the row
                                    checkboxesInRow++;

                                    // Add a line break after every two checkboxes
                                    if (checkboxesInRow % 2 === 0) {
                                        checkboxContainer.appendChild(document.createElement("br"));
                                    }
                                });

                                // Initialize a variable to count the number of radio buttons added to the current row
                                var radioButtonsInRow = 0;
                                // Get the container element
                                var radioBoxContainer = document.getElementById("radioBoxContainer");

                                // Function to handle radio button change event
                                function handleRadioButtonChange(event) {
                                    // Update selectedVariable with the value of the selected radio button
                                    selectedVariable = event.target.value;

                                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                                }


                                // Iterate through metadataCategories to create radio buttons
                                // Count the unique values in the metadata category
                                function countUniqueValues(cat, j) {
                                    var uniqueValues = new Set(); // Use a Set to store unique values
                                    // Iterate through metadata categories to create y scales
                                    metadataCategories.forEach((category, i) => {
                                        if (j === i) {
                                            var values = Object.values(metadata[i]); // Extract values for the current category
                                            values.shift(); // Remove the first value (Sample_source_name_ch1)
                                            var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                            console.log("Values for", category, ":", uniqueValues);
                                            return uniqueValues.length; // Return the size of the Set, which is the count of unique values
                                        }
                                    });
                                }

                                // Iterate through metadataCategories to create radio buttons
                                metadataCategories.forEach(function (category, i) {
                                    // Check if the category has more than 9 unique values
                                    var values = Object.values(metadata[i]); // Extract values for the current category
                                    values.shift(); // Remove the first value (Sample_source_name_ch1)
                                    var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                    console.log("Values for", category, ":", uniqueValues);
                                    console.log(uniqueValues.length);
                                    if (uniqueValues.length >= 9) return

                                    // Create a radio button element
                                    var radioButton = document.createElement("input");
                                    radioButton.type = "radio";
                                    radioButton.name = "radioButtonGroup"; // Set the same name for all radio buttons in the group
                                    radioButton.value = category;
                                    radioButton.id = "radioButton_" + category; // Set a unique ID for each radio button

                                    // Set the checked attribute based on condition
                                    if (category === selectedRowName) {
                                        radioButton.checked = true;
                                    }

                                    // Create a label for the radio button
                                    var label = document.createElement("label");
                                    label.htmlFor = radioButton.id;
                                    label.appendChild(document.createTextNode(category));

                                    // Add event listener to the radio button to handle change event
                                    radioButton.addEventListener("change", handleRadioButtonChange);

                                    // Append the radio button and label to the container element
                                    radioBoxContainer.appendChild(radioButton);
                                    radioBoxContainer.appendChild(label);

                                    // Increment the count of radio buttons in the row
                                    radioButtonsInRow++;

                                    // Add a line break after every two radio buttons
                                    if (radioButtonsInRow % 2 === 0) {
                                        radioBoxContainer.appendChild(document.createElement("br"));
                                    }
                                });

                                document.getElementById("checkboxContainer").style.visibility = "visible";
                                document.getElementById("radioBoxContainer").style.visibility = "visible";


                            }
                            console.log(dataN_copy.length)
                            var pc1Values = [];
                            var pc2Values = [];
                            var groupValues = [];
                            if (data_copy_pval === undefined) {
                                alert("No deg found!")
                            }
                            console.log(data_copy_pval)
                            console.log(dataC_copy_pval)
                            console.log(dataN_copy_pval)
                            const geneNames = data_copy_pval.map(entry => entry.gene);
                            const uniqueGeneNames = new Set(geneNames);

                            if (geneNames.length !== uniqueGeneNames.size) {
                                console.error("Duplicate gene names detected in the input data.");
                            }
                            console.log(data_copy_pval)

                            var req = ocpu.call("pca", {
                                data: data_copy_pval,
                                dataN: dataN_copy_pval,
                                dataC: dataC_copy_pval
                            }, function (session) {
                                var filteredDataURL = session.loc + "/R/.val/json";
                                console.log(session);
                                // Fetch the filtered data from the URL
                                fetch(filteredDataURL)
                                    .then(response => response.json())
                                    .then(data => {
                                        json = data
                                        console.log(filteredDataURL)
                                        console.log(json)

                                        var pc1Key = "PC1";
                                        var pc2Key = "PC2";
                                        var groupKey = "Group";

                                        // Arrays to store PC1 and PC2 values


                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            pc1Values.push(obj[pc1Key]);
                                            pc2Values.push(obj[pc2Key]);
                                            groupValues.push(obj[groupKey]);
                                        });
                                        // console.log(pc1Values)

                                        // Extract metadata categories from the values of the first column
                                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                        console.log("Metadata categories:", metadataCategories);

                                        explainedVariance = json.explained_variance; // Access explained variance
                                        console.log("Explained variance", explainedVariance)

                                        // Initialize pca_data array
                                        pca_data = [];

                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Retrieve additional data from metadata based on _row
                                            var gsm = obj._row;
                                            var group = obj.Group;
                                            // Create an object with the required fields
                                            var newObj = {
                                                GSM: gsm,
                                                group: group,
                                            };

                                            // Check for the existence of each principal component before adding to newObj
                                            if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                            if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                            if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                            if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                            if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                            if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                            // Add metadata values for each category to the newObj
                                            metadataCategories.forEach((category, index) => {
                                                newObj[category] = metadata[index][gsm];
                                            });

                                            // Push the new object to the pca_data array
                                            pca_data.push(newObj);
                                        });

                                        heatmap_data = []
                                        json.scores_var.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            var gene = obj._row

                                            var newObj = {
                                                gene: gene,
                                            };
                                            // Check for the existence of each principal component before adding to newObj
                                            if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                            if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                            if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                            if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                            if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                            if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                            heatmap_data.push(newObj);
                                        })

                                        // Assuming you want to work with the first object in the array
                                        let obj = json.scores_df[0]; // Get the first object

                                        // Initialize an array to hold available principal components
                                        availablePCs = [];

                                        // Check for the existence of each principal component
                                        if (obj.PC1 !== undefined) availablePCs.push('pc1');
                                        if (obj.PC2 !== undefined) availablePCs.push('pc2');
                                        if (obj.PC3 !== undefined) availablePCs.push('pc3');
                                        if (obj.PC4 !== undefined) availablePCs.push('pc4');
                                        if (obj.PC5 !== undefined) availablePCs.push('pc5');
                                        if (obj.PC6 !== undefined) availablePCs.push('pc6');

                                        // Function to update the dropdowns based on available PCs
                                        function updateDropdowns() {
                                            const xAxisSelect = document.getElementById("x-axis-select");
                                            const yAxisSelect = document.getElementById("y-axis-select");

                                            // Clear existing options
                                            xAxisSelect.innerHTML = '';
                                            yAxisSelect.innerHTML = '';

                                            // Add available options to the X-axis dropdown
                                            availablePCs.forEach(function (pc) {
                                                const option = document.createElement("option");
                                                option.value = pc;
                                                option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                xAxisSelect.appendChild(option);
                                            });

                                            // Add available options to the Y-axis dropdown
                                            availablePCs.forEach(function (pc) {
                                                const option = document.createElement("option");
                                                option.value = pc;
                                                option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                yAxisSelect.appendChild(option);
                                            });

                                            // Set the default selected value for the Y-axis to PC2, if available
                                            if (availablePCs.includes("pc2")) {
                                                yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                                            }

                                        }

                                        // Call the function to update dropdowns
                                        updateDropdowns();

                                        // Display the newData array
                                        console.log("PCA, first try ", pca_data);
                                        if (obj.PC2 !== undefined) pca(pca_data);
                                        displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                                        document.getElementById("value-placeholder").textContent = displayed_rows;
                                        if (obj.PC2 !== undefined) heatmap(heatmap_data);
                                    })





                            })
                            // DEG(data_copy_pval,parsedLogFC,old_p_adj)
                            // var req = ocpu.call("enrichment", {
                            //     data: data_copy
                            //     }, function (session) {

                            // })
                        });


                })

            }
            else {

                var req = ocpu.call("variation", {
                    rawdata: data1,
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            document.getElementById("loadingOverlay").style.display = "none";

                            const innerData = JSON.parse(data[0]);
                            console.log(data1)

                            // Extract variation values from the inner JSON array
                            variation_data = innerData.map(obj => obj.Variation);

                            // Now you have an array of variation values, you can use it as needed
                            console.log(variation_data);
                            row_length = variation_data.length
                            initial_num_genes = row_length

                            console.log("numero di geni iniziali prima di qualsiasi filtro " + row_length)

                            thr_prc = ss.quantile(variation_data, prc_IQR);
                            updateHistogram(variation_data);
                            variation_data_copy = (variation_data);

                            const ind = variation_data_copy.reduce((result, entry, index) => {

                                if (entry < thr_prc) {
                                    result.push(index);
                                }
                                return result;
                            }, []);

                            console.log(ind)

                            if (ind.length > 0) {

                                // Remove entries corresponding to ind from dataN
                                data_copy1 = data_original.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from dataC
                                dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from data
                                dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));

                                data_original_cpy = data_copy1

                                dataC_original_cpy = dataC_copy1

                                dataN_original_cpy = dataN_copy1

                                // Remove entries corresponding to ind from genes
                                //genes = genes.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from logFC
                                //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                            }

                            dataN_copy = dataN_copy1
                            dataC_copy = dataC_copy1
                            data_copy = data_copy1
                            console.log("geni tolti dal primo filtering del IQR", ind.length)

                            // Update the gene count display
                            // const geneCountDiv = document.getElementById('geneCount');
                            // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;

                            first_filter_number_genes = data_copy.length
                            console.log(dataC_original)


                            parsedLogFC_origin1 = calculateLogFC(dataC_original, dataN_original)
                            parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
                            parsedLogFC = parsedLogFC_origin
                            console.log(parsedLogFC)

                            //  console.log("first parsed origin after",parsedLogFC_origin.length)
                            //  console.log("first data orign afterN ",dataN_copy.length)
                            //  console.log("first data orign afterC ",dataC_copy.length)

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy);

                            if (parsedLogFC) {

                                // Calculate the quantile
                                log_thr_fc = Math.log2(1.1);
                                //console.log(log_thr_fc)
                                const ind = parsedLogFC_origin.reduce((result, entry, index) => {

                                    if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                        result.push(index);

                                    }
                                    return result;
                                }, []);
                                console.log("geni tolti dal primo filtering del LOGFC", ind.length)

                                // console.log("parsed log before ",parsedLogFC.length)
                                // console.log("data copy beforeC ",dataC_copy.length)
                                // console.log("data copy beforeN ",dataN_copy.length)

                                // console.log("parsed log origin ",parsedLogFC_origin.length)
                                /////////////////////// 

                                //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE

                                //////////////////////
                                // console.log(parsedLogFC_origin)
                                // console.log(data_copy)
                                if (ind.length > 0) {

                                    // Remove entries corresponding to ind from dataN
                                    dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

                                    // Remove entries corresponding to ind from dataN
                                    dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));

                                    data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

                                    parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
                                }

                                //////// DATI FILTRATI DAL PRIMO FOLD-CHANGE//////////////////
                                // console.log(parsedLogFC)
                                // console.log(data_copy)

                                updateLogFCHistogram(parsedLogFC_origin)

                                if (chosen_statistic == 't-test') {
                                    updateStatisticalMethod('T-test');
                                    var req = ocpu.call("pval", {
                                        data: data_copy,
                                        N: normal_number,
                                        M: case_number
                                    }, function (session) {
                                        var filteredDataURL = session.loc + "/R/.val/json";
                                        //console.log(session);
                                        // Fetch the filtered data from the URL
                                        fetch(filteredDataURL)
                                            .then(response => response.json())
                                            .then(data => {
                                                console.log(session);
                                                // Convert pval_adj values back to numbers if needed
                                                data.forEach(entry => {
                                                    entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                                                });

                                                old_p_adj = data
                                                const ind = old_p_adj.reduce((result, entry, index) => {

                                                    if (entry.pval_adj > threshold) {
                                                        result.push(index);
                                                    }
                                                    return result;
                                                }, []);

                                                console.log(old_p_adj)
                                                console.log(ind)


                                                console.log("geni tolti dal primo filtering del pval", ind.length)

                                                if (ind.length > 0) {

                                                    //console.log(parsedLogFC.length)

                                                    // Remove entries corresponding to ind from dataN

                                                    // Remove entries corresponding to ind from dataN
                                                    dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                                    // Remove entries corresponding to ind from dataN
                                                    dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                                                    data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                                    console.log("geni rimamenti dal primo filtering", data_copy.length)
                                                    // Remove entries corresponding to ind from logFC
                                                    parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                                    parsedLogFC_pval = parsedLogFC
                                                    console.log(log_thr_fc)
                                                    console.log(parsedLogFC_origin1)
                                                    console.log(old_p_adj)

                                                    if (parsedLogFC.length == 0) {
                                                        alert("No deg found!")
                                                    }

                                                    console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                                    var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                                    console.log(sortedLogFC)

                                                    var mostUpregulatedGene = sortedLogFC[0];
                                                    var secondMostUpregulatedGene = sortedLogFC[1];

                                                    var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                    var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                                    console.log(mostUpregulatedGene)

                                                    // Function to find the adjusted p-value for a given gene
                                                    function getAdjustedPValue(geneName) {
                                                        const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                                        return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                                    }

                                                    var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                                    var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                                    // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                                    if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                                        selectedGeneData.push(mostUpregulatedGeneName);
                                                    }

                                                    if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                                        selectedGeneData.push(mostDownregulatedGeneName);
                                                    }
                                                    // Find the select element
                                                    var selectElement = document.getElementById("selectButton");

                                                    // Clear existing options
                                                    selectElement.innerHTML = "";

                                                    // Add the new options dynamically
                                                    var option1 = document.createElement("option");
                                                    option1.value = mostUpregulatedGene.Gene;
                                                    option1.text = `${mostUpregulatedGene.Gene}`;
                                                    option1.selected = true;
                                                    selectElement.appendChild(option1);

                                                    var option2 = document.createElement("option");
                                                    option2.value = mostDownregulatedGene.Gene;
                                                    option2.text = `${mostDownregulatedGene.Gene}`;
                                                    selectElement.appendChild(option2);


                                                    // updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)

                                                    dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)

                                                    updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                                                    updateCounter();
                                                    updateUpandDown();

                                                    scatter.selectAll("circle")
                                                        .filter(circleData => circleData.Gene === mostUpregulatedGeneName || circleData.Gene === mostDownregulatedGeneName)
                                                        .style("fill", d => {
                                                            // Check if logFC is greater than or equal to the threshold
                                                            return "green";

                                                        })
                                                        .classed('pulse', true);

                                                    // Function to handle checkbox change event
                                                    function handleCheckboxChange(event) {
                                                        var isChecked = event.target.checked;
                                                        var category = event.target.value;

                                                        if (isChecked) {
                                                            // Add category to first_dims array
                                                            first_dims.unshift(category);
                                                        } else {
                                                            // Remove category from first_dims array
                                                            var index = first_dims.indexOf(category);
                                                            if (index !== -1) {
                                                                first_dims.splice(index, 1);
                                                            }
                                                        }

                                                        // Log the updated first_dims array
                                                        console.log("Updated first_dims:", first_dims);

                                                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                                    }


                                                    var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);

                                                    // Get the container element
                                                    var checkboxContainer = document.getElementById("checkboxContainer");

                                                    // Initialize a variable to count the number of checkboxes added to the current row
                                                    var checkboxesInRow = 0;

                                                    // Iterate through metadataCategories to create checkboxes
                                                    metadataCategories.forEach(function (category) {
                                                        // Create a checkbox element
                                                        var checkbox = document.createElement("input");
                                                        checkbox.type = "checkbox";
                                                        checkbox.value = category;
                                                        checkbox.id = "checkbox_" + category; // Set a unique ID for each checkbox

                                                        // Set the checked attribute based on condition
                                                        if (category === selectedRowName) {
                                                            checkbox.checked = true;
                                                        }

                                                        // Create a label for the checkbox
                                                        var label = document.createElement("label");
                                                        label.htmlFor = checkbox.id;
                                                        label.appendChild(document.createTextNode(category));

                                                        // Add event listener to the checkbox to handle change event
                                                        checkbox.addEventListener("change", handleCheckboxChange);

                                                        // Append the checkbox and label to the container element
                                                        checkboxContainer.appendChild(checkbox);
                                                        checkboxContainer.appendChild(label);

                                                        // Increment the count of checkboxes in the row
                                                        checkboxesInRow++;

                                                        // Add a line break after every two checkboxes
                                                        if (checkboxesInRow % 2 === 0) {
                                                            checkboxContainer.appendChild(document.createElement("br"));
                                                        }
                                                    });

                                                    // Initialize a variable to count the number of radio buttons added to the current row
                                                    var radioButtonsInRow = 0;
                                                    // Get the container element
                                                    var radioBoxContainer = document.getElementById("radioBoxContainer");

                                                    // Function to handle radio button change event
                                                    function handleRadioButtonChange(event) {
                                                        // Update selectedVariable with the value of the selected radio button
                                                        selectedVariable = event.target.value;

                                                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                                                    }


                                                    // Iterate through metadataCategories to create radio buttons
                                                    // Count the unique values in the metadata category
                                                    function countUniqueValues(cat, j) {
                                                        var uniqueValues = new Set(); // Use a Set to store unique values
                                                        // Iterate through metadata categories to create y scales
                                                        metadataCategories.forEach((category, i) => {
                                                            if (j === i) {
                                                                var values = Object.values(metadata[i]); // Extract values for the current category
                                                                values.shift(); // Remove the first value (Sample_source_name_ch1)
                                                                var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                                                console.log("Values for", category, ":", uniqueValues);
                                                                return uniqueValues.length; // Return the size of the Set, which is the count of unique values
                                                            }
                                                        });
                                                    }

                                                    // Iterate through metadataCategories to create radio buttons
                                                    metadataCategories.forEach(function (category, i) {
                                                        // Check if the category has more than 9 unique values
                                                        var values = Object.values(metadata[i]); // Extract values for the current category
                                                        values.shift(); // Remove the first value (Sample_source_name_ch1)
                                                        var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                                        console.log("Values for", category, ":", uniqueValues);
                                                        console.log(uniqueValues.length);
                                                        if (uniqueValues.length >= 9) return

                                                        // Create a radio button element
                                                        var radioButton = document.createElement("input");
                                                        radioButton.type = "radio";
                                                        radioButton.name = "radioButtonGroup"; // Set the same name for all radio buttons in the group
                                                        radioButton.value = category;
                                                        radioButton.id = "radioButton_" + category; // Set a unique ID for each radio button

                                                        // Set the checked attribute based on condition
                                                        if (category === selectedRowName) {
                                                            radioButton.checked = true;
                                                        }

                                                        // Create a label for the radio button
                                                        var label = document.createElement("label");
                                                        label.htmlFor = radioButton.id;
                                                        label.appendChild(document.createTextNode(category));

                                                        // Add event listener to the radio button to handle change event
                                                        radioButton.addEventListener("change", handleRadioButtonChange);

                                                        // Append the radio button and label to the container element
                                                        radioBoxContainer.appendChild(radioButton);
                                                        radioBoxContainer.appendChild(label);

                                                        // Increment the count of radio buttons in the row
                                                        radioButtonsInRow++;

                                                        // Add a line break after every two radio buttons
                                                        if (radioButtonsInRow % 2 === 0) {
                                                            radioBoxContainer.appendChild(document.createElement("br"));
                                                        }
                                                    });

                                                    document.getElementById("checkboxContainer").style.visibility = "visible";
                                                    document.getElementById("radioBoxContainer").style.visibility = "visible";


                                                }
                                                console.log(dataN_copy.length)
                                                var pc1Values = [];
                                                var pc2Values = [];
                                                var groupValues = [];
                                                console.log(data_copy_pval)
                                                var req = ocpu.call("pca", {
                                                    data: data_copy_pval,
                                                    dataN: dataN_copy_pval,
                                                    dataC: dataC_copy_pval
                                                }, function (session) {
                                                    var filteredDataURL = session.loc + "/R/.val/json";
                                                    //console.log(session);
                                                    // Fetch the filtered data from the URL
                                                    fetch(filteredDataURL)
                                                        .then(response => response.json())
                                                        .then(data => {
                                                            json = data
                                                            console.log(filteredDataURL)
                                                            console.log(json)

                                                            var pc1Key = "PC1";
                                                            var pc2Key = "PC2";
                                                            var groupKey = "Group";


                                                            // Iterate over each object in the JSON array
                                                            json.scores_df.forEach(function (obj) {
                                                                // Push PC1, PC2, and Group values to the arrays
                                                                pc1Values.push(obj[pc1Key]);
                                                                pc2Values.push(obj[pc2Key]);
                                                                groupValues.push(obj[groupKey]);
                                                            });
                                                            // console.log(pc1Values)

                                                            // Extract metadata categories from the values of the first column
                                                            var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                                            console.log("Metadata categories:", metadataCategories);

                                                            explainedVariance = json.explained_variance; // Access explained variance
                                                            console.log("Explained variance", explainedVariance)

                                                            // Initialize pca_data array
                                                            pca_data = [];

                                                            // Iterate over each object in the JSON array
                                                            json.scores_df.forEach(function (obj) {
                                                                // Retrieve additional data from metadata based on _row
                                                                var gsm = obj._row;
                                                                var group = obj.Group;
                                                                // Create an object with the required fields
                                                                var newObj = {
                                                                    GSM: gsm,
                                                                    group: group,
                                                                };

                                                                // Check for the existence of each principal component before adding to newObj
                                                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                                                // Add metadata values for each category to the newObj
                                                                metadataCategories.forEach((category, index) => {
                                                                    newObj[category] = metadata[index][gsm];
                                                                });

                                                                // Push the new object to the pca_data array
                                                                pca_data.push(newObj);
                                                            });

                                                            heatmap_data = []
                                                            json.scores_var.forEach(function (obj) {
                                                                // Push PC1, PC2, and Group values to the arrays
                                                                var gene = obj._row

                                                                var newObj = {
                                                                    gene: gene,
                                                                };
                                                                // Check for the existence of each principal component before adding to newObj
                                                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                                                heatmap_data.push(newObj);
                                                            })

                                                            // Assuming you want to work with the first object in the array
                                                            let obj = json.scores_df[0]; // Get the first object

                                                            // Initialize an array to hold available principal components
                                                            availablePCs = [];

                                                            // Check for the existence of each principal component
                                                            if (obj.PC1 !== undefined) availablePCs.push('pc1');
                                                            if (obj.PC2 !== undefined) availablePCs.push('pc2');
                                                            if (obj.PC3 !== undefined) availablePCs.push('pc3');
                                                            if (obj.PC4 !== undefined) availablePCs.push('pc4');
                                                            if (obj.PC5 !== undefined) availablePCs.push('pc5');
                                                            if (obj.PC6 !== undefined) availablePCs.push('pc6');

                                                            // Function to update the dropdowns based on available PCs
                                                            function updateDropdowns() {
                                                                const xAxisSelect = document.getElementById("x-axis-select");
                                                                const yAxisSelect = document.getElementById("y-axis-select");

                                                                // Clear existing options
                                                                xAxisSelect.innerHTML = '';
                                                                yAxisSelect.innerHTML = '';

                                                                // Add available options to the X-axis dropdown
                                                                availablePCs.forEach(function (pc) {
                                                                    const option = document.createElement("option");
                                                                    option.value = pc;
                                                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                                    xAxisSelect.appendChild(option);
                                                                });

                                                                // Add available options to the Y-axis dropdown
                                                                availablePCs.forEach(function (pc) {
                                                                    const option = document.createElement("option");
                                                                    option.value = pc;
                                                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                                    yAxisSelect.appendChild(option);
                                                                });

                                                                // Set the default selected value for the Y-axis to PC2, if available
                                                                if (availablePCs.includes("pc2")) {
                                                                    yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                                                                }

                                                            }

                                                            // Call the function to update dropdowns
                                                            updateDropdowns();

                                                            // Display the newData array
                                                            console.log("PCA, first try ", pca_data);
                                                            if (obj.PC2 !== undefined) pca(pca_data);
                                                            displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                                                            document.getElementById("value-placeholder").textContent = displayed_rows;
                                                            if (obj.PC2 !== undefined) heatmap(heatmap_data);

                                                        })





                                                })
                                                // DEG(data_copy_pval,parsedLogFC,old_p_adj)
                                                // var req = ocpu.call("enrichment", {
                                                //     data: data_copy
                                                //     }, function (session) {

                                                // })
                                            });


                                    })
                                } else if (chosen_statistic == 'limma') {
                                    updateStatisticalMethod('limma');
                                    console.log(dataC_copy)
                                    console.log(dataN_copy)
                                    console.log(data_copy_pval)
                                    var req = ocpu.call("limmaDE", {
                                        dataC: dataC_copy,  // Pass your processed case data
                                        dataN: dataN_copy   // Pass your processed normal data
                                    }, function (session) {
                                        var filteredDataURL = session.loc + "/R/.val/json";
                                        // console.log(session);
                                        // Fetch the filtered data from the URL
                                        fetch(filteredDataURL)
                                            .then(response => response.json())
                                            .then(data => {
                                                console.log(session);
                                                // Convert pval_adj values back to numbers if needed
                                                data.forEach(entry => {
                                                    entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                                                });

                                                // Rename '_row' to 'Gene'
                                                data.forEach(entry => {
                                                    if (entry.hasOwnProperty('_row')) {
                                                        entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                                        delete entry._row; // Remove '_row' property
                                                    }
                                                });

                                                old_p_adj = data
                                                old_p_adj.sort((a, b) => {
                                                    if (a.Gene < b.Gene) {
                                                        return -1;
                                                    }
                                                    if (a.Gene > b.Gene) {
                                                        return 1;
                                                    }
                                                    return 0;
                                                });

                                                const ind = old_p_adj.reduce((result, entry, index) => {

                                                    if (entry.pval_adj > threshold) {
                                                        result.push(index);
                                                    }
                                                    return result;
                                                }, []);

                                                console.log(old_p_adj)
                                                console.log(ind)

                                                console.log("geni tolti dal primo filtering del pval", ind.length)

                                                if (ind.length > 0) {

                                                    //console.log(parsedLogFC.length)

                                                    // Remove entries corresponding to ind from dataN

                                                    // Remove entries corresponding to ind from dataN
                                                    dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                                    // Remove entries corresponding to ind from dataN
                                                    dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                                                    data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                                    console.log("geni rimamenti dal primo filtering", data_copy.length)

                                                    // Remove entries corresponding to ind from logFC
                                                    parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                                    parsedLogFC_pval = parsedLogFC
                                                    console.log(log_thr_fc)
                                                    console.log(parsedLogFC_origin1)
                                                    console.log(old_p_adj)

                                                    if (parsedLogFC.length == 0) {
                                                        alert("No deg found!")
                                                    }

                                                    console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                                    var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                                    console.log(sortedLogFC)

                                                    var mostUpregulatedGene = sortedLogFC[0];

                                                    var secondMostUpregulatedGene = sortedLogFC[1];

                                                    var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                    var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                                    console.log(mostUpregulatedGene)

                                                    // Function to find the adjusted p-value for a given gene
                                                    function getAdjustedPValue(geneName) {
                                                        const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                                        return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                                    }

                                                    var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                                    var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                                    // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                                    if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                                        selectedGeneData.push(mostUpregulatedGeneName);
                                                    }

                                                    if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                                        selectedGeneData.push(mostDownregulatedGeneName);
                                                    }

                                                    // Find the select element
                                                    var selectElement = document.getElementById("selectButton");

                                                    // Clear existing options
                                                    selectElement.innerHTML = "";

                                                    // Add the new options dynamically
                                                    var option1 = document.createElement("option");
                                                    option1.value = mostUpregulatedGene.Gene;
                                                    option1.text = `${mostUpregulatedGene.Gene}`;
                                                    option1.selected = true;
                                                    selectElement.appendChild(option1);

                                                    var option2 = document.createElement("option");
                                                    option2.value = mostDownregulatedGene.Gene;
                                                    option2.text = `${mostDownregulatedGene.Gene}`;
                                                    selectElement.appendChild(option2);


                                                    // updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)

                                                    dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)
                                                    console.log(dataN_copy_pval[0])

                                                    updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                                                    updateCounter();
                                                    updateUpandDown();

                                                    scatter.selectAll("circle")
                                                        .filter(circleData => circleData.Gene === mostUpregulatedGeneName || circleData.Gene === mostDownregulatedGeneName)
                                                        .style("fill", d => {
                                                            // Check if logFC is greater than or equal to the threshold
                                                            return "green";

                                                        })
                                                        .classed('pulse', true);

                                                    // Function to handle checkbox change event
                                                    function handleCheckboxChange(event) {
                                                        var isChecked = event.target.checked;
                                                        var category = event.target.value;

                                                        if (isChecked) {
                                                            // Add category to first_dims array
                                                            first_dims.unshift(category);
                                                        } else {
                                                            // Remove category from first_dims array
                                                            var index = first_dims.indexOf(category);
                                                            if (index !== -1) {
                                                                first_dims.splice(index, 1);
                                                            }
                                                        }

                                                        // Log the updated first_dims array
                                                        console.log("Updated first_dims:", first_dims);

                                                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                                    }


                                                    var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);

                                                    // Get the container element
                                                    var checkboxContainer = document.getElementById("checkboxContainer");

                                                    // Initialize a variable to count the number of checkboxes added to the current row
                                                    var checkboxesInRow = 0;

                                                    // Iterate through metadataCategories to create checkboxes
                                                    metadataCategories.forEach(function (category) {
                                                        // Create a checkbox element
                                                        var checkbox = document.createElement("input");
                                                        checkbox.type = "checkbox";
                                                        checkbox.value = category;
                                                        checkbox.id = "checkbox_" + category; // Set a unique ID for each checkbox

                                                        // Set the checked attribute based on condition
                                                        if (category === selectedRowName) {
                                                            checkbox.checked = true;
                                                        }

                                                        // Create a label for the checkbox
                                                        var label = document.createElement("label");
                                                        label.htmlFor = checkbox.id;
                                                        label.appendChild(document.createTextNode(category));

                                                        // Add event listener to the checkbox to handle change event
                                                        checkbox.addEventListener("change", handleCheckboxChange);

                                                        // Append the checkbox and label to the container element
                                                        checkboxContainer.appendChild(checkbox);
                                                        checkboxContainer.appendChild(label);

                                                        // Increment the count of checkboxes in the row
                                                        checkboxesInRow++;

                                                        // Add a line break after every two checkboxes
                                                        if (checkboxesInRow % 2 === 0) {
                                                            checkboxContainer.appendChild(document.createElement("br"));
                                                        }
                                                    });

                                                    // Initialize a variable to count the number of radio buttons added to the current row
                                                    var radioButtonsInRow = 0;
                                                    // Get the container element
                                                    var radioBoxContainer = document.getElementById("radioBoxContainer");

                                                    // Function to handle radio button change event
                                                    function handleRadioButtonChange(event) {
                                                        // Update selectedVariable with the value of the selected radio button
                                                        selectedVariable = event.target.value;

                                                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                                                    }


                                                    // Iterate through metadataCategories to create radio buttons
                                                    // Count the unique values in the metadata category
                                                    function countUniqueValues(cat, j) {
                                                        var uniqueValues = new Set(); // Use a Set to store unique values
                                                        // Iterate through metadata categories to create y scales
                                                        metadataCategories.forEach((category, i) => {
                                                            if (j === i) {
                                                                var values = Object.values(metadata[i]); // Extract values for the current category
                                                                values.shift(); // Remove the first value (Sample_source_name_ch1)
                                                                var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                                                console.log("Values for", category, ":", uniqueValues);
                                                                return uniqueValues.length; // Return the size of the Set, which is the count of unique values
                                                            }
                                                        });
                                                    }

                                                    // Iterate through metadataCategories to create radio buttons
                                                    metadataCategories.forEach(function (category, i) {
                                                        // Check if the category has more than 9 unique values
                                                        var values = Object.values(metadata[i]); // Extract values for the current category
                                                        values.shift(); // Remove the first value (Sample_source_name_ch1)
                                                        var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                                        console.log("Values for", category, ":", uniqueValues);
                                                        console.log(uniqueValues.length);
                                                        if (uniqueValues.length >= 9) return

                                                        // Create a radio button element
                                                        var radioButton = document.createElement("input");
                                                        radioButton.type = "radio";
                                                        radioButton.name = "radioButtonGroup"; // Set the same name for all radio buttons in the group
                                                        radioButton.value = category;
                                                        radioButton.id = "radioButton_" + category; // Set a unique ID for each radio button

                                                        // Set the checked attribute based on condition
                                                        if (category === selectedRowName) {
                                                            radioButton.checked = true;
                                                        }

                                                        // Create a label for the radio button
                                                        var label = document.createElement("label");
                                                        label.htmlFor = radioButton.id;
                                                        label.appendChild(document.createTextNode(category));

                                                        // Add event listener to the radio button to handle change event
                                                        radioButton.addEventListener("change", handleRadioButtonChange);

                                                        // Append the radio button and label to the container element
                                                        radioBoxContainer.appendChild(radioButton);
                                                        radioBoxContainer.appendChild(label);

                                                        // Increment the count of radio buttons in the row
                                                        radioButtonsInRow++;

                                                        // Add a line break after every two radio buttons
                                                        if (radioButtonsInRow % 2 === 0) {
                                                            radioBoxContainer.appendChild(document.createElement("br"));
                                                        }
                                                    });

                                                    document.getElementById("checkboxContainer").style.visibility = "visible";
                                                    document.getElementById("radioBoxContainer").style.visibility = "visible";


                                                }
                                                console.log(dataN_copy.length)
                                                var pc1Values = [];
                                                var pc2Values = [];
                                                var groupValues = [];
                                                console.log("PCA DATA COPY PVAL:", data_copy_pval)
                                                var req = ocpu.call("pca", {
                                                    data: data_copy_pval,
                                                    dataN: dataN_copy_pval,
                                                    dataC: dataC_copy_pval
                                                }, function (session) {
                                                    var filteredDataURL = session.loc + "/R/.val/json";
                                                    //console.log(session);
                                                    // Fetch the filtered data from the URL
                                                    fetch(filteredDataURL)
                                                        .then(response => response.json())
                                                        .then(data => {
                                                            json = data
                                                            console.log(filteredDataURL)
                                                            console.log(json)

                                                            var pc1Key = "PC1";
                                                            var pc2Key = "PC2";
                                                            var groupKey = "Group";

                                                            // Iterate over each object in the JSON array
                                                            json.scores_df.forEach(function (obj) {
                                                                // Push PC1, PC2, and Group values to the arrays
                                                                pc1Values.push(obj[pc1Key]);
                                                                pc2Values.push(obj[pc2Key]);
                                                                groupValues.push(obj[groupKey]);
                                                            });
                                                            // console.log(pc1Values)

                                                            // Extract metadata categories from the values of the first column
                                                            var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                                            console.log("Metadata categories:", metadataCategories);

                                                            explainedVariance = json.explained_variance; // Access explained variance
                                                            console.log("Explained variance", explainedVariance)
                                                            // Initialize pca_data array
                                                            pca_data = [];

                                                            // Iterate over each object in the JSON array
                                                            json.scores_df.forEach(function (obj) {
                                                                // Retrieve additional data from metadata based on _row
                                                                var gsm = obj._row;
                                                                var group = obj.Group;
                                                                // Create an object with the required fields
                                                                var newObj = {
                                                                    GSM: gsm,
                                                                    group: group,
                                                                };

                                                                // Check for the existence of each principal component before adding to newObj
                                                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                                                // Add metadata values for each category to the newObj
                                                                metadataCategories.forEach((category, index) => {
                                                                    newObj[category] = metadata[index][gsm];
                                                                });

                                                                // Push the new object to the pca_data array
                                                                pca_data.push(newObj);
                                                            });

                                                            heatmap_data = []
                                                            json.scores_var.forEach(function (obj) {
                                                                // Push PC1, PC2, and Group values to the arrays
                                                                var gene = obj._row

                                                                var newObj = {
                                                                    gene: gene,
                                                                };
                                                                // Check for the existence of each principal component before adding to newObj
                                                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                                                heatmap_data.push(newObj);
                                                            })

                                                            // Assuming you want to work with the first object in the array
                                                            let obj = json.scores_df[0]; // Get the first object

                                                            // Initialize an array to hold available principal components
                                                            availablePCs = [];

                                                            // Check for the existence of each principal component
                                                            if (obj.PC1 !== undefined) availablePCs.push('pc1');
                                                            if (obj.PC2 !== undefined) availablePCs.push('pc2');
                                                            if (obj.PC3 !== undefined) availablePCs.push('pc3');
                                                            if (obj.PC4 !== undefined) availablePCs.push('pc4');
                                                            if (obj.PC5 !== undefined) availablePCs.push('pc5');
                                                            if (obj.PC6 !== undefined) availablePCs.push('pc6');

                                                            // Function to update the dropdowns based on available PCs
                                                            function updateDropdowns() {
                                                                const xAxisSelect = document.getElementById("x-axis-select");
                                                                const yAxisSelect = document.getElementById("y-axis-select");

                                                                // Clear existing options
                                                                xAxisSelect.innerHTML = '';
                                                                yAxisSelect.innerHTML = '';

                                                                // Add available options to the X-axis dropdown
                                                                availablePCs.forEach(function (pc) {
                                                                    const option = document.createElement("option");
                                                                    option.value = pc;
                                                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                                    xAxisSelect.appendChild(option);
                                                                });

                                                                // Add available options to the Y-axis dropdown
                                                                availablePCs.forEach(function (pc) {
                                                                    const option = document.createElement("option");
                                                                    option.value = pc;
                                                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                                    yAxisSelect.appendChild(option);
                                                                });

                                                                // Set the default selected value for the Y-axis to PC2, if available
                                                                if (availablePCs.includes("pc2")) {
                                                                    yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                                                                }

                                                            }

                                                            // Call the function to update dropdowns
                                                            updateDropdowns();

                                                            // Display the newData array
                                                            console.log("PCA, first try ", pca_data);
                                                            if (obj.PC2 !== undefined) pca(pca_data);
                                                            displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                                                            document.getElementById("value-placeholder").textContent = displayed_rows;
                                                            if (obj.PC2 !== undefined) heatmap(heatmap_data);

                                                        })





                                                })
                                                // DEG(data_copy_pval,parsedLogFC,old_p_adj)
                                                // var req = ocpu.call("enrichment", {
                                                //     data: data_copy
                                                //     }, function (session) {

                                                // })
                                            });


                                    })
                                } else if (chosen_statistic == 'deseq2') {
                                }


                                ///// DATI FILTRATI DAL PRIMO PVALUE, GIA' FILTRATI DAL PRIMO LOGFC, CHE ERANO GIA FILTRATI DA PRIMO IQR IN dataC_copy dataN_copy data_copy parsedLogFC ///////


                                // Calculate the quantile
                                log_thr_fc = Math.log2(thr_fc);
                            }
                            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {

                                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                    result.push(index);
                                }
                                return result;
                            }, []);

                            // const geneCountDiv2 = document.getElementById('geneCount2');
                            // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;


                        });

                })
            }
        }


        document.getElementById("thresholdSlider").addEventListener("input", function () {
            // Update the threshold value on slider change
            prc_IQR = parseFloat(this.value);
            document.getElementById("thresholdValue").innerText = `${Math.round(prc_IQR * 100)}%`;

            // Calculate the quantile
            thr_prc = ss.quantile(variation_data_copy, prc_IQR);
            updateHistogram(variation_data);
            console.log(variation_data);

            // Step 1: Create a Set of genes that pass the IQR threshold
            const iqrGeneset = new Set();
            variation_data_copy.forEach((entry, index) => {
                if (entry >= thr_prc) {
                    iqrGeneset.add(data_original[index].gene);  // Assuming 'gene' is the key
                }
            });

            console.log("Number of genes passing the IQR filter:", iqrGeneset.size);

            dataC_copy1 = dataC_original;
            dataN_copy1 = dataN_original;
            data_copy1 = data_original;

            if (iqrGeneset.size > 0) {
                // Step 2: Filter data based on the IQR gene set
                dataC_copy1 = dataC_original.filter(entry => iqrGeneset.has(entry.gene));  // Assuming 'gene' is the key
                dataN_copy1 = dataN_original.filter(entry => iqrGeneset.has(entry.gene));
                data_copy1 = data_original.filter(entry => iqrGeneset.has(entry.gene));
            }

            first_filter_number_genes = dataC_copy1.length;

            // Step 3: Calculate the logFC after the IQR filtering
            parsedLogFC_origin = calculateLogFC(dataC_copy1, dataN_copy1);
            parsedLogFC = parsedLogFC_origin;
            updateLogFCHistogram(parsedLogFC_origin);

            // Step 4: Create a Set of genes that pass the logFC threshold
            const logFCGeneset = new Set();
            parsedLogFC_origin.forEach(entry => {
                if (Math.abs(entry.logFC) >= Math.log2(thr_fc)) {
                    logFCGeneset.add(entry.Gene);  // Assuming 'Gene' is the key
                }
            });

            console.log("Number of genes passing the logFC filter:", logFCGeneset.size);

            // Step 5: Filter data based on the logFC gene set
            dataC_copy = dataC_copy1.filter(entry => logFCGeneset.has(entry.gene));
            dataN_copy = dataN_copy1.filter(entry => logFCGeneset.has(entry.gene));
            data_copy = data_copy1.filter(entry => logFCGeneset.has(entry.gene));
            parsedLogFC = parsedLogFC_origin.filter(entry => logFCGeneset.has(entry.Gene));

            console.log("Remaining genes after logFC filtering:", data_copy.length);

            // Step 6: Update the gene count and plots
            updateCounter();
            updateUpandDown();
        });

        document.getElementById("thresholdSlider").addEventListener("change", function () {
            document.getElementById("loadingOverlay").style.display = "block";
            if (chosen_statistic == 't-test') {
                console.log("data copy in iqr prima di chiamare pval", data_copy)
                var req = ocpu.call("pval", {
                    data: data_copy,
                    N: normal_number,
                    M: case_number
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);


                            const ind = old_p_adj.reduce((result, entry, index) => {

                                if (entry.pval_adj > threshold) {
                                    result.push(index);
                                }
                                return result;
                            }, []);
                            console.log("geni con pval minore di thr nel iqr slider", ind.length)
                            console.log("thr pval ", threshold)
                            dataC_copy_pval = dataC_copy
                            dataN_copy_pval = dataN_copy
                            data_copy_pval = data_copy

                            if (ind.length > 0) {

                                //console.log(parsedLogFC.length)

                                // Remove entries corresponding to ind from dataN

                                // Remove entries corresponding to ind from dataN
                                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from dataN
                                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from logFC
                                parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                console.log("geni passati a box dal IQR slider", parsedLogFC.length)
                            }
                            updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)



                            var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                            var mostUpregulatedGene = sortedLogFC[0];
                            var secondMostUpregulatedGene = sortedLogFC[1];

                            var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                            var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                            var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                            //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                            var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                            //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                            genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
                            if (selectedGeneData == []) {
                                // Function to find the adjusted p-value for a given gene
                                function getAdjustedPValue(geneName) {
                                    const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                    return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                }

                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostUpregulatedGeneName);
                                }

                                if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostDownregulatedGeneName);
                                }

                            }
                            else {
                                // Filter out genes that are not present in dataC_copy or dataN_copy
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });
                            }


                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }


                            // dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy_pval, first_dims)
                            updateCounter();
                            updateUpandDown();
                            var pc1Values = [];
                            var pc2Values = [];
                            var groupValues = [];
                            console.log("PCA DATA COPY PVAL:", data_copy_pval)
                            var req = ocpu.call("pca", {
                                data: data_copy_pval,
                                dataN: dataN_copy_pval,
                                dataC: dataC_copy_pval
                            }, function (session) {
                                var filteredDataURL = session.loc + "/R/.val/json";
                                //console.log(session);
                                // Fetch the filtered data from the URL
                                fetch(filteredDataURL)
                                    .then(response => response.json())
                                    .then(data => {
                                        json = data
                                        console.log(filteredDataURL)
                                        console.log(json)

                                        var pc1Key = "PC1";
                                        var pc2Key = "PC2";
                                        var groupKey = "Group";

                                        // Arrays to store PC1 and PC2 values


                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            pc1Values.push(obj[pc1Key]);
                                            pc2Values.push(obj[pc2Key]);
                                            groupValues.push(obj[groupKey]);
                                        });
                                        // console.log(pc1Values)

                                        // Extract metadata categories from the values of the first column
                                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                        console.log("Metadata categories:", metadataCategories);

                                        explainedVariance = json.explained_variance; // Access explained variance
                                        console.log("Explained variance", explainedVariance)

                                        // Initialize pca_data array
                                        pca_data = [];

                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Retrieve additional data from metadata based on _row
                                            var gsm = obj._row;
                                            var group = obj.Group;
                                            // Create an object with the required fields
                                            var newObj = {
                                                GSM: gsm,
                                                group: group,
                                            };

                                            // Check for the existence of each principal component before adding to newObj
                                            if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                            if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                            if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                            if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                            if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                            if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                            // Add metadata values for each category to the newObj
                                            metadataCategories.forEach((category, index) => {
                                                newObj[category] = metadata[index][gsm];
                                            });

                                            // Push the new object to the pca_data array
                                            pca_data.push(newObj);
                                        });

                                        heatmap_data = []
                                        json.scores_var.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            var gene = obj._row

                                            var newObj = {
                                                gene: gene,
                                            };
                                            // Check for the existence of each principal component before adding to newObj
                                            if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                            if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                            if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                            if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                            if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                            if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                            heatmap_data.push(newObj);
                                        })

                                        // Assuming you want to work with the first object in the array
                                        let obj = json.scores_df[0]; // Get the first object

                                        // Initialize an array to hold available principal components
                                        availablePCs = [];

                                        // Check for the existence of each principal component
                                        if (obj.PC1 !== undefined) availablePCs.push('pc1');
                                        if (obj.PC2 !== undefined) availablePCs.push('pc2');
                                        if (obj.PC3 !== undefined) availablePCs.push('pc3');
                                        if (obj.PC4 !== undefined) availablePCs.push('pc4');
                                        if (obj.PC5 !== undefined) availablePCs.push('pc5');
                                        if (obj.PC6 !== undefined) availablePCs.push('pc6');

                                        // Function to update the dropdowns based on available PCs
                                        function updateDropdowns() {
                                            const xAxisSelect = document.getElementById("x-axis-select");
                                            const yAxisSelect = document.getElementById("y-axis-select");

                                            // Clear existing options
                                            xAxisSelect.innerHTML = '';
                                            yAxisSelect.innerHTML = '';

                                            // Add available options to the X-axis dropdown
                                            availablePCs.forEach(function (pc) {
                                                const option = document.createElement("option");
                                                option.value = pc;
                                                option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                xAxisSelect.appendChild(option);
                                            });

                                            // Add available options to the Y-axis dropdown
                                            availablePCs.forEach(function (pc) {
                                                const option = document.createElement("option");
                                                option.value = pc;
                                                option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                yAxisSelect.appendChild(option);
                                            });

                                            // Set the default selected value for the Y-axis to PC2, if available
                                            if (availablePCs.includes("pc2")) {
                                                yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                                            }

                                        }

                                        // Call the function to update dropdowns
                                        updateDropdowns();

                                        // Display the newData array
                                        console.log("PCA, first try ", pca_data);
                                        if (obj.PC2 !== undefined) pca(pca_data);
                                        displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                                        document.getElementById("value-placeholder").textContent = displayed_rows;
                                        if (obj.PC2 !== undefined) heatmap(heatmap_data);

                                    })



                                // DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)


                            })
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    return "green";

                                });



                        });
                })

            } else if (chosen_statistic == 'limma') {
                console.log("data copy in iqr prima di chiamare limma", data_copy)
                console.log(dataC_copy)
                console.log(dataN_copy)
                var req = ocpu.call("limmaDE", {
                    dataC: dataC_copy,  // Pass your processed case data
                    dataN: dataN_copy   // Pass your processed normal data
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            console.log(session);
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            // Rename '_row' to 'Gene'
                            data.forEach(entry => {
                                if (entry.hasOwnProperty('_row')) {
                                    entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                    delete entry._row; // Remove '_row' property
                                }
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);



                            const pvalGeneSet = new Set();
                            old_p_adj.forEach(entry => {
                                if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                                    pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                                }
                            });

                            console.log("Number of genes passing the p-value filter:", pvalGeneSet.size);
                            console.log("Threshold p-value:", threshold);

                            dataC_copy_pval = dataC_copy;
                            dataN_copy_pval = dataN_copy;
                            data_copy_pval = data_copy;

                            if (pvalGeneSet.size > 0) {
                                // Filter the data based on the pvalGeneSet
                                dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                                dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                                data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                                parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC

                                console.log("Genes passed to box plot after p-value filter:", parsedLogFC_pval.length);
                            }
                            updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)



                            var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                            var mostUpregulatedGene = sortedLogFC[0];
                            var secondMostUpregulatedGene = sortedLogFC[1];

                            var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                            var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                            var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                            //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                            var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                            //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                            genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
                            if (selectedGeneData == []) {
                                // Function to find the adjusted p-value for a given gene
                                function getAdjustedPValue(geneName) {
                                    const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                    return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                }

                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostUpregulatedGeneName);
                                }

                                if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostDownregulatedGeneName);
                                }

                            }
                            else {
                                // Filter out genes that are not present in dataC_copy or dataN_copy
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });
                            }

                            console.log(selectedGeneData)

                            // Find the select element
                            var selectElement = document.getElementById("selectButton");

                            // Clear existing options
                            selectElement.innerHTML = "";

                            // Add the new options dynamically
                            var option1 = document.createElement("option");
                            option1.value = mostUpregulatedGene.Gene;
                            option1.text = `${mostUpregulatedGene.Gene}`;
                            option1.selected = true;
                            selectElement.appendChild(option1);

                            var option2 = document.createElement("option");
                            option2.value = mostDownregulatedGene.Gene;
                            option2.text = `${mostDownregulatedGene.Gene}`;
                            selectElement.appendChild(option2);

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }



                            //dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy_pval, first_dims)


                            updateCounter();
                            updateUpandDown();
                            var pc1Values = [];
                            var pc2Values = [];
                            var groupValues = [];
                            console.log("PCA DATA COPY PVAL:", data_copy_pval)

                            if (data_copy_pval.length > 0) {
                                var req = ocpu.call("pca", {
                                    data: data_copy_pval,
                                    dataN: dataN_copy_pval,
                                    dataC: dataC_copy_pval
                                }, function (session) {
                                    var filteredDataURL = session.loc + "/R/.val/json";
                                    //console.log(session);
                                    // Fetch the filtered data from the URL
                                    fetch(filteredDataURL)
                                        .then(response => response.json())
                                        .then(data => {
                                            json = data
                                            console.log(filteredDataURL)
                                            console.log(json)

                                            var pc1Key = "PC1";
                                            var pc2Key = "PC2";
                                            var groupKey = "Group";

                                            // Arrays to store PC1 and PC2 values


                                            // Iterate over each object in the JSON array
                                            json.scores_df.forEach(function (obj) {
                                                // Push PC1, PC2, and Group values to the arrays
                                                pc1Values.push(obj[pc1Key]);
                                                pc2Values.push(obj[pc2Key]);
                                                groupValues.push(obj[groupKey]);
                                            });
                                            // console.log(pc1Values)

                                            // Extract metadata categories from the values of the first column
                                            var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                            console.log("Metadata categories:", metadataCategories);

                                            explainedVariance = json.explained_variance; // Access explained variance
                                            console.log("Explained variance", explainedVariance)

                                            // Initialize pca_data array
                                            pca_data = [];

                                            // Iterate over each object in the JSON array
                                            json.scores_df.forEach(function (obj) {
                                                // Retrieve additional data from metadata based on _row
                                                var gsm = obj._row;
                                                var group = obj.Group;
                                                // Create an object with the required fields
                                                var newObj = {
                                                    GSM: gsm,
                                                    group: group,
                                                };

                                                // Check for the existence of each principal component before adding to newObj
                                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                                // Add metadata values for each category to the newObj
                                                metadataCategories.forEach((category, index) => {
                                                    newObj[category] = metadata[index][gsm];
                                                });

                                                // Push the new object to the pca_data array
                                                pca_data.push(newObj);
                                            });

                                            heatmap_data = []
                                            json.scores_var.forEach(function (obj) {
                                                // Push PC1, PC2, and Group values to the arrays
                                                var gene = obj._row

                                                var newObj = {
                                                    gene: gene,
                                                };
                                                // Check for the existence of each principal component before adding to newObj
                                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                                heatmap_data.push(newObj);
                                            })

                                            // Assuming you want to work with the first object in the array
                                            let obj = json.scores_df[0]; // Get the first object

                                            // Initialize an array to hold available principal components
                                            availablePCs = [];

                                            // Check for the existence of each principal component
                                            if (obj.PC1 !== undefined) availablePCs.push('pc1');
                                            if (obj.PC2 !== undefined) availablePCs.push('pc2');
                                            if (obj.PC3 !== undefined) availablePCs.push('pc3');
                                            if (obj.PC4 !== undefined) availablePCs.push('pc4');
                                            if (obj.PC5 !== undefined) availablePCs.push('pc5');
                                            if (obj.PC6 !== undefined) availablePCs.push('pc6');

                                            // Function to update the dropdowns based on available PCs
                                            function updateDropdowns() {
                                                const xAxisSelect = document.getElementById("x-axis-select");
                                                const yAxisSelect = document.getElementById("y-axis-select");

                                                // Clear existing options
                                                xAxisSelect.innerHTML = '';
                                                yAxisSelect.innerHTML = '';

                                                // Add available options to the X-axis dropdown
                                                availablePCs.forEach(function (pc) {
                                                    const option = document.createElement("option");
                                                    option.value = pc;
                                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                    xAxisSelect.appendChild(option);
                                                });

                                                // Add available options to the Y-axis dropdown
                                                availablePCs.forEach(function (pc) {
                                                    const option = document.createElement("option");
                                                    option.value = pc;
                                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                    yAxisSelect.appendChild(option);
                                                });

                                                // Set the default selected value for the Y-axis to PC2, if available
                                                if (availablePCs.includes("pc2")) {
                                                    yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                                                }

                                            }

                                            // Call the function to update dropdowns
                                            updateDropdowns();

                                            // Display the newData array
                                            console.log("PCA, first try ", pca_data);
                                            if (obj.PC2 !== undefined) pca(pca_data);
                                            displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                                            document.getElementById("value-placeholder").textContent = displayed_rows;
                                            if (obj.PC2 !== undefined) heatmap(heatmap_data);
                                        })



                                    // DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)


                                })
                            }
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    return "green";

                                });



                        });
                })

            }



            // const geneCountDiv2 = document.getElementById('geneCount2');
            // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;

        });


        // Reference to the input field for the threshold value
        const thresholdInput = document.getElementById('log_thresholdSliderValue');
        const thresholdSlider = document.getElementById('log_thresholdSlider');
        var last_log_selected = 1.1

        // Make the input editable on double-click
        thresholdInput.addEventListener('dblclick', function () {
            last_log_selected = thresholdSlider.value; // Store the slider value
            this.readOnly = false;
            this.style.backgroundColor = '#fff'; // Change background to indicate edit mode
            this.style.color = "black"; // Change text color to black

            // Handle clicks outside the input field to make it non-editable
            const clickOutsideHandler = function (event) {
                if (event.target !== thresholdInput) { // Check if the click target is not the input field
                    thresholdInput.readOnly = true;
                    thresholdInput.style.backgroundColor = 'transparent'; // Return to non-edit mode
                    thresholdInput.style.color = "white"; // Change text color back to white

                    // Update the slider and input to the last selected value
                    thresholdSlider.value = last_log_selected;
                    thresholdInput.value = thresholdSlider.value; // Sync input with slider

                    // Trigger slider input event
                    thresholdSlider.dispatchEvent(new Event('input'));

                    // Remove the event listener after clicking outside
                    document.removeEventListener('click', clickOutsideHandler);
                }
            };

            // Add event listener for clicks outside
            document.addEventListener('click', clickOutsideHandler);
        });

        // Validate and restrict input to only float/int numbers
        thresholdInput.addEventListener('input', function () {
            const regex = /^[0-9]*[.]?[0-9]*$/; // Regex for float or int, allowing optional digits before and after the dot

            // Check if input is a valid number
            if (!regex.test(this.value)) {
                this.value = this.value.slice(0, -1); // Remove the last invalid character
            }

            const value = this.value;

            // Check if the last character is a decimal point
            const isLastCharPoint = value.endsWith('.');

            // Convert the input value to a float
            const newValue = parseFloat(value);

            // Validate the new value
            if (!isNaN(newValue) && !isLastCharPoint && newValue >= thresholdSlider.min && newValue <= thresholdSlider.max) {
                thresholdSlider.value = newValue;
                thresholdSlider.dispatchEvent(new Event('input')); // Trigger slider input event
            }
        });

        // Trigger the threshold slider's logic when the user presses "Enter"
        thresholdInput.addEventListener('keypress', function (event) {
            if (event.key === 'Enter') {
                this.readOnly = true;
                this.style.backgroundColor = 'transparent'; // Return to non-edit mode
                this.style.color = "white"; // Change text color back to white

                // Trigger the slider input event
                const newValue = parseFloat(this.value);
                if (!isNaN(newValue) && newValue >= thresholdSlider.min && newValue <= thresholdSlider.max) {
                    thresholdSlider.value = newValue;
                    thresholdSlider.dispatchEvent(new Event('input')); // Trigger slider input event
                    thresholdSlider.dispatchEvent(new Event('change')); // Trigger slider change event
                } else {
                    alert(`Please enter a value between ${thresholdSlider.min} and ${thresholdSlider.max}`);
                }
            }
        });

        document.getElementById("log_thresholdSlider").addEventListener("input", function () {
            // Step 1: Create a Set of genes that pass the logFC threshold
            thr_fc = parseFloat(this.value);
            thresholdInput.value = thr_fc;
            log_thr_fc = Math.log2(thr_fc);


            const geneset = new Set();
            parsedLogFC_origin.forEach(entry => {
                if (Math.abs(entry.logFC) >= log_thr_fc) {
                    geneset.add(entry.Gene);  // Add the gene to the set if it passes the filter
                }
            });

            console.log("Number of genes passing the LOGFC filter:", geneset.size);

            // Step 2: Filter dataC_copy1, dataN_copy1, data_copy1, and parsedLogFC_origin using the geneset
            if (geneset.size > 0) {
                dataC_copy = dataC_copy1.filter(entry => geneset.has(entry.gene));  // Use the 'gene' key for comparison
                dataN_copy = dataN_copy1.filter(entry => geneset.has(entry.gene));
                data_copy = data_copy1.filter(entry => geneset.has(entry.gene));
                parsedLogFC = parsedLogFC_origin.filter(entry => geneset.has(entry.Gene));  // Use the 'Gene' key for comparison
            }

            updateCounter();
            updateUpandDown();
            updateLogFCHistogram(parsedLogFC_origin);

        });

        document.getElementById("log_thresholdSlider").addEventListener("change", function () {
            last_log_selected = thr_fc
            document.getElementById("loadingOverlay").style.display = "block";
            dataC_copy_pval = dataC_copy
            dataN_copy_pval = dataN_copy
            data_copy_pval = data_copy
            updateCounter();
            updateUpandDown();

            if (chosen_statistic == 't-test') {

                var req = ocpu.call("pval", {
                    data: data_copy,
                    N: normal_number,
                    M: case_number
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }

                            selectedGeneData = selectedGeneData.filter(function (gene) {
                                // Check if the gene is present in dataC_copy or dataN_copy
                                return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                    dataN_copy.some(function (d) { return d.gene === gene; });
                            });

                            console.log(selectedGeneData)

                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                            const ind = old_p_adj.reduce((result, entry, index) => {

                                if (entry.pval_adj > threshold) {
                                    result.push(index);
                                }
                                return result;
                            }, []);
                            dataC_copy_pval = dataC_copy
                            dataN_copy_pval = dataN_copy
                            data_copy_pval = data_copy

                            console.log("geni con pval minore di thr nel logFC slider", ind.length)

                            if (ind.length > 0) {

                                //console.log(parsedLogFC.length)

                                // Remove entries corresponding to ind from dataN

                                // Remove entries corresponding to ind from dataN
                                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from dataN
                                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));

                                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from logFC
                                parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));


                                updateBoxPlot(last_box, parsedLogFC_pval, dataN_copy_pval, dataC_copy_pval)
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });

                                console.log(selectedGeneData)

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                                console.log(dataN_copy.length)
                            }
                            updateCounter();
                            updateUpandDown();

                            //   var pc1Values = [];
                            // var pc2Values = [];
                            // var groupValues = [];
                            console.log("PCA DATA COPY PVAL:", data_copy_pval)

                            if (data_copy_pval.length > 0) {

                                var req = ocpu.call("pca", {
                                    data: data_copy_pval,
                                    dataN: dataN_copy_pval,
                                    dataC: dataC_copy_pval
                                }, function (session) {
                                    var filteredDataURL = session.loc + "R/.val/json";
                                    //console.log(session);
                                    // Fetch the filtered data from the URL
                                    fetch(filteredDataURL)
                                        .then(response => response.json())
                                        .then(data => {
                                            json = data
                                            console.log(filteredDataURL)
                                            console.log(json)

                                            var pc1Key = "PC1";
                                            var pc2Key = "PC2";
                                            var groupKey = "Group";

                                            // Arrays to store PC1 and PC2 values


                                            // Iterate over each object in the JSON array
                                            json.scores_df.forEach(function (obj) {
                                                // Push PC1, PC2, and Group values to the arrays
                                                pc1Values.push(obj[pc1Key]);
                                                pc2Values.push(obj[pc2Key]);
                                                groupValues.push(obj[groupKey]);
                                            });
                                            // console.log(pc1Values)

                                            // Extract metadata categories from the values of the first column
                                            var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                            console.log("Metadata categories:", metadataCategories);

                                            explainedVariance = json.explained_variance; // Access explained variance
                                            console.log("Explained variance", explainedVariance)

                                            // Initialize pca_data array
                                            pca_data = [];

                                            // Iterate over each object in the JSON array
                                            json.scores_df.forEach(function (obj) {
                                                // Retrieve additional data from metadata based on _row
                                                var gsm = obj._row;
                                                var group = obj.Group;
                                                // Create an object with the required fields
                                                var newObj = {
                                                    GSM: gsm,
                                                    group: group,
                                                };

                                                // Check for the existence of each principal component before adding to newObj
                                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                                // Add metadata values for each category to the newObj
                                                metadataCategories.forEach((category, index) => {
                                                    newObj[category] = metadata[index][gsm];
                                                });

                                                // Push the new object to the pca_data array
                                                pca_data.push(newObj);
                                            });

                                            heatmap_data = []
                                            json.scores_var.forEach(function (obj) {
                                                // Push PC1, PC2, and Group values to the arrays
                                                var gene = obj._row

                                                var newObj = {
                                                    gene: gene,
                                                };
                                                // Check for the existence of each principal component before adding to newObj
                                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                                heatmap_data.push(newObj);
                                            })

                                            // Assuming you want to work with the first object in the array
                                            let obj = json.scores_df[0]; // Get the first object

                                            // Initialize an array to hold available principal components
                                            availablePCs = [];

                                            // Check for the existence of each principal component
                                            if (obj.PC1 !== undefined) availablePCs.push('pc1');
                                            if (obj.PC2 !== undefined) availablePCs.push('pc2');
                                            if (obj.PC3 !== undefined) availablePCs.push('pc3');
                                            if (obj.PC4 !== undefined) availablePCs.push('pc4');
                                            if (obj.PC5 !== undefined) availablePCs.push('pc5');
                                            if (obj.PC6 !== undefined) availablePCs.push('pc6');

                                            // Function to update the dropdowns based on available PCs
                                            function updateDropdowns() {
                                                const xAxisSelect = document.getElementById("x-axis-select");
                                                const yAxisSelect = document.getElementById("y-axis-select");

                                                // Clear existing options
                                                xAxisSelect.innerHTML = '';
                                                yAxisSelect.innerHTML = '';

                                                // Add available options to the X-axis dropdown
                                                availablePCs.forEach(function (pc) {
                                                    const option = document.createElement("option");
                                                    option.value = pc;
                                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                    xAxisSelect.appendChild(option);
                                                });

                                                // Add available options to the Y-axis dropdown
                                                availablePCs.forEach(function (pc) {
                                                    const option = document.createElement("option");
                                                    option.value = pc;
                                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                    yAxisSelect.appendChild(option);
                                                });

                                                // Set the default selected value for the Y-axis to PC2, if available
                                                if (availablePCs.includes("pc2")) {
                                                    yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                                                }

                                            }

                                            // Call the function to update dropdowns
                                            updateDropdowns();

                                            // Display the newData array
                                            console.log("PCA, first try ", pca_data);
                                            if (obj.PC2 !== undefined) pca(pca_data);
                                            displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                                            document.getElementById("value-placeholder").textContent = displayed_rows;
                                            if (obj.PC2 !== undefined) heatmap(heatmap_data);
                                        })

                                    //DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)

                                })
                            }





                        });
                })
            } else if (chosen_statistic == 'limma') {
                console.log(dataC_copy)
                console.log(dataN_copy)

                var req = ocpu.call("limmaDE", {
                    dataC: dataC_copy,  // Pass your processed case data
                    dataN: dataN_copy   // Pass your processed normal data
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            console.log(session);
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            // Rename '_row' to 'Gene'
                            data.forEach(entry => {
                                if (entry.hasOwnProperty('_row')) {
                                    entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                    delete entry._row; // Remove '_row' property
                                }
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }

                            selectedGeneData = selectedGeneData.filter(function (gene) {
                                // Check if the gene is present in dataC_copy or dataN_copy
                                return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                    dataN_copy.some(function (d) { return d.gene === gene; });
                            });

                            console.log(selectedGeneData)

                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                            // Step 1: Create a Set of genes that pass the p-value threshold
                            const pvalGeneset = new Set();
                            old_p_adj.forEach(entry => {
                                if (entry.pval_adj <= threshold) {
                                    pvalGeneset.add(entry.Gene);  // Assuming 'Gene' is the key
                                }
                            });

                            console.log("Number of genes passing the p-value filter:", pvalGeneset.size);

                            // Step 2: Initialize copies of the data
                            dataC_copy_pval = dataC_copy;
                            dataN_copy_pval = dataN_copy;
                            data_copy_pval = data_copy;

                            if (pvalGeneset.size > 0) {
                                // Step 3: Filter dataC_copy, dataN_copy, and data_copy using the p-value gene set
                                dataC_copy_pval = dataC_copy.filter(entry => pvalGeneset.has(entry.gene));  // Assuming 'gene' is the key
                                dataN_copy_pval = dataN_copy.filter(entry => pvalGeneset.has(entry.gene));
                                data_copy_pval = data_copy.filter(entry => pvalGeneset.has(entry.gene));

                                // Step 4: Filter parsedLogFC_pval based on the gene set
                                parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneset.has(entry.Gene));  // Assuming 'Gene' is the key

                                console.log("First gene after p-value filtering:", dataN_copy_pval[0]);

                                // Step 5: Update box plot
                                updateBoxPlot(last_box, parsedLogFC_pval, dataN_copy_pval, dataC_copy_pval);

                                // Step 6: Filter selectedGeneData based on whether genes are in dataC_copy or dataN_copy
                                selectedGeneData = selectedGeneData.filter(gene =>
                                    dataC_copy_pval.some(d => d.gene === gene) || dataN_copy_pval.some(d => d.gene === gene)
                                );

                                console.log("Selected gene data after filtering:", selectedGeneData);

                                // Step 7: Update the parallel coordinates plot
                                dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy_pval, first_dims);

                                console.log("Filtered dataN_copy length:", dataN_copy_pval.length);
                            }
                            updateCounter();
                            updateUpandDown();

                            //   var pc1Values = [];
                            // var pc2Values = [];
                            // var groupValues = [];
                            console.log("PCA DATA COPY PVAL:", data_copy_pval)

                            var req = ocpu.call("pca", {
                                data: data_copy_pval,
                                dataN: dataN_copy_pval,
                                dataC: dataC_copy_pval
                            }, function (session) {
                                var filteredDataURL = session.loc + "R/.val/json";
                                //console.log(session);
                                // Fetch the filtered data from the URL
                                fetch(filteredDataURL)
                                    .then(response => response.json())
                                    .then(data => {
                                        json = data
                                        console.log(filteredDataURL)
                                        console.log(json)

                                        var pc1Key = "PC1";
                                        var pc2Key = "PC2";
                                        var groupKey = "Group";

                                        // Arrays to store PC1 and PC2 values


                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            pc1Values.push(obj[pc1Key]);
                                            pc2Values.push(obj[pc2Key]);
                                            groupValues.push(obj[groupKey]);
                                        });
                                        // console.log(pc1Values)

                                        // Extract metadata categories from the values of the first column
                                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                        console.log("Metadata categories:", metadataCategories);

                                        explainedVariance = json.explained_variance; // Access explained variance
                                        console.log("Explained variance", explainedVariance)

                                        // Initialize pca_data array
                                        pca_data = [];

                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Retrieve additional data from metadata based on _row
                                            var gsm = obj._row;
                                            var group = obj.Group;
                                            // Create an object with the required fields
                                            var newObj = {
                                                GSM: gsm,
                                                group: group,
                                            };

                                            // Check for the existence of each principal component before adding to newObj
                                            if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                            if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                            if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                            if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                            if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                            if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                            // Add metadata values for each category to the newObj
                                            metadataCategories.forEach((category, index) => {
                                                newObj[category] = metadata[index][gsm];
                                            });

                                            // Push the new object to the pca_data array
                                            pca_data.push(newObj);
                                        });

                                        heatmap_data = []
                                        json.scores_var.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            var gene = obj._row

                                            var newObj = {
                                                gene: gene,
                                            };
                                            // Check for the existence of each principal component before adding to newObj
                                            if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                            if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                            if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                            if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                            if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                            if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                            heatmap_data.push(newObj);
                                        })

                                        // Assuming you want to work with the first object in the array
                                        let obj = json.scores_df[0]; // Get the first object

                                        // Initialize an array to hold available principal components
                                        availablePCs = [];

                                        // Check for the existence of each principal component
                                        if (obj.PC1 !== undefined) availablePCs.push('pc1');
                                        if (obj.PC2 !== undefined) availablePCs.push('pc2');
                                        if (obj.PC3 !== undefined) availablePCs.push('pc3');
                                        if (obj.PC4 !== undefined) availablePCs.push('pc4');
                                        if (obj.PC5 !== undefined) availablePCs.push('pc5');
                                        if (obj.PC6 !== undefined) availablePCs.push('pc6');

                                        // Function to update the dropdowns based on available PCs
                                        function updateDropdowns() {
                                            const xAxisSelect = document.getElementById("x-axis-select");
                                            const yAxisSelect = document.getElementById("y-axis-select");

                                            // Clear existing options
                                            xAxisSelect.innerHTML = '';
                                            yAxisSelect.innerHTML = '';

                                            // Add available options to the X-axis dropdown
                                            availablePCs.forEach(function (pc) {
                                                const option = document.createElement("option");
                                                option.value = pc;
                                                option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                xAxisSelect.appendChild(option);
                                            });

                                            // Add available options to the Y-axis dropdown
                                            availablePCs.forEach(function (pc) {
                                                const option = document.createElement("option");
                                                option.value = pc;
                                                option.textContent = pc.toUpperCase(); // Set text to uppercase
                                                yAxisSelect.appendChild(option);
                                            });

                                            // Set the default selected value for the Y-axis to PC2, if available
                                            if (availablePCs.includes("pc2")) {
                                                yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                                            }

                                        }

                                        // Call the function to update dropdowns
                                        updateDropdowns();

                                        // Display the newData array
                                        console.log("PCA, first try ", pca_data);
                                        if (obj.PC2 !== undefined) pca(pca_data);
                                        displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                                        document.getElementById("value-placeholder").textContent = displayed_rows;
                                        if (obj.PC2 !== undefined) heatmap(heatmap_data);
                                    })

                                //DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)

                            })





                        });
                })

            } else if (chosen_statistic == 'deseq2') {
                const geneset = new Set();
                parsedLogFC_origin.forEach(entry => {
                    if (Math.abs(entry.logFC) >= log_thr_fc) {
                        geneset.add(entry.Gene);  // Add the gene to the set if it passes the filter
                    }
                });

                console.log("Number of genes passing the LOGFC filter", geneset.size);

                // Step 3: Filter dataC_copy1, dataN_copy1, data_copy1, and parsedLogFC_origin using the geneset
                if (geneset.size > 0) {
                    dataC_copy = dataC_copy1.filter(entry => geneset.has(entry.gene));
                    dataN_copy = dataN_copy1.filter(entry => geneset.has(entry.gene));
                    data_copy = data_copy1.filter(entry => geneset.has(entry.gene));
                    parsedLogFC = parsedLogFC_origin.filter(entry => geneset.has(entry.Gene));
                    old_p_adj = deseq_p_adj.filter(entry => geneset.has(entry.Gene))
                }

                console.log(data_copy)
                console.log(parsedLogFC)
                console.log(old_p_adj)

                var data_log = data_copy1.map(obj => {
                    var newObj = {};
                    for (var key in obj) {
                        if (key !== "gene") {
                            newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                        }
                    }
                    newObj["gene"] = obj["gene"];
                    return newObj;
                });

                var dataN_log = dataN_copy1.map(obj => {
                    var newObj = {};
                    for (var key in obj) {
                        if (key !== "gene") {
                            newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                        }
                    }
                    newObj["gene"] = obj["gene"];
                    return newObj;
                });

                var dataC_log = dataC_copy1.map(obj => {
                    var newObj = {};
                    for (var key in obj) {
                        if (key !== "gene") {
                            newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                        }
                    }
                    newObj["gene"] = obj["gene"];
                    return newObj;
                });

                averageExpressions10C = calculateAverageLog10Expressions(dataC_log);
                averageExpressions10N = calculateAverageLog10Expressions(dataN_log);

                if (currentPlot === 'volcano') {
                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else {
                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                }

                // Step 1: Initialize the geneset and the p-value threshold
                const geneset_pval = new Set();

                // Step 2: Create a geneset of genes to keep based on the p-value condition
                old_p_adj.forEach(entry => {
                    if (entry.pval_adj <= threshold) {  // Adjust condition according to your filtering logic
                        geneset_pval.add(entry.Gene);  // Assuming 'Gene' is the property name
                    }
                });

                console.log("Number of genes passing the pval_adj filter", geneset_pval.size);

                selectedGeneData = selectedGeneData.filter(function (gene) {
                    // Check if the gene is present in dataC_copy or dataN_copy
                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                        dataN_copy.some(function (d) { return d.gene === gene; });
                });

                console.log(selectedGeneData)

                data_copy = data_log.filter(entry => geneset.has(entry.gene))
                dataC_copy = dataC_log.filter(entry => geneset.has(entry.gene))
                dataN_copy = dataN_log.filter(entry => geneset.has(entry.gene))

                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                const pvalGeneSet = new Set();
                old_p_adj.forEach(entry => {
                    if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                        pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                    }
                });

                console.log("Number of genes passing the p-value filter in the logFC slider:", pvalGeneSet.size);

                dataC_copy_pval = dataC_copy;
                dataN_copy_pval = dataN_copy;
                data_copy_pval = data_copy;

                if (pvalGeneSet.size > 0) {
                    // Filter the data based on the pvalGeneSet
                    dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                    dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                    data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                    parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC

                    console.log(dataN_copy_pval[0]);

                    updateBoxPlot(last_box, parsedLogFC_pval, dataN_copy_pval, dataC_copy_pval);

                    // Update selectedGeneData based on the filtered data
                    selectedGeneData = selectedGeneData.filter(function (gene) {
                        // Check if the gene is present in the filtered data
                        return dataC_copy.some(d => d.gene === gene) || dataN_copy.some(d => d.gene === gene);
                    });
                }

                console.log(selectedGeneData)

                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                console.log(dataN_copy.length)

                updateCounter();
                updateUpandDown();

                //   var pc1Values = [];
                // var pc2Values = [];
                // var groupValues = [];                                                
                console.log("PCA DATA COPY PVAL:", data_copy_pval)

                var req = ocpu.call("pca", {
                    data: data_copy_pval,
                    dataN: dataN_copy_pval,
                    dataC: dataC_copy_pval
                }, function (session) {
                    var filteredDataURL = session.loc + "R/.val/json";
                    //console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            json = data
                            console.log(filteredDataURL)
                            console.log(json)

                            var pc1Key = "PC1";
                            var pc2Key = "PC2";
                            var groupKey = "Group";

                            // Arrays to store PC1 and PC2 values


                            // Iterate over each object in the JSON array
                            json.scores_df.forEach(function (obj) {
                                // Push PC1, PC2, and Group values to the arrays
                                pc1Values.push(obj[pc1Key]);
                                pc2Values.push(obj[pc2Key]);
                                groupValues.push(obj[groupKey]);
                            });
                            // console.log(pc1Values)

                            // Extract metadata categories from the values of the first column
                            var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                            console.log("Metadata categories:", metadataCategories);

                            explainedVariance = json.explained_variance; // Access explained variance
                            console.log("Explained variance", explainedVariance)

                            // Initialize pca_data array
                            pca_data = [];

                            // Iterate over each object in the JSON array
                            json.scores_df.forEach(function (obj) {
                                // Retrieve additional data from metadata based on _row
                                var gsm = obj._row;
                                var group = obj.Group;
                                // Create an object with the required fields
                                var newObj = {
                                    GSM: gsm,
                                    group: group,
                                };

                                // Check for the existence of each principal component before adding to newObj
                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                // Add metadata values for each category to the newObj
                                metadataCategories.forEach((category, index) => {
                                    newObj[category] = metadata[index][gsm];
                                });

                                // Push the new object to the pca_data array
                                pca_data.push(newObj);
                            });

                            heatmap_data = []
                            json.scores_var.forEach(function (obj) {
                                // Push PC1, PC2, and Group values to the arrays
                                var gene = obj._row

                                var newObj = {
                                    gene: gene,
                                };
                                // Check for the existence of each principal component before adding to newObj
                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                heatmap_data.push(newObj);
                            })

                            // Assuming you want to work with the first object in the array
                            let obj = json.scores_df[0]; // Get the first object

                            // Initialize an array to hold available principal components
                            availablePCs = [];

                            // Check for the existence of each principal component
                            if (obj.PC1 !== undefined) availablePCs.push('pc1');
                            if (obj.PC2 !== undefined) availablePCs.push('pc2');
                            if (obj.PC3 !== undefined) availablePCs.push('pc3');
                            if (obj.PC4 !== undefined) availablePCs.push('pc4');
                            if (obj.PC5 !== undefined) availablePCs.push('pc5');
                            if (obj.PC6 !== undefined) availablePCs.push('pc6');

                            // Function to update the dropdowns based on available PCs
                            function updateDropdowns() {
                                const xAxisSelect = document.getElementById("x-axis-select");
                                const yAxisSelect = document.getElementById("y-axis-select");

                                // Clear existing options
                                xAxisSelect.innerHTML = '';
                                yAxisSelect.innerHTML = '';

                                // Add available options to the X-axis dropdown
                                availablePCs.forEach(function (pc) {
                                    const option = document.createElement("option");
                                    option.value = pc;
                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                    xAxisSelect.appendChild(option);
                                });

                                // Add available options to the Y-axis dropdown
                                availablePCs.forEach(function (pc) {
                                    const option = document.createElement("option");
                                    option.value = pc;
                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                    yAxisSelect.appendChild(option);
                                });

                                // Set the default selected value for the Y-axis to PC2, if available
                                if (availablePCs.includes("pc2")) {
                                    yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                                }

                            }

                            // Call the function to update dropdowns
                            updateDropdowns();

                            // Display the newData array
                            console.log("PCA, first try ", pca_data);
                            if (obj.PC2 !== undefined) pca(pca_data);
                            displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                            document.getElementById("value-placeholder").textContent = displayed_rows;
                            if (obj.PC2 !== undefined) heatmap(heatmap_data);
                        })

                    //DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)

                })




            }



            //updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            // console.log("parsed log ",parsedLogFC.length)
            // console.log("data copy beforeC ",dataC_copy.length)
            // console.log("data copy beforeN",dataN_copy.length)

            // const geneCountDiv = document.getElementById('geneCount2');
            // geneCountDiv.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length}`;

            // Now, dataN, dataC, data, genes, and logFC are updated
        })

        document.getElementById('thresholdSelect').addEventListener('change', function () {
            //console.log(dataC_copy)
            //console.log(data_copy)
            //console.log(dataN_copy)

            document.getElementById("loadingOverlay").style.display = "block";


            threshold = parseFloat(this.value);

            const ind = old_p_adj.reduce((result, entry, index) => {

                if (entry.pval_adj > threshold) {
                    result.push(index);
                }
                return result;
            }, []);

            if (currentPlot === 'volcano') {
                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            } else {
                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            }            // dataC_copy_pval=dataC_copy
            // dataN_copy_pval=dataN_copy
            // data_copy_pval=data_copy


            if (ind.length > 0) {

                //console.log(parsedLogFC.length)

                // Remove entries corresponding to ind from dataN

                // Remove entries corresponding to ind from dataN
                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from dataN
                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from logFC
                parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));

                updateCounter();
                updateUpandDown();

                updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                var pc1Values = [];
                var pc2Values = [];
                var groupValues = [];
                console.log("PCA DATA COPY PVAL:", data_copy_pval)

                var req = ocpu.call("pca", {
                    data: data_copy_pval,
                    dataN: dataN_copy_pval,
                    dataC: dataC_copy_pval
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    //console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            json = data
                            console.log(filteredDataURL)
                            console.log(json)

                            var pc1Key = "PC1";
                            var pc2Key = "PC2";
                            var groupKey = "Group";

                            // Iterate over each object in the JSON array
                            json.scores_df.forEach(function (obj) {
                                // Push PC1, PC2, and Group values to the arrays
                                pc1Values.push(obj[pc1Key]);
                                pc2Values.push(obj[pc2Key]);
                                groupValues.push(obj[groupKey]);
                            });
                            // console.log(pc1Values)

                            // Extract metadata categories from the values of the first column
                            var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                            console.log("Metadata categories:", metadataCategories);

                            explainedVariance = json.explained_variance; // Access explained variance
                            console.log("Explained variance", explainedVariance)

                            // Initialize pca_data array
                            pca_data = [];

                            // Iterate over each object in the JSON array
                            json.scores_df.forEach(function (obj) {
                                // Retrieve additional data from metadata based on _row
                                var gsm = obj._row;
                                var group = obj.Group;
                                // Create an object with the required fields
                                var newObj = {
                                    GSM: gsm,
                                    group: group,
                                };

                                // Check for the existence of each principal component before adding to newObj
                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                // Add metadata values for each category to the newObj
                                metadataCategories.forEach((category, index) => {
                                    newObj[category] = metadata[index][gsm];
                                });

                                // Push the new object to the pca_data array
                                pca_data.push(newObj);
                            });

                            heatmap_data = []
                            json.scores_var.forEach(function (obj) {
                                // Push PC1, PC2, and Group values to the arrays
                                var gene = obj._row

                                var newObj = {
                                    gene: gene,
                                };
                                // Check for the existence of each principal component before adding to newObj
                                if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                                if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                                if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                                if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                                if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                                if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                                heatmap_data.push(newObj);
                            })

                            // Assuming you want to work with the first object in the array
                            let obj = json.scores_df[0]; // Get the first object

                            // Initialize an array to hold available principal components
                            availablePCs = [];

                            // Check for the existence of each principal component
                            if (obj.PC1 !== undefined) availablePCs.push('pc1');
                            if (obj.PC2 !== undefined) availablePCs.push('pc2');
                            if (obj.PC3 !== undefined) availablePCs.push('pc3');
                            if (obj.PC4 !== undefined) availablePCs.push('pc4');
                            if (obj.PC5 !== undefined) availablePCs.push('pc5');
                            if (obj.PC6 !== undefined) availablePCs.push('pc6');

                            // Function to update the dropdowns based on available PCs
                            function updateDropdowns() {
                                const xAxisSelect = document.getElementById("x-axis-select");
                                const yAxisSelect = document.getElementById("y-axis-select");

                                // Clear existing options
                                xAxisSelect.innerHTML = '';
                                yAxisSelect.innerHTML = '';

                                // Add available options to the X-axis dropdown
                                availablePCs.forEach(function (pc) {
                                    const option = document.createElement("option");
                                    option.value = pc;
                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                    xAxisSelect.appendChild(option);
                                });

                                // Add available options to the Y-axis dropdown
                                availablePCs.forEach(function (pc) {
                                    const option = document.createElement("option");
                                    option.value = pc;
                                    option.textContent = pc.toUpperCase(); // Set text to uppercase
                                    yAxisSelect.appendChild(option);
                                });

                                // Set the default selected value for the Y-axis to PC2, if available
                                if (availablePCs.includes("pc2")) {
                                    yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                                }

                            }

                            // Call the function to update dropdowns
                            updateDropdowns();

                            // Display the newData array
                            console.log("PCA, first try ", pca_data);
                            if (obj.PC2 !== undefined) pca(pca_data);
                            displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                            document.getElementById("value-placeholder").textContent = displayed_rows;
                            if (obj.PC2 !== undefined) heatmap(heatmap_data);
                        })




                    // DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)



                })

            } else {
                document.getElementById("loadingOverlay").style.display = "none";
            }

        })

        function pca(pca_data) {
            console.log("update pca")
            pc1Values = []
            pc2Values = []
            pc3Values = []
            pc4Values = []
            pc5Values = []
            pc6Values = []
            groupValues = []
            smokerValues = []
            stageValues = []

            console.log(pca_data)

            // Iterate over the newData array
            pca_data.forEach(function (obj) {
                // Access pc1, pc2, and group values from each object
                var groupValue = obj.group;
                var gsmValue = obj.GSM; // Assuming GSM is a property in the object
                // Check for the existence of each principal component before adding to newObj
                if (obj.pc1 !== undefined) pc1Values.push(obj.pc1);
                if (obj.pc2 !== undefined) pc2Values.push(obj.pc2);
                if (obj.pc3 !== undefined) pc3Values.push(obj.pc3);
                if (obj.pc4 !== undefined) pc4Values.push(obj.pc4);
                if (obj.pc5 !== undefined) pc5Values.push(obj.pc5);
                if (obj.pc6 !== undefined) pc6Values.push(obj.pc6);

                groupValues.push(groupValue);

                //console.log("PC1:", pc1Value, ", PC2:", pc2Value, ", Group:", groupValue);
            });

            var margin = { top: 20, right: 20, bottom: 50, left: 60 };
            var width = 600;
            var height = 400;

            // Create x and y scales with offsets
            var xScale = d3.scaleLinear()
                .domain([
                    d3.min(pc1Values) - 2, // Apply offset to min value
                    d3.max(pc1Values) + 2  // Apply offset to max value
                ])
                .range([0, width]);

            var yScale = d3.scaleLinear()
                .domain([
                    d3.min(pc2Values) - 2, // Apply offset to min value
                    d3.max(pc2Values) + 2  // Apply offset to max value
                ])
                .range([height, 0]);

            // Create SVG container
            var svg = d3.select("#pca")
                .html("")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Add circles for each data point
            svg.selectAll(".data-circle")
                .data(pca_data) // Bind data directly to the circles
                .enter().append("circle")
                .attr("class", "data-circle") // Assign the class "data-circle" to the circles
                .attr("cx", function (d) { return xScale(d.pc1); })
                .attr("cy", function (d) { return yScale(d.pc2); })
                .attr("r", 5) // Adjust the radius as needed
                .style("fill", function (d) {
                    // console.log(d)
                    // console.log(selectedRowName)
                    // console.log(d[selectedRowName])
                    if (d[selectedRowName] == chosen_meta1) {
                        return d3.schemeSet1[0];
                    } else {
                        return d3.schemeSet1[2]
                    }
                })
                .attr("stroke", function (d) {
                    // Set stroke color based on presence in gsmList
                    return gsmList.includes(d.GSM) ? "black" : null;
                })
                .attr("stroke-width", function (d) {
                    // Set stroke width based on presence in gsmList
                    return gsmList.includes(d.GSM) ? null : null;
                })
                .style("opacity", function (d) {
                    // If gsmList is not empty, reduce opacity for unselected circles
                    return gsmList.length > 0 && !gsmList.includes(d.GSM) ? 0.2 : 1;
                })
            // .on("click", function (d) {
            //     // On click, select the circle and add the GSM value to the list
            //     d3.select(this).attr("stroke", "black").attr("stroke-width", 2);
            //     var selectedGSM = d.GSM; // Assuming GSM is a property in the object
            //     // console.log("Selected GSM:", selectedGSM);
            //     gsmList.push(selectedGSM);
            //     // console.log("GSM List:", gsmList)

            //     // Update the circles' opacity based on the new gsmList
            //     svg.selectAll(".data-circle")
            //         .style("opacity", function (d) {
            //             return gsmList.length > 0 && !gsmList.includes(d.GSM) ? 0.2 : 1;
            //         });
            //     ;

            //     // Check if the selected GSM is in the transposedData list
            //     var selectedData = transposedData.find(function (data) {
            //         return data.GSM === selectedGSM;
            //     });

            // });


            // Add x-axis
            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");

            // Add y-axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Principal Component Analysis")
                .style("fill", "white");


            // Add X axis label
            var xAxisLabel = svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text(`PC1 (${explainedVariance[0].toFixed(2)}%)`);

            // Add Y axis label
            var yAxisLabel = svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text(`PC2 (${explainedVariance[1].toFixed(2)}%)`);


            // Define brush function
            var brush = d3.brush()
                .extent([[0, 0], [width, height]])
                .on("end", brushended);

            // Append brush to SVG
            var brushGroup = svg.append("g")
                .attr("class", "brush")
                .call(brush);



            // Function to handle brushend event
            function brushended() {
                var selection = d3.event.selection; // Get the brush selection
                var selectedCircles; // Initialize variable to store selected circles

                if (!selection) {
                    // If there's no selection (brush is removed)
                    // Deselect all circles and clear the GSM list
                    selectedCircles = d3.selectAll(".data-circle").each(function () {
                        d3.select(this)
                            .attr("stroke", null) // Remove stroke
                            .attr("stroke-width", null); // Remove stroke width
                    });
                    gsmList = []; // Clear GSM list
                } else {
                    // If there's a selection, filter selected circles
                    selectedCircles = d3.selectAll(".data-circle").filter(function () {
                        var cx = d3.select(this).attr("cx"); // Get the x-coordinate of the circle
                        var cy = d3.select(this).attr("cy"); // Get the y-coordinate of the circle
                        return cx >= selection[0][0] && cx <= selection[1][0] && cy >= selection[0][1] && cy <= selection[1][1];
                    });

                    // Handle selected circles
                    selectedCircles.each(function () {
                        var circle = d3.select(this); // Select the circle
                        var circleGSM = circle.datum().GSM; // Get the GSM value associated with the circle

                        // Add circle's GSM to the list
                        if (!gsmList.includes(circleGSM)) {
                            gsmList.push(circleGSM);
                        }

                        // Select the circle visually
                        circle.attr("stroke", "black")
                            .attr("stroke-width", null)
                            .raise(); // Bring the selected circle to the front
                    });

                    brushGroup.raise();

                }

                // Update the opacity for all circles after brushing
                svg.selectAll(".data-circle")
                    .style("opacity", function (d) {
                        return gsmList.length > 0 && !gsmList.includes(d.GSM) ? 0.2 : 1;
                    })
                    .each(function (d) {
                        // Bring selected circles to the front
                        // if (gsmList.includes(d.GSM)) {
                        //     d3.select(this).raise();
                        // }
                    });

                // Update parallel plot or any other function with the updated GSM list
                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);


                updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

            }

            // Define maximum length for legend labels before truncating
            var maxLabelLength = 18; // You can adjust this value as needed

            var legendItems = [
                { label: chosen_meta2, color: d3.schemeSet1[2] },
                { label: chosen_meta1, color: d3.schemeSet1[0] }
            ];

            // Create legend group
            var legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (width - 580) + "," + 20 + ")")
                .call(d3.drag()
                    .on("drag", function (event) {
                        d3.select(this).attr("transform", function () {
                            return "translate(" + (d3.event.x) + "," + (d3.event.y) + ")";
                        });
                    })
                );

            // Append legend circles and text
            legendItems.forEach(function (d, i) {
                // Append circles
                legend.append("circle")
                    .attr("class", "legend-item")
                    .attr("cx", 5)
                    .attr("cy", i * 20 + 5)
                    .attr("r", 4)
                    .style("fill", d.color);

                // Append text
                legend.append("text")
                    .attr("class", "legend-item")
                    .attr("x", 15)
                    .attr("y", i * 20 + 10)
                    .text(function () {
                        // Truncate the label if it exceeds the maximum length
                        var text = d.label;
                        if (text.length > maxLabelLength) {
                            return text.slice(0, maxLabelLength) + '...'; // Truncate and add ellipsis
                        }
                        return text;
                    })
                    .style("font-size", "12px")
                    .style("fill", "white")
                    .append("title") // Add tooltip with the full text
                    .text(function () { return d.label; }); // Full text for tooltip
            });

            // Calculate total height and width for the legend rectangle
            var legendHeight = legendItems.length * 20; // Height based on number of items and spacing

            // Get the maximum width of the text elements
            var longestLabelWidth = 0;
            legend.selectAll("text.legend-item").each(function () {
                var width = this.getComputedTextLength(); // Get the width of the rendered text
                longestLabelWidth = Math.max(longestLabelWidth, width); // Update longest width
            });

            // Append white transparent rectangle around the legend
            legend.append("rect")
                .attr("x", -5)
                .attr("y", -5)
                .attr("width", longestLabelWidth + 20) // Add padding to the longest label width
                .attr("height", legendHeight + 10) // Add padding to the legend height
                .style("fill", "none")
                .style("stroke", "white")  // Add stroke attribute
                .style("stroke-width", 1);  // Set stroke width

            // Change cursor to pointer when mouse enters the legend rectangle
            legend.on("mouseover", function (event) {
                d3.select(this).style("cursor", "move");
            });


            // Append legend circles and text
            legend.selectAll("circle.legend-item")
                .data(legendItems)
                .enter().append("circle")
                .attr("class", "legend-item")
                .attr("cx", 5) // Adjust the x-coordinate as needed
                .attr("cy", function (d, i) { return i * 20 + 5; }) // Adjust the y-coordinate as needed
                .attr("r", 4) // Adjust the radius as needed
                .style("fill", function (d) { return d.color; });


            // Store previous axis selections globally
            var prevXAxisSelect = d3.select("#x-axis-select").property("value");
            var prevYAxisSelect = d3.select("#y-axis-select").property("value");

            // Function to update the plot based on selected axes
            function updatePlot() {
                var xAxisSelect = d3.select("#x-axis-select").property("value");
                var yAxisSelect = d3.select("#y-axis-select").property("value");

                var xValues = pca_data.map(d => d[xAxisSelect]);
                var yValues = pca_data.map(d => d[yAxisSelect]);

                // Update scales with offsets
                xScale.domain([
                    d3.min(xValues) - 2, // Apply offset to min value
                    d3.max(xValues) + 2  // Apply offset to max value
                ]);

                yScale.domain([
                    d3.min(yValues) - 2, // Apply offset to min value
                    d3.max(yValues) + 2  // Apply offset to max value
                ]);

                // Update circles
                var circles = svg.selectAll(".data-circle")
                    .data(pca_data);

                circles.enter()
                    .append("circle")
                    .attr("class", "data-circle")
                    .attr("r", 5)
                    .style("fill", function (d) {
                        return d[selectedRowName] == chosen_meta1 ? d3.schemeSet1[0] : d3.schemeSet1[2];
                    })
                    .merge(circles) // Merge enter and update selection
                    .transition() // Apply transition
                    .duration(1000)
                    .attr("cx", function (d) { return xScale(d[xAxisSelect]); })
                    .attr("cy", function (d) { return yScale(d[yAxisSelect]); });

                circles.exit().remove(); // Remove any extra circles

                // Update axes only if they've changed
                if (xAxisSelect !== prevXAxisSelect) {
                    // Update x-axis
                    xAxis.transition().duration(1000).call(d3.axisBottom(xScale));
                    xAxisLabel.transition() // Smooth transition for the X axis label
                        .duration(500)
                        .style("opacity", 0)  // Fade out
                        .transition()  // After fading out, update the text and fade in
                        .duration(500)
                        .style("opacity", 1)
                        .text(`${xAxisSelect.toUpperCase()} (${explainedVariance[availablePCs.indexOf(xAxisSelect)].toFixed(2)}%)`);
                }

                if (yAxisSelect !== prevYAxisSelect) {
                    // Update y-axis
                    yAxis.transition().duration(1000).call(d3.axisLeft(yScale));
                    yAxisLabel.transition()  // Smooth transition for the Y axis label
                        .duration(500)
                        .style("opacity", 0)  // Fade out
                        .transition()  // After fading out, update the text and fade in
                        .duration(500)
                        .style("opacity", 1)
                        .text(`${yAxisSelect.toUpperCase()} (${explainedVariance[availablePCs.indexOf(yAxisSelect)].toFixed(2)}%)`);
                }

                // Style ticks to be white
                xAxis.selectAll("line, path").style("stroke", "white");
                xAxis.selectAll("text").style("fill", "white");

                yAxis.selectAll("line, path").style("stroke", "white");
                yAxis.selectAll("text").style("fill", "white");

                // Update the previous axis selections for the next update
                prevXAxisSelect = xAxisSelect;
                prevYAxisSelect = yAxisSelect;
            }


            // Add button click listener to update the plot
            d3.select("#update-plot").on("click", updatePlot);

            document.getElementById("loadingOverlay").style.display = "none";

        }

        function updateHistogram(variation_data) {
            console.log(variation_data)
            // Filter data based on the threshold
            const filteredData = variation_data.filter(variation => variation >= thr_prc);

            // Create histogram using D3.js
            const svgWidth = 600;
            const svgHeight = 300;
            const margin = { top: 20, right: 20, bottom: 40, left: 50 };
            const width = svgWidth - margin.left - margin.right;
            const height = svgHeight - margin.top - margin.bottom;

            const svg = d3.select("#IQR")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create histogram
            const histogram = d3.histogram()
                .value(variation => variation)
                .domain(d3.extent(variation_data))
                .thresholds(100);

            const bins = histogram(variation_data);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(variation_data))
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .range([height, 0]);

            // Add histogram bars
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", d => xScale(d.x0))
                .attr("y", d => yScale(d.length))
                .attr("width", d => xScale(d.x1) - xScale(d.x0))
                .attr("height", d => height - yScale(d.length))
                .attr("fill", d => {
                    const thresholdPosition = xScale(thr_prc);
                    if (xScale(d.x1) < thresholdPosition) {
                        return "grey"; // Set the color to grey if d.x1 is less than the threshold
                    } else {
                        return "darkgreen"; // Set the original bar color
                    }
                });

            // Add overlay for colored portion
            svg.selectAll(".overlay")
                .data(bins)
                .enter()
                .append("rect")
                .attr("class", "overlay")
                .attr("x", d => {
                    const thresholdPosition = xScale(thr_prc);
                    return xScale(d.x0); // Start the overlay from the beginning of the bar
                })
                .attr("y", d => yScale(d.length))
                .attr("width", d => {
                    const thresholdPosition = xScale(thr_prc);
                    const barWidth = xScale(d.x1) - xScale(d.x0);
                    if (xScale(d.x0) < thresholdPosition && xScale(d.x1) > thresholdPosition) {
                        // Calculate the width of the portion to color
                        return thresholdPosition - xScale(d.x0); // Only color the left portion
                    } else {
                        return 0; // Set width to 0 for bars where threshold is not in range
                    }
                })
                .attr("height", d => height - yScale(d.length))
                .attr("fill", "grey") // Color the left portion of the overlay
                .attr("opacity", 1); // Set opacity for transparency

            // Add x-axis
            var xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");

            // Add y-axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");


            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("IQR value");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 12)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("Frequency");


            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top * 0.1)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("fill", "white")
                .text("IQR Frequency distribution");

            // Add a red line indicating the threshold
            const thresholdLine = svg.append("line")
                .attr("y1", 0)
                .attr("y2", height)
                .attr("stroke", "darkred")
                .attr("stroke-width", 2);

            // Update the position of the threshold line
            thresholdLine.attr("x1", xScale(thr_prc))
                .attr("x2", xScale(thr_prc));


            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width - 150) + "," + 20 + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 5)  // Adjusted x-coordinate to provide some padding
                .attr("y", 5)  // Adjusted y-coordinate to provide some padding
                .attr("width", 160)  // Adjusted width to encapsulate the legend content
                .attr("height", 70)  // Adjusted height to encapsulate the legend content
                .style("stroke", "white")  // Border color
                .style("fill", "none")  // No fill for the rectangle
                .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

            // Add Remaining genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 10)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "darkgreen");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 18)
                .text("Remaining genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");

            // Add Filtered genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 35)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "grey");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 45)
                .text("Filtered genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");


        }

        function updateLogFCHistogram(logFCData) {
            // Extract logFC values and convert them to numbers
            const logFCValues = logFCData.map(entry => entry.logFC);

            // Define histogram parameters
            const svgWidth = 600;
            const svgHeight = 300;
            const margin = { top: 30, right: 20, bottom: 40, left: 50 };
            const width = svgWidth - margin.left - margin.right;
            const height = svgHeight - margin.top - margin.bottom;

            // Create SVG container
            const svg = d3.select("#logFCHistogram")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create histogram using D3.js
            const histogram = d3.histogram()
                .value(d => d)
                .domain(d3.extent(logFCValues))
                .thresholds(100); // Number of bins

            const bins = histogram(logFCValues);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(logFCValues))
                .nice()
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .nice()
                .range([height, 0]);

            // Add histogram bars
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", d => xScale(d.x0))
                .attr("y", d => yScale(d.length))
                .attr("width", d => xScale(d.x1) - xScale(d.x0))
                .attr("height", d => height - yScale(d.length))
                .attr("fill", "orange");

            // Add x-axis
            var xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
            xAxis.selectAll("line, path")
                .style("stroke", "white");
            xAxis.selectAll("text")
                .style("fill", "white");
            // .append("text")
            // .attr("x", width / 2)
            // .attr("y", margin.bottom * 0.8)
            // .attr("text-anchor", "middle")
            // .text("logFC");


            // Add y-axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale))
            // .append("text")
            // .attr("transform", "rotate(-90)")
            // .attr("y", -margin.left * 0.7)
            // .attr("x", -height / 2)
            // .attr("text-anchor", "middle")
            // .text("frequency");

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("Log fold change");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 12)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("Frequency");



            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top * 0.1)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("fill", "white")
                .text("FC (logarithmic) frequency distribution");

            // Add ablines
            svg.append("line")
                .attr("x1", xScale(-Math.log2(thr_fc)))
                .attr("y1", 0)
                .attr("x2", xScale(-Math.log2(thr_fc)))
                .attr("y2", height)
                .style("stroke", "darkred")
                .style("stroke-width", "2");

            svg.append("line")
                .attr("x1", xScale(Math.log2(thr_fc)))
                .attr("y1", 0)
                .attr("x2", xScale(Math.log2(thr_fc)))
                .attr("y2", height)
                .style("stroke", "darkred")
                .style("stroke-width", "2");

            // Add overlay for colored portion
            svg.selectAll(".overlay")
                .data(bins)
                .enter()
                .append("rect")
                .attr("class", "overlay")
                .attr("x", d => {
                    const thresholdPosition = xScale(-Math.log2(thr_fc)); // Position of the left abline
                    return thresholdPosition < xScale(d.x0) ? xScale(d.x0) : thresholdPosition; // Start the overlay from the greater of the two positions
                })
                .attr("y", d => yScale(d.length)) // Start from the bottom of each bin
                .attr("width", d => {
                    const thresholdPositionLeft = xScale(-Math.log2(thr_fc)); // Position of the left abline
                    const thresholdPositionRight = xScale(Math.log2(thr_fc)); // Position of the right abline
                    const barWidth = xScale(d.x1) - xScale(d.x0);
                    // Calculate the width of the portion to color
                    return Math.max(0, Math.min(thresholdPositionRight, xScale(d.x1)) - Math.max(thresholdPositionLeft, xScale(d.x0)));
                })
                .attr("height", d => height - yScale(d.length)) // Set the height based on the height of each bin
                .attr("fill", "grey") // Color the portion of the overlay
                .attr("opacity", 1); // Set opacity for transparency


            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width - 150) + "," + 20 + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 5)  // Adjusted x-coordinate to provide some padding
                .attr("y", 5)  // Adjusted y-coordinate to provide some padding
                .attr("width", 160)  // Adjusted width to encapsulate the legend content
                .attr("height", 70)  // Adjusted height to encapsulate the legend content
                .style("stroke", "white")  // Border color
                .style("fill", "none")  // No fill for the rectangle
                .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

            // Add Remaining genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 10)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "orange");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 18)
                .text("Remaining genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");

            // Add Filtered genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 35)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "grey");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 45)
                .text("Filtered genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");



        }

        function updateVolcanoPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

            var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
                return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
            }, parsed[0]);

            var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
                return currentGene.logFC < minGene.logFC ? currentGene : minGene;
            }, parsed[0]);

            //console.log(mostUpregulatedGene)
            var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
            var mostDownregulatedGeneName = mostDownregulatedGene.Gene;


            // Create circles for each gene
            var data = Object.keys(averageExpressionsN).map(function (gene) {
                // Find the corresponding logFC value from parsedLogFC_origin
                var logFCObj = parsed.find(d => d.Gene === gene) || null;
                var logFC = logFCObj ? logFCObj.logFC : null;

                if (logFC <= log_thr_fc) {
                    var type = "down"
                }
                else {
                    var type = "up"
                }

                var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
                var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

                return { gene: gene, Normal: averageExpressionsN[gene], Case: averageExpressionsC[gene], logFC: logFC, pval_adj: pval_adj, type: type };
            });

            console.log(data);

            // Set up margin, width, and height
            var margin = { top: 10, right: 100, bottom: 40, left: 60 };
            var width = 1000 - margin.left - margin.right;
            var height = 600 - margin.top - margin.bottom;

            // Create SVG container
            var svg = d3.select("#scatterPlot")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Create x and y scales
            var xScale = d3.scaleLinear()
                .domain([
                    d3.min(data, d => d.logFC) - 0.5,
                    d3.max(data, d => d.logFC) + 0.5
                ])
                .range([0, width]);

            var yScale = d3.scaleLinear()
                .domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20)))])
                .range([height, 0])
                .nice();

            // Add X axis
            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");

            // Add Y axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            var clip = svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            svg.select("#scatter").selectAll("*").remove();
            scatter = svg.append('g')
                .attr("id", "scatter")
                .attr("clip-path", "url(#clip)");

            // Add X axis label with logarithmic notation
            xlab = svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

            // Add Y axis label with logarithmic notation
            ylab = svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
                .style("fill", "white");

            // Add title
            svg.append("text")
                .attr("id", "plotTitle")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Volcano Plot")
                .style("fill", "white");

            // Create circles for each gene
            var tooltip = d3.select("#tooltip");

            svg.select("#scatter").selectAll("*").remove();

            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width - 75) + "," + (height - 250) + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", 160)
                .attr("height", 210)
                .style("stroke", "white")
                .style("fill", "none")
                .style("filter", "url(#legendShadow)")
                .style("pointer-events", "none");

            // Append legend for upregulated genes (LogFC > log2(thr_fc) and pval_adj < threshold)
            var upregulatedLegend = legend.append("g")
                .attr("transform", "translate(0,0)");

            upregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "darkred")
                .classed("legend-circle", true);

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "white")
                .style("font-size", "20px")
                .text("Upregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "12px") // Smaller font size for subtitle
                .text("LogFC > log2(" + thr_fc + ") and");

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "white")
                .text("pval_adj < " + threshold)
                .style("font-size", "12px"); // Smaller font size for subtitle

            // Calculate the height of the first legend item
            var legendItemHeight = upregulatedLegend.node().getBBox().height;

            // Append legend for downregulated genes (LogFC < -log2(thr_fc) and pval_adj < threshold)
            var downregulatedLegend = legend.append("g")
                .attr("transform", "translate(0," + 2 * legendItemHeight + ")");

            downregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 65)
                .attr("r", 6)
                .style("fill", "royalblue")
                .classed("legend-circle", true);

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 68)
                .style("fill", "white")
                .style("font-size", "20px")
                .text("Downregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "12px") // Smaller font size for subtitle
                .text("LogFC < -log2(" + thr_fc + ") and");

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 96)
                .style("fill", "white")
                .text("pval_adj < " + threshold)
                .style("font-size", "12px"); // Smaller font size for subtitle

            // Append legend for not significant genes (abs(LogFC) < log2(thr_fc) OR pval_adj > threshold)
            var notSignificantLegend = legend.append("g")
                .attr("transform", "translate(0," + legendItemHeight + ")");

            notSignificantLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 40)
                .attr("r", 6)
                .style("fill", "grey")
                .classed("legend-circle", true);

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 40)
                .style("fill", "white")
                .style("font-size", "20px")
                .text("Not Significant")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "12px") // Smaller font size for subtitle
                .text("|LogFC| < log2(" + thr_fc + ") or");

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 68)
                .style("fill", "white")
                .text("pval_adj > " + threshold)
                .style("font-size", "12px"); // Smaller font size for subtitle


            var circles = scatter.selectAll("circle")
                .data(data);

            // Enter new circles
            circles.enter().append("circle")
                .attr("cx", function (d) {
                    if (d.pval_adj !== null) {
                        return xScale(d.logFC)
                    }
                })
                .attr("cy", function (d) {
                    if (d.pval_adj !== null) {
                        return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                    }
                })
                .attr("r", 2) // Start with radius 0 for initial transition effect
                .style("fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "darkred"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "royalblue"; // Downregulated
                        } else {
                            return "grey"; // Not significant
                        }
                    } else {
                        return "grey"; // Not significant
                    }
                })
                .attr("data-initial-fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "darkred"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "royalblue"; // Downregulated
                        } else {
                            return "grey"; // Not significant
                        }
                    } else {
                        return "grey"; // Not significant
                    }
                })
                .classed('pulse', d => {
                    return selectedGeneData.some(selectedGene => selectedGene === d.gene);
                })
                .on("mouseover", function (d) {
                    d3.select(this)
                        .style("stroke", "black")
                        .style("stroke-width", 2);

                    tooltip.transition()
                        .duration(200) // Add transition duration for mouseout
                        .style("opacity", .9);

                    tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                        .style("left", (d3.event.pageX + 15) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function (d) {
                    // Remove the highlight and hide tooltip on mouseout
                    d3.select(this)
                        .style("stroke", "none");

                    tooltip.transition()
                        .duration(200) // Add transition duration for mouseout
                        .style("opacity", 0)
                        .style("visibility", "none")
                        .style("pointer-events", "none"); // Disable pointer events for the tooltip
                })
                .on("click", function (d) {
                    var selectedElement = d3.select(this);
                    var currentFill = selectedElement.style("fill");

                    // Check if the element is already filled with grey
                    if (currentFill === "grey") {
                        return; // If grey, do nothing
                    }

                    // Check if the element is already highlighted
                    var isHighlighted = selectedElement.classed('pulse');

                    if (isHighlighted) {
                        // If already highlighted, remove the highlighting
                        selectedElement.style("fill", d => {
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                return "darkred";
                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                return "royalblue";
                            } else {
                                return "grey";
                            }
                        })
                            .classed('pulse', false)
                            .classed("pulse1", false);

                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                        // Find and remove the corresponding option from the select element
                        var select = document.getElementById("selectButton");
                        var options = select.options;

                        for (var i = 0; i < options.length; i++) {
                            if (!selectedGeneData.includes(options[i].value)) {
                                select.removeChild(options[i]);
                                break; // Exit the loop once the option is removed
                            }
                        }
                        heatmap(heatmap_data)

                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                    } else {
                        // If not highlighted, apply the highlighting
                        selectedElement
                            .style("fill", "green")
                            .style("stroke-width", 2)
                            .classed('pulse', true)
                            .classed('pulse1', false)
                            .raise();  // Move this element to the top

                        console.log(d)

                        // Find the corresponding scatterplot circle and toggle its selection
                        // var correspondingSquare = square
                        //     .filter(function (squaredata) {
                        //         return squaredata.gene === d.gene;
                        //     });

                        // correspondingSquare.style("stroke", "none");

                        // On click, filter data for the selected gene
                        selectedGeneData.push(d.gene);

                        // Get the select element
                        var select = document.getElementById("selectButton");

                        // Add new options for the genes in selectedGeneData that are not already in the select element
                        selectedGeneData.forEach(function (gene) {
                            if (!Array.from(select.options).some(option => option.value === gene)) {
                                var option = document.createElement("option");
                                option.value = gene;
                                option.text = gene;
                                select.appendChild(option);
                            }
                        });

                        synchronizeAnimations(this);
                        heatmap(heatmap_data)
                        // Call a function to create parallel coordinates plot using selectedGeneData
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                    }
                })
                .each(function (d) {
                    if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        d3.select(this).raise();
                    }
                })


            // Update existing circles with transition
            circles.transition()
                .duration(750)
                .attr("cx", function (d) {
                    if (d.pval_adj !== null) {
                        return xScale(d.logFC)
                    }
                })
                .attr("cy", function (d) {
                    if (d.pval_adj !== null) {
                        return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                    }
                })
                .style("fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "darkred"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "royalblue"; // Downregulated
                        } else {
                            return "grey"; // Not significant
                        }
                    } else {
                        return "grey"; // Not significant
                    }
                })
                .attr("data-initial-fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "darkred"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "royalblue"; // Downregulated
                        } else {
                            return "grey"; // Not significant
                        }
                    } else {
                        return "grey"; // Not significant
                    }
                })
                .attr("r", 2);

            // Exit old circles
            circles.exit()
                .transition()
                .duration(750)
                .attr("r", 0)
                .remove();

            // Variables to store the brush extents in the original data space
            let leftBrushExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]
            let rightBrushExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]

            let brushedGenesLeft = [];
            let brushedGenesRight = [];

            // Define brush for the left side (x < 0)
            var brushLeft = d3.brush()
                .extent([[0, 0], [xScale(0), height]])  // Constrain the brush to the left side
                .on("end", updateBrushLeft);

            // Define brush for the right side (x > 0)
            var brushRight = d3.brush()
                .extent([[xScale(0), 0], [width, height]])  // Constrain the brush to the right side
                .on("end", updateBrushRight);

            var brushLeftG
            var brushRightG
            // To get the current scale
            var currentXScale = xScale; // This will give you the reference to the xScale
            var currentYScale = yScale

            // Functions to handle brush events
            function updateBrushLeft() {
                const selection = d3.event.selection;  // Access event via d3.event in v4
                if (selection) {
                    var [x0, y0] = selection[0]; // Get coordinates for left brush
                    var [x1, y1] = selection[1];

                    // Store the selection in data space, including y extents
                    leftBrushExtent = [
                        [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                        [currentXScale.invert(x1), currentYScale.invert(y1)]
                    ];

                    // Filter selected points based on the stored extents
                    var selectedPoints = data.filter(d => {
                        return (
                            d.logFC >= leftBrushExtent[0][0] && d.logFC <= leftBrushExtent[1][0] &&
                            -Math.log10(d.pval_adj) <= leftBrushExtent[0][1] && -Math.log10(d.pval_adj) >= leftBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                        );
                    });
                    // Add genes to brushedGenes if they are not already present
                    selectedPoints.forEach(point => {
                        if (!brushedGenesLeft.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                            brushedGenesLeft.push(point.gene);
                        }
                    });
                    console.log("Brushed genes left", brushedGenesLeft)
                    highlightSelectedGenes(selectedPoints);
                } else {
                    console.log("Brushed genes left", brushedGenesLeft)
                    // Remove the 'pulse' class from the brushed genes
                    scatter.selectAll("circle").filter(d => brushedGenesLeft.some(p => p === d.gene))
                        .each(function (d) {
                            console.log(d)
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }

                            }
                        });

                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);

                    brushedGenesLeft = []
                    leftBrushExtent = null; // Reset if there's no selection
                }
            }

            function updateBrushRight() {
                const selection = d3.event.selection;  // Access event via d3.event in v4
                if (selection) {
                    var [x0, y0] = selection[0]; // Get coordinates for right brush
                    var [x1, y1] = selection[1];

                    // Store the selection in data space, including y extents
                    rightBrushExtent = [
                        [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                        [currentXScale.invert(x1), currentYScale.invert(y1)]
                    ];

                    // Filter selected points based on the stored extents
                    var selectedPoints = data.filter(d =>
                        d.logFC >= rightBrushExtent[0][0] && d.logFC <= rightBrushExtent[1][0] &&
                        -Math.log10(d.pval_adj) <= rightBrushExtent[0][1] && -Math.log10(d.pval_adj) >= rightBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                    );
                    // Add genes to brushedGenes if they are not already present
                    selectedPoints.forEach(point => {
                        if (!brushedGenesRight.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                            brushedGenesRight.push(point.gene);
                        }
                    });
                    highlightSelectedGenes(selectedPoints);
                } else {
                    // Remove the 'pulse' class from the brushed genes
                    scatter.selectAll("circle").filter(d => brushedGenesRight.some(p => p === d.gene))
                        .each(function (d) {
                            console.log(d)
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }

                            }
                        });

                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);

                    brushedGenesRight = []
                    rightBrushExtent = null; // Reset if there's no selection
                }
            }


            // Function to highlight the selected genes based on the brush
            function highlightSelectedGenes(selectedPoints) {

                // Select all circles and filter only those that are in the selected points
                scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                    .each(function (d) {
                        var selectedElement = d3.select(this);
                        var currentFill = selectedElement.style("fill");

                        // Check if the element is already filled with grey
                        if (currentFill === "grey") {
                            return; // If grey, do nothing
                        }

                        // Check if the element is already highlighted
                        var isHighlighted = selectedElement.classed('pulse');

                        if (!isHighlighted) {
                            // If not highlighted, apply the highlighting
                            selectedElement
                                .style("fill", "green")
                                .style("stroke-width", 2)
                                .classed('pulse', true)
                                .classed('pulse1', false)
                                .raise();  // Move this element to the top

                            if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                            // Get the select element
                            var select = document.getElementById("selectButton");

                            // Add new options for the genes in selectedGeneData that are not already in the select element
                            selectedGeneData.forEach(function (gene) {
                                if (!Array.from(select.options).some(option => option.value === gene)) {
                                    var option = document.createElement("option");
                                    option.value = gene;
                                    option.text = gene;
                                    select.appendChild(option);
                                }
                            });

                            synchronizeAnimations(this);
                        }
                    });

                if (selectedPoints.length >= 1) {
                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                }

            }

            // Set the zoom and pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart)
                .on("end", function () {
                    // Reapply the brush selections with the correct y values
                    // if (leftBrushExtent) {
                    //     brushLeftG.call(brushLeft.move, [
                    //         [currentXScale(leftBrushExtent[0][0]), currentYScale(leftBrushExtent[0][1])],  // Use stored y extents
                    //         [currentXScale(leftBrushExtent[1][0]), currentYScale(leftBrushExtent[1][1])]
                    //     ]);
                    // }
                    // if (rightBrushExtent) {
                    //     brushRightG.call(brushRight.move, [
                    //         [currentXScale(rightBrushExtent[0][0]), currentYScale(rightBrushExtent[0][1])],  // Use stored y extents
                    //         [currentXScale(rightBrushExtent[1][0]), currentYScale(rightBrushExtent[1][1])]
                    //     ]);
                    // }
                })

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach click event to the reset button
            d3.select("#resetButton").on("click", resetZoom);

            // Attach click event to the toggle zoom button
            d3.select("#toggleZoomButton").on("click", function () {
                zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                if (zoomEnabled) {
                    document.getElementById("resetButton").style.cursor = "pointer"
                    document.getElementById("resetButton").style.opacity = 1
                    document.getElementById("resetButton").disabled = false
                    document.getElementById("switchButton").style.cursor = "pointer"
                    document.getElementById("switchButton").style.opacity = 1
                    document.getElementById("switchButton").disabled = false
                    document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Brush Mode"
                    svg.call(zoom); // Re-enable zooming

                    brushLeftG.remove();
                    brushRightG.remove();
                    brushedGenesLeft = []
                    brushedGenesRight = []

                } else {
                    document.getElementById("resetButton").style.cursor = "not-allowed"
                    document.getElementById("resetButton").style.opacity = 0.6
                    document.getElementById("resetButton").disabled = true
                    document.getElementById("switchButton").style.cursor = "not-allowed"
                    document.getElementById("switchButton").style.opacity = 0.6
                    document.getElementById("switchButton").disabled = true

                    document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Save Brushed Genes"
                    svg.on(".zoom", null); // Disable zooming by removing the zoom event

                    // Remove the brushes from the SVG

                    // Optionally, you can update the brush extents
                    brushLeft.extent([[0, 0], [currentXScale(0), height]]);
                    brushRight.extent([[currentXScale(0), 0], [width, height]]);

                    // Redraw brushes to reflect new zoom scale
                    brushLeftG = svg.append("g")
                        .attr("class", "brush-left")
                        .call(brushLeft);

                    brushRightG = svg.append("g")
                        .attr("class", "brush-right")
                        .call(brushRight);

                    brushedGenesLeft = []
                    brushedGenesRight = []

                }
            });
            // Updating the chart after zooming
            function updateChart() {
                if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled

                // Recover the new scale
                var t = d3.event.transform;
                newX = t.rescaleX(xScale);
                newY = t.rescaleY(yScale);
                currentXScale = newX; // Update the reference
                currentYScale = newY; // Update the reference

                // xScale = newX
                // yScale = newY

                // Update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX));
                yAxis.call(d3.axisLeft(newY));

                xAxis.selectAll("line, path").style("stroke", "white");
                xAxis.selectAll("text").style("fill", "white");

                yAxis.selectAll("line, path").style("stroke", "white");
                yAxis.selectAll("text").style("fill", "white");

                // Update circle position
                scatter.selectAll("circle")
                    .attr('cx', function (d) {
                        if (d.pval_adj !== null) return newX(d.logFC);
                    })
                    .attr('cy', function (d) {
                        if (d.pval_adj !== null) return newY(-Math.log10(d.pval_adj));
                    });

                // Update the brush extents
                brushLeft.extent([[0, 0], [newX(0), height]]);
                brushRight.extent([[newX(0), 0], [width, height]]);

                if (!zoomEnabled) {
                    // Redraw brushes to reflect new zoom scale
                    brushLeftG.call(brushLeft);
                    brushRightG.call(brushRight);
                }

            }

            // Define the resetZoom function
            function resetZoom() {
                // Reset the zoom transformation
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);

                if (leftBrushExtent) {
                    brushLeftG.call(brushLeft.move, [
                        [xScale(leftBrushExtent[0][0]), yScale(leftBrushExtent[0][1])], // Use original x and y extents
                        [xScale(leftBrushExtent[1][0]), yScale(leftBrushExtent[1][1])]
                    ]);
                }
                if (rightBrushExtent) {
                    brushRightG.call(brushRight.move, [
                        [xScale(rightBrushExtent[0][0]), yScale(rightBrushExtent[0][1])], // Use original x and y extents
                        [xScale(rightBrushExtent[1][0]), yScale(rightBrushExtent[1][1])]
                    ]);
                }
            }

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Synchronize the current time of the animation with the target animation
                    if (currentAnimation) {
                        currentAnimation.currentTime = targetTime;
                    }
                });
            }

            function findAnimByName(targetElement, animationName) {
                // Retrieve all the animations associated with the target element
                const animations = targetElement.getAnimations();

                // Find the animation object for the 'pulse' animation
                return animations.find(animation => animation.animationName === animationName);
            }
            let brushScatterG
            let brushedGenesScatter = [];

            // Variables to store the brush extents in the original data space
            let brushScatterExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]

            // Define brush for the left side (x < 0)
            var brushScatter



            function SwitchingPlot(structure, choice) {

                if (choice == "volcano") {
                    if (brushScatterG) brushScatterG.remove()
                    // Create x and y scales
                    xScale.domain([
                        d3.min(data, d => d.logFC) - 0.5,
                        d3.max(data, d => d.logFC) + 0.5
                    ]);

                    yScale.domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20)))]);

                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    brushLeft = d3.brush()
                        .extent([[0, 0], [xScale(0), height]])  // Constrain the brush to the left side
                        .on("end", updateBrushLeft);

                    brushRight = d3.brush()
                        .extent([[xScale(0), 0], [width, height]])  // Constrain the brush to the right side
                        .on("end", updateBrushRight);

                    var brushLeftG
                    var brushRightG

                    // Update the zoom behavior to call updateChart1 (assuming updateChart1 is a function you have defined elsewhere)
                    zoom.on("zoom", updateChart1);

                    // Apply zoom behavior to the svg
                    svg.call(zoom);

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    xAxis.selectAll("text")
                        .style("fill", "white");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    yAxis.selectAll("text")
                        .style("fill", "white");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Volcano Plot")
                        .style("fill", "white");


                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    // Remove existing circles
                    dot.exit().remove();


                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            return selectedGeneData.some(selectedGene => selectedGene === d.gene);
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }
                                heatmap(heatmap_data)

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            } else {
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("fill", "green")
                                    .style("stroke-width", 2)
                                    .classed('pulse', true)
                                    .classed('pulse1', false)
                                    .raise();  // Move this element to the top

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                var select = document.getElementById("selectButton");

                                // Add new options for the genes in selectedGeneData that are not already in the select element
                                selectedGeneData.forEach(function (gene) {
                                    if (!Array.from(select.options).some(option => option.value === gene)) {
                                        var option = document.createElement("option");
                                        option.value = gene;
                                        option.text = gene;
                                        select.appendChild(option);
                                    }
                                });

                                synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            }
                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) {
                            if (d.pval_adj !== null) {
                                return xScale(d.logFC)
                            }
                        })
                        .attr("cy", function (d) {
                            if (d.pval_adj !== null) {
                                return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                            }
                        })
                        .attr("r", 2) // Start with radius 0 for initial transition effect
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "darkred"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "royalblue"; // Downregulated
                                } else {
                                    return "grey"; // Not significant
                                }
                            } else {
                                return "grey"; // Not significant
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "darkred"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "royalblue"; // Downregulated
                                } else {
                                    return "grey"; // Not significant
                                }
                            } else {
                                return "grey"; // Not significant
                            }
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })

                    // Functions to handle brush events
                    function updateBrushLeft() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            leftBrushExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.logFC >= leftBrushExtent[0][0] && d.logFC <= leftBrushExtent[1][0] &&
                                    -Math.log10(d.pval_adj) <= leftBrushExtent[0][1] && -Math.log10(d.pval_adj) >= leftBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesLeft.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesLeft.push(point.gene);
                                }
                            });
                            console.log("Brushed genes left", brushedGenesLeft)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes left", brushedGenesLeft)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesLeft.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with grey
                                    if (currentFill === "grey") {
                                        return; // If grey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "darkred";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "royalblue";
                                            } else {
                                                return "grey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        var select = document.getElementById("selectButton");
                                        var options = select.options;

                                        for (var i = 0; i < options.length; i++) {
                                            if (!selectedGeneData.includes(options[i].value)) {
                                                select.removeChild(options[i]);
                                                break; // Exit the loop once the option is removed
                                            }
                                        }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);

                            brushedGenesLeft = []
                            leftBrushExtent = null; // Reset if there's no selection
                        }
                    }

                    function updateBrushRight() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for right brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            rightBrushExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d =>
                                d.logFC >= rightBrushExtent[0][0] && d.logFC <= rightBrushExtent[1][0] &&
                                -Math.log10(d.pval_adj) <= rightBrushExtent[0][1] && -Math.log10(d.pval_adj) >= rightBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                            );
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesRight.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesRight.push(point.gene);
                                }
                            });
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesRight.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with grey
                                    if (currentFill === "grey") {
                                        return; // If grey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "darkred";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "royalblue";
                                            } else {
                                                return "grey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        var select = document.getElementById("selectButton");
                                        var options = select.options;

                                        for (var i = 0; i < options.length; i++) {
                                            if (!selectedGeneData.includes(options[i].value)) {
                                                select.removeChild(options[i]);
                                                break; // Exit the loop once the option is removed
                                            }
                                        }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);

                            brushedGenesRight = []
                            rightBrushExtent = null; // Reset if there's no selection
                        }
                    }


                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {

                        // Select all circles and filter only those that are in the selected points
                        scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                            .each(function (d) {
                                var selectedElement = d3.select(this);
                                var currentFill = selectedElement.style("fill");

                                // Check if the element is already filled with grey
                                if (currentFill === "grey") {
                                    return; // If grey, do nothing
                                }

                                // Check if the element is already highlighted
                                var isHighlighted = selectedElement.classed('pulse');

                                if (!isHighlighted) {
                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("fill", "green")
                                        .style("stroke-width", 2)
                                        .classed('pulse', true)
                                        .classed('pulse1', false)
                                        .raise();  // Move this element to the top

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                    // Get the select element
                                    var select = document.getElementById("selectButton");

                                    // Add new options for the genes in selectedGeneData that are not already in the select element
                                    selectedGeneData.forEach(function (gene) {
                                        if (!Array.from(select.options).some(option => option.value === gene)) {
                                            var option = document.createElement("option");
                                            option.value = gene;
                                            option.text = gene;
                                            select.appendChild(option);
                                        }
                                    });

                                    synchronizeAnimations(this);
                                }
                            });

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }

                    }



                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false
                            document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Brush Mode"
                            svg.call(zoom); // Re-enable zooming

                            brushLeftG.remove();
                            brushRightG.remove();
                            brushedGenesLeft = []
                            brushedGenesRight = []

                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Save Brushed Genes"
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushLeft.extent([[0, 0], [currentXScale(0), height]]);
                            brushRight.extent([[currentXScale(0), 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushLeftG = svg.append("g")
                                .attr("class", "brush-left")
                                .call(brushLeft);

                            brushRightG = svg.append("g")
                                .attr("class", "brush-right")
                                .call(brushRight);

                            brushedGenesLeft = []
                            brushedGenesRight = []

                        }
                    });
                    // Updating the chart after zooming
                    function updateChart1() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled

                        // Recover the new scale
                        var t = d3.event.transform;
                        newX = t.rescaleX(xScale);
                        newY = t.rescaleY(yScale);
                        currentXScale = newX; // Update the reference
                        currentYScale = newY; // Update the reference

                        // xScale = newX
                        // yScale = newY

                        // Update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path").style("stroke", "white");
                        xAxis.selectAll("text").style("fill", "white");

                        yAxis.selectAll("line, path").style("stroke", "white");
                        yAxis.selectAll("text").style("fill", "white");

                        // Update circle position
                        scatter.selectAll("circle")
                            .attr('cx', function (d) {
                                if (d.pval_adj !== null) return newX(d.logFC);
                            })
                            .attr('cy', function (d) {
                                if (d.pval_adj !== null) return newY(-Math.log10(d.pval_adj));
                            });

                        // Update the brush extents
                        brushLeft.extent([[0, 0], [newX(0), height]]);
                        brushRight.extent([[newX(0), 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            brushLeftG.call(brushLeft);
                            brushRightG.call(brushRight);
                        }

                    }

                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (leftBrushExtent) {
                        //     brushLeftG.call(brushLeft.move, [
                        //         [xScale(leftBrushExtent[0][0]), yScale(leftBrushExtent[0][1])], // Use original x and y extents
                        //         [xScale(leftBrushExtent[1][0]), yScale(leftBrushExtent[1][1])]
                        //     ]);
                        // }
                        // if (rightBrushExtent) {
                        //     brushRightG.call(brushRight.move, [
                        //         [xScale(rightBrushExtent[0][0]), yScale(rightBrushExtent[0][1])], // Use original x and y extents
                        //         [xScale(rightBrushExtent[1][0]), yScale(rightBrushExtent[1][1])]
                        //     ]);
                        // }
                    }
                    xlab.html("")
                    ylab.html("")

                    // Add X axis label with logarithmic notation
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "white")
                        .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

                    // Add Y axis label with logarithmic notation
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
                        .style("fill", "white");
                }

                else {
                    if (brushLeftG) brushLeftG.remove()
                    if (brushRightG) brushRightG.remove()
                    brushedGenesLeft = []
                    brushedGenesRight = []
                    xScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsN)))
                        .range([0, width]);
                    //console.log("Domain:", xScale.domain());

                    brushScatter = d3.brush()
                        .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                        .on("end", updateBrushScatter);

                    //console.log(averageExpressionsN);
                    //console.log(averageExpressionsC);
                    yScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsC)))
                        .range([height, 0])
                        .nice()
                    //console.log(yScale);

                    var currentXScale = xScale
                    var currentYScale = yScale
                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    zoom.on("zoom", updateChart1);
                    svg.call(zoom)

                    // if (brushScatterExtent) {
                    //     brushScatterG.call(brushScatter.move, [
                    //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                    //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                    //     ]);
                    // }


                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    xAxis.selectAll("text")
                        .style("fill", "white");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    yAxis.selectAll("text")
                        .style("fill", "white");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Scatter Plot")
                        .style("fill", "white");

                    xlab.html("")
                    ylab.html("")
                    // Add X axis label
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "white")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta2 + "))</tspan>");

                    // Add Y axis label
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta1 + "))</tspan>")
                        .style("fill", "white");

                    //svg.select("#scatter").selectAll("*").remove();

                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);


                    // Remove existing circles
                    // dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                return true;
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                return true;
                            } else {
                                return false;
                            }

                        })
                        .on("mouseover", function (d) {
                            // Highlight the gene on mouseover
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            // Display tooltip on mouseover
                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            const parts = d.gene.split('|');
                            // Use the first part as the gene name
                            const geneName = parts[0];

                            tooltip.html(`<strong>Gene:</strong> ${geneName}<br><strong>${chosen_meta2}:</strong> ${d.Normal.toFixed(2)}<br><strong>${chosen_meta1}:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? formatPValue(d.pval_adj) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                console.log("sono verde")
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }

                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);
                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }
                                heatmap(heatmap_data)

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                            } else {
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("fill", "green")
                                    .style("stroke-width", 2)
                                    .classed('pulse', true)
                                    .classed('pulse1', false)
                                    .raise();  // Move this element to the top

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                var select = document.getElementById("selectButton");

                                // Add new options for the genes in selectedGeneData that are not already in the select element
                                selectedGeneData.forEach(function (gene) {
                                    if (!Array.from(select.options).some(option => option.value === gene)) {
                                        var option = document.createElement("option");
                                        option.value = gene;
                                        option.text = gene;
                                        select.appendChild(option);
                                    }
                                });

                                synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                            }


                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", d => {
                            // Log the value of d['Normal'] to inspect its format
                            if (isNaN(d['Normal'])) {
                                console.log("NaN value found in 'Normal':", d['Normal']);
                            }
                            // Convert the value to a number, assuming it's a string
                            return xScale(parseFloat(d['Normal']));
                        })
                        .attr("cy", d => yScale(d['Case']))
                        .attr("r", d => {
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            } else if (d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            } else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "4"
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName) {
                                return "4"
                            }
                        })
                        .style("fill", d => {

                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                                return "green";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                                return "green";
                            }
                            else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {

                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {

                                return "royalblue";
                            }
                            else {
                                return "grey";
                            }
                        })
                        .attr("data-initial-fill", d => {

                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                currentCircleFill = "green"
                                return "green";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                currentCircleFill = "green"
                                return "green";
                            }
                            else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                currentCircleFill = "darkred"
                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                currentCircleFill = "royalblue"
                                return "royalblue";
                            }
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })

                    brushScatter = d3.brush()
                        .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                        .on("end", updateBrushScatter);

                    // Attach click event to the reset button
                    d3.select("#resetButton").on("click", resetZoom);

                    // Functions to handle brush events
                    function updateBrushScatter() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            brushScatterExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.Normal >= brushScatterExtent[0][0] && d.Normal <= brushScatterExtent[1][0] &&
                                    d.Case <= brushScatterExtent[0][1] && d.Case >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesScatter.push(point.gene);
                                }
                            });
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with grey
                                    if (currentFill === "grey") {
                                        return; // If grey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "darkred";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "royalblue";
                                            } else {
                                                return "grey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        var select = document.getElementById("selectButton");
                                        var options = select.options;

                                        for (var i = 0; i < options.length; i++) {
                                            if (!selectedGeneData.includes(options[i].value)) {
                                                select.removeChild(options[i]);
                                                break; // Exit the loop once the option is removed
                                            }
                                        }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);

                            brushedGenesScatter = []
                            brushScatterExtent = null; // Reset if there's no selection
                        }
                    }

                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {
                        console.log("ciao")

                        // Select all circles and filter only those that are in the selected points
                        scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                            .each(function (d) {
                                var selectedElement = d3.select(this);
                                var currentFill = selectedElement.style("fill");

                                // Check if the element is already filled with grey
                                if (currentFill === "grey") {
                                    return; // If grey, do nothing
                                }

                                // Check if the element is already highlighted
                                var isHighlighted = selectedElement.classed('pulse');

                                if (!isHighlighted) {
                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("fill", "green")
                                        .style("stroke-width", 2)
                                        .classed('pulse', true)
                                        .classed('pulse1', false)
                                        .raise();  // Move this element to the top

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                    // Get the select element
                                    var select = document.getElementById("selectButton");

                                    // Add new options for the genes in selectedGeneData that are not already in the select element
                                    selectedGeneData.forEach(function (gene) {
                                        if (!Array.from(select.options).some(option => option.value === gene)) {
                                            var option = document.createElement("option");
                                            option.value = gene;
                                            option.text = gene;
                                            select.appendChild(option);
                                        }
                                    });

                                    synchronizeAnimations(this);
                                }
                            });

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }

                    }

                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false

                            document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Brush Mode"
                            svg.call(zoom); // Re-enable zooming

                            brushScatterG.remove();
                            brushedGenesScatter = []

                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Save Brushed Genes"
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushScatter.extent([[0, 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushScatterG = svg.append("g")
                                .attr("class", "brush-scatter")
                                .call(brushScatter);


                            brushedGenesScatter = []

                        }
                    });

                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (brushScatterExtent) {
                        //     brushScatterG.call(brushScatter.move, [
                        //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                        //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                        //     ]);
                        // }
                    }

                    function updateChart1() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        currentXScale = newX
                        currentYScale = newY

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "white");

                        xAxis.selectAll("text")
                            .style("fill", "white");

                        yAxis.selectAll("line, path")
                            .style("stroke", "white");

                        yAxis.selectAll("text")
                            .style("fill", "white");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) { return newX(d.Normal); })
                            .attr('cy', function (d) { return newY(d.Case); });

                        brushScatter.extent([[0, 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            // brushScatterG.call(brushScatter);
                        }

                    }



                }


            }



            d3.select("#switchButton").on("click", function () {
                if (currentPlot === 'volcano') {
                    currentPlot = 'scatter';
                    SwitchingPlot(data, currentPlot)
                } else {
                    currentPlot = 'volcano';
                    SwitchingPlot(data, currentPlot)
                }
            });

            //dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

        }

        function updateScatterPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

            //console.log(parsed)

            var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
                return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
            }, parsed[0]);

            var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
                return currentGene.logFC < minGene.logFC ? currentGene : minGene;
            }, parsed[0]);

            //console.log(mostUpregulatedGene)
            var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
            var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

            // Set up margin, width, and height
            var margin = { top: 10, right: 100, bottom: 40, left: 60 };
            var width = 1000 - margin.left - margin.right;
            var height = 600 - margin.top - margin.bottom;

            // Create SVG container
            var svg = d3.select("#scatterPlot")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Create x and y scales
            var xScale = d3.scaleLinear()
                .domain(d3.extent(Object.values(averageExpressionsN)))
                .range([0, width]);
            console.log("Domain:", xScale.domain());

            var yScale = d3.scaleLinear()
                .domain(d3.extent(Object.values(averageExpressionsC)))
                .range([height, 0])
                .nice()
            //console.log(yScale);

            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale))

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");
            // Add Y axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale))

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            // Customization

            var clip = svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            svg.select("#scatter").selectAll("*").remove();
            scatter = svg.append('g')
                .attr("id", "scatter")
                .attr("clip-path", "url(#clip)");

            // Set the zoom and Pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")  // Set pointer-events to "all" here
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            // Attach click event to the reset button
            d3.select("#resetButton")
                .on("click", resetZoom);

            // Add X axis label
            xlab = svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta2 + "))</tspan>");

            // Add Y axis label
            ylab = svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta1 + "))</tspan>")
                .style("fill", "white");

            // Add title
            svg.append("text")
                .attr("id", "plotTitle")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Scatter Plot")
                .style("fill", "white");

            // Create circles for each gene
            var data = Object.keys(averageExpressionsN).map(function (gene) {
                // Find the corresponding logFC value from parsedLogFC_origin
                var logFCObj = parsed.find(d => d.Gene === gene) || null;
                var logFC = logFCObj ? logFCObj.logFC : null;

                if (logFC <= log_thr_fc) {
                    var type = "down"
                }
                else {
                    var type = "up"
                }

                var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
                var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

                return { gene: gene, Normal: averageExpressionsN[gene], Case: averageExpressionsC[gene], logFC: logFC, pval_adj: pval_adj, type: type };
            });

            console.log(averageExpressionsN.length)
            //console.log(data.length)

            // Merge data by Gene
            let mergedData = old_p_adj.map(d => {
                let log = parsed.find(p => p.Gene === d.Gene);
                return {
                    Gene: d.Gene,
                    logFC: log.logFC,
                    pval_adj: d.pval_adj ? d.pval_adj : null
                };
            })
            mergedData = mergedData.filter(d => d.logFC !== null && d.pval_adj !== null);

            console.log(mergedData);

            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width - 75) + "," + (height - 250) + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", 160)
                .attr("height", 210)
                .style("stroke", "white")
                .style("fill", "none")
                .style("filter", "url(#legendShadow)")
                .style("pointer-events", "none");

            // Append legend for upregulated genes (LogFC > log2(thr_fc) and pval_adj < threshold)
            var upregulatedLegend = legend.append("g")
                .attr("transform", "translate(0,0)");

            upregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "darkred")
                .classed("legend-circle", true);

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "white")
                .style("font-size", "20px")
                .text("Upregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "12px") // Smaller font size for subtitle
                .text("LogFC > log2(" + thr_fc + ") and");

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "white")
                .text("pval_adj < " + threshold)
                .style("font-size", "12px"); // Smaller font size for subtitle

            // Calculate the height of the first legend item
            var legendItemHeight = upregulatedLegend.node().getBBox().height;

            // Append legend for downregulated genes (LogFC < -log2(thr_fc) and pval_adj < threshold)
            var downregulatedLegend = legend.append("g")
                .attr("transform", "translate(0," + 2 * legendItemHeight + ")");

            downregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 65)
                .attr("r", 6)
                .style("fill", "royalblue")
                .classed("legend-circle", true);

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 68)
                .style("fill", "white")
                .style("font-size", "20px")
                .text("Downregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "12px") // Smaller font size for subtitle
                .text("LogFC < -log2(" + thr_fc + ") and");

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 96)
                .style("fill", "white")
                .text("pval_adj < " + threshold)
                .style("font-size", "12px"); // Smaller font size for subtitle

            // Append legend for not significant genes (abs(LogFC) < log2(thr_fc) OR pval_adj > threshold)
            var notSignificantLegend = legend.append("g")
                .attr("transform", "translate(0," + legendItemHeight + ")");

            notSignificantLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 40)
                .attr("r", 6)
                .style("fill", "grey")
                .classed("legend-circle", true);

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 40)
                .style("fill", "white")
                .style("font-size", "20px")
                .text("Not Significant")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "12px") // Smaller font size for subtitle
                .text("|LogFC| < log2(" + thr_fc + ") or");

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 68)
                .style("fill", "white")
                .text("pval_adj > " + threshold)
                .style("font-size", "12px"); // Smaller font size for subtitle

            // Add circles to the scatter plot
            var tooltip = d3.select("#tooltip");
            //console.log(data)
            svg.select("#scatter").selectAll("*").remove();
            scatter.selectAll("circle")
                .data(data)
                .enter().append("circle")
                .attr("cx", d => {
                    // Log the value of d['Normal'] to inspect its format
                    if (isNaN(d['Normal'])) {
                        console.log("NaN value found in 'Normal':", d['Normal']);
                    }
                    // Convert the value to a number, assuming it's a string
                    return xScale(parseFloat(d['Normal']));
                })
                .attr("cy", d => yScale(d['Case']))
                .attr("r", d => {
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    } else if (d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    } else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "4"
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName) {
                        return "4"
                    }
                })
                .style("fill", d => {

                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                        return "green";
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                        return "green";
                    }
                    else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {

                        return "darkred";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {

                        return "royalblue";
                    }
                    else {
                        return "grey";
                    }
                })
                .attr("data-initial-fill", d => {

                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        currentCircleFill = "green"
                        return "green";
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        currentCircleFill = "green"
                        return "green";
                    }
                    else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                        currentCircleFill = "darkred"
                        return "darkred";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                        currentCircleFill = "royalblue"
                        return "royalblue";
                    }
                }

                )
                .classed('pulse', d => {
                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        return true;
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        return true;
                    } else {
                        return false;
                    }

                })
                .on("mouseover", function (d) {
                    // Highlight the gene on mouseover
                    d3.select(this)
                        .style("stroke", "black")
                        .style("stroke-width", 2);

                    // Display tooltip on mouseover
                    tooltip.transition()
                        .duration(200) // Add transition duration for mouseout
                        .style("opacity", .9);

                    const parts = d.gene.split('|');
                    // Use the first part as the gene name
                    const geneName = parts[0];

                    tooltip.html(`<strong>Gene:</strong> ${geneName}<br><strong>${chosen_meta2}:</strong> ${d.Normal.toFixed(2)}<br><strong>${chosen_meta1}:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? formatPValue(d.pval_adj) : 'NA'}`)
                        .style("left", (d3.event.pageX + 15) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function (d) {
                    // Remove the highlight and hide tooltip on mouseout
                    d3.select(this)
                        .style("stroke", "none");

                    tooltip.transition()
                        .duration(200) // Add transition duration for mouseout
                        .style("opacity", 0)
                        .style("visibility", "none")
                        .style("pointer-events", "none"); // Disable pointer events for the tooltip
                })
                .on("click", function (d) {
                    var selectedElement = d3.select(this);
                    var currentFill = selectedElement.style("fill");

                    // Check if the element is already filled with grey
                    if (currentFill === "grey") {
                        return; // If grey, do nothing
                    }

                    // Check if the element is already highlighted
                    var isHighlighted = selectedElement.classed('pulse');

                    if (isHighlighted) {
                        console.log("sono verde")
                        // If already highlighted, remove the highlighting
                        selectedElement.style("fill", d => {
                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                return "royalblue";
                            } else {
                                return "grey";
                            }

                        })
                            .classed('pulse', false)
                            .classed("pulse1", false);
                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                        // Find and remove the corresponding option from the select element
                        var select = document.getElementById("selectButton");
                        var options = select.options;

                        for (var i = 0; i < options.length; i++) {
                            if (!selectedGeneData.includes(options[i].value)) {
                                select.removeChild(options[i]);
                                break; // Exit the loop once the option is removed
                            }
                        }
                        heatmap(heatmap_data)

                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                    } else {
                        // If not highlighted, apply the highlighting
                        selectedElement
                            .style("fill", "green")
                            .style("stroke-width", 2)
                            .classed('pulse', true)
                            .classed('pulse1', false)
                            .raise();  // Move this element to the top

                        // On click, filter data for the selected gene
                        selectedGeneData.push(d.gene);

                        // Get the select element
                        var select = document.getElementById("selectButton");

                        // Add new options for the genes in selectedGeneData that are not already in the select element
                        selectedGeneData.forEach(function (gene) {
                            if (!Array.from(select.options).some(option => option.value === gene)) {
                                var option = document.createElement("option");
                                option.value = gene;
                                option.text = gene;
                                select.appendChild(option);
                            }
                        });

                        synchronizeAnimations(this);
                        heatmap(heatmap_data)
                        // Call a function to create parallel coordinates plot using selectedGeneData
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                    }
                })
                .each(function (d) {
                    if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        d3.select(this).raise();
                    }
                })

            // Variables to store the brush extents in the original data space
            let brushScatterExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]

            let brushedGenesScatter = [];

            // Define brush for the left side (x < 0)
            var brushScatter = d3.brush()
                .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                .on("end", updateBrushScatter);

            var brushScatterG

            // To get the current scale
            var currentXScale = xScale; // This will give you the reference to the xScale
            var currentYScale = yScale

            // Functions to handle brush events
            function updateBrushScatter() {
                const selection = d3.event.selection;  // Access event via d3.event in v4
                if (selection) {
                    var [x0, y0] = selection[0]; // Get coordinates for left brush
                    var [x1, y1] = selection[1];

                    // Store the selection in data space, including y extents
                    brushScatterExtent = [
                        [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                        [currentXScale.invert(x1), currentYScale.invert(y1)]
                    ];

                    // Filter selected points based on the stored extents
                    var selectedPoints = data.filter(d => {
                        return (
                            d.Normal >= brushScatterExtent[0][0] && d.Normal <= brushScatterExtent[1][0] &&
                            d.Case <= brushScatterExtent[0][1] && d.Case >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                        );
                    });
                    // Add genes to brushedGenes if they are not already present
                    selectedPoints.forEach(point => {
                        if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                            brushedGenesScatter.push(point.gene);
                        }
                    });
                    console.log("Brushed genes scatter", brushedGenesScatter)
                    highlightSelectedGenes(selectedPoints);
                } else {
                    console.log("Brushed genes scatter", brushedGenesScatter)
                    // Remove the 'pulse' class from the brushed genes
                    scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                        .each(function (d) {
                            console.log(d)
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }

                            }
                        });

                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);

                    brushedGenesScatter = []
                    brushScatterExtent = null; // Reset if there's no selection
                }
            }

            // Function to highlight the selected genes based on the brush
            function highlightSelectedGenes(selectedPoints) {

                // Select all circles and filter only those that are in the selected points
                scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                    .each(function (d) {
                        var selectedElement = d3.select(this);
                        var currentFill = selectedElement.style("fill");

                        // Check if the element is already filled with grey
                        if (currentFill === "grey") {
                            return; // If grey, do nothing
                        }

                        // Check if the element is already highlighted
                        var isHighlighted = selectedElement.classed('pulse');

                        if (!isHighlighted) {
                            // If not highlighted, apply the highlighting
                            selectedElement
                                .style("fill", "green")
                                .style("stroke-width", 2)
                                .classed('pulse', true)
                                .classed('pulse1', false)
                                .raise();  // Move this element to the top

                            if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                            // Get the select element
                            var select = document.getElementById("selectButton");

                            // Add new options for the genes in selectedGeneData that are not already in the select element
                            selectedGeneData.forEach(function (gene) {
                                if (!Array.from(select.options).some(option => option.value === gene)) {
                                    var option = document.createElement("option");
                                    option.value = gene;
                                    option.text = gene;
                                    select.appendChild(option);
                                }
                            });

                            synchronizeAnimations(this);
                        }
                    });

                if (selectedPoints.length >= 1) {
                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                }

            }

            // Set the zoom and pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart)
                .on("end", function () {
                })

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach click event to the reset button
            d3.select("#resetButton").on("click", resetZoom);

            // Attach click event to the toggle zoom button
            d3.select("#toggleZoomButton").on("click", function () {
                zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                if (zoomEnabled) {
                    document.getElementById("resetButton").style.cursor = "pointer"
                    document.getElementById("resetButton").style.opacity = 1
                    document.getElementById("resetButton").disabled = false
                    document.getElementById("switchButton").style.cursor = "pointer"
                    document.getElementById("switchButton").style.opacity = 1
                    document.getElementById("switchButton").disabled = false

                    document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Brush Mode"
                    svg.call(zoom); // Re-enable zooming

                    brushScatterG.remove();
                    brushedGenesScatter = []

                } else {
                    document.getElementById("resetButton").style.cursor = "not-allowed"
                    document.getElementById("resetButton").style.opacity = 0.6
                    document.getElementById("resetButton").disabled = true
                    document.getElementById("switchButton").style.cursor = "not-allowed"
                    document.getElementById("switchButton").style.opacity = 0.6
                    document.getElementById("switchButton").disabled = true

                    document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Save Brushed Genes"
                    svg.on(".zoom", null); // Disable zooming by removing the zoom event

                    // Remove the brushes from the SVG

                    // Optionally, you can update the brush extents
                    brushScatter.extent([[0, 0], [width, height]]);

                    // Redraw brushes to reflect new zoom scale
                    brushScatterG = svg.append("g")
                        .attr("class", "brush-scatter")
                        .call(brushScatter);


                    brushedGenesScatter = []

                }
            });

            // Define the resetZoom function
            function resetZoom() {
                // Reset the zoom transformation
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);

                // if (brushScatterExtent) {
                //     brushScatterG.call(brushScatter.move, [
                //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                //     ]);
                // }
            }

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            function updateChart() {
                if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                // recover the new scale
                var newX = d3.event.transform.rescaleX(xScale);
                var newY = d3.event.transform.rescaleY(yScale);

                currentXScale = newX
                currentYScale = newY

                // update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX));
                yAxis.call(d3.axisLeft(newY));

                xAxis.selectAll("line, path")
                    .style("stroke", "white");

                xAxis.selectAll("text")
                    .style("fill", "white");

                yAxis.selectAll("line, path")
                    .style("stroke", "white");

                yAxis.selectAll("text")
                    .style("fill", "white");

                // update circle position
                scatter
                    .selectAll("circle")
                    .attr('cx', function (d) { return newX(d.Normal); })
                    .attr('cy', function (d) { return newY(d.Case); });

                brushScatter.extent([[0, 0], [width, height]]);

                if (!zoomEnabled) {
                    // Redraw brushes to reflect new zoom scale
                    // brushScatterG.call(brushScatter);
                }

            }

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }
            let brushLeftG
            let brushRightG
            let brushedGenesLeft = [];
            let brushedGenesRight = [];

            function SwitchingPlot(structure, choice) {

                if (choice == "volcano") {
                    if (brushScatterG) brushScatterG.remove();
                    brushedGenesScatter = []

                    // Create x and y scales
                    xScale.domain([
                        d3.min(data, d => d.logFC) - 0.5,
                        d3.max(data, d => d.logFC) + 0.5
                    ]);

                    yScale.domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20))) + 1]);

                    // Set the zoom and pan features
                    zoom = d3.zoom()
                        .scaleExtent([0.05, 20])
                        .extent([[0, 0], [width, height]])
                        .on("zoom", updateChart)
                        .on("end", function () {
                        })

                    // Reset zoom (assuming resetZoom is a function you have defined elsewhere)
                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);


                    // Variables to store the brush extents in the original data space
                    let leftBrushExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]
                    let rightBrushExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]

                    // if (leftBrushExtent) {
                    //     brushLeftG.call(brushLeft.move, [
                    //         [xScale(leftBrushExtent[0][0]), yScale(leftBrushExtent[0][1])], // Use original x and y extents
                    //         [xScale(leftBrushExtent[1][0]), yScale(leftBrushExtent[1][1])]
                    //     ]);
                    // }
                    // if (rightBrushExtent) {
                    //     brushRightG.call(brushRight.move, [
                    //         [xScale(rightBrushExtent[0][0]), yScale(rightBrushExtent[0][1])], // Use original x and y extents
                    //         [xScale(rightBrushExtent[1][0]), yScale(rightBrushExtent[1][1])]
                    //     ]);
                    // }

                    // Attach click event to the reset button
                    d3.select("#resetButton")
                        .on("click", function () {
                            // Reset zoom (assuming resetZoom is a function you have defined elsewhere)
                            svg.transition()
                                .duration(750)
                                .call(zoom.transform, d3.zoomIdentity);

                            // if (leftBrushExtent) {
                            //     brushLeftG.call(brushLeft.move, [
                            //         [xScale(leftBrushExtent[0][0]), yScale(leftBrushExtent[0][1])], // Use original x and y extents
                            //         [xScale(leftBrushExtent[1][0]), yScale(leftBrushExtent[1][1])]
                            //     ]);
                            // }
                            // if (rightBrushExtent) {
                            //     brushRightG.call(brushRight.move, [
                            //         [xScale(rightBrushExtent[0][0]), yScale(rightBrushExtent[0][1])], // Use original x and y extents
                            //         [xScale(rightBrushExtent[1][0]), yScale(rightBrushExtent[1][1])]
                            //     ]);
                            // }

                        });



                    // Update the zoom behavior to call updateChart1 (assuming updateChart1 is a function you have defined elsewhere)
                    zoom.on("zoom", updateChart1);

                    // Apply zoom behavior to the svg
                    svg.call(zoom);

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    xAxis.selectAll("text")
                        .style("fill", "white");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    yAxis.selectAll("text")
                        .style("fill", "white");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Volcano Plot")
                        .style("fill", "white");


                    // Update dots
                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            return selectedGeneData.some(selectedGene => selectedGene === d.gene);
                        })
                    // Remove existing circles
                    dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            return selectedGeneData.some(selectedGene => selectedGene === d.gene);
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }
                                heatmap(heatmap_data)

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            } else {
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("fill", "green")
                                    .style("stroke-width", 2)
                                    .classed('pulse', true)
                                    .classed('pulse1', false)
                                    .raise();  // Move this element to the top

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                var select = document.getElementById("selectButton");

                                // Add new options for the genes in selectedGeneData that are not already in the select element
                                selectedGeneData.forEach(function (gene) {
                                    if (!Array.from(select.options).some(option => option.value === gene)) {
                                        var option = document.createElement("option");
                                        option.value = gene;
                                        option.text = gene;
                                        select.appendChild(option);
                                    }
                                });

                                synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            }
                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) {
                            if (d.pval_adj !== null) {
                                return xScale(d.logFC)
                            }
                        })
                        .attr("cy", function (d) {
                            if (d.pval_adj !== null) {
                                return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                            }
                        })
                        .attr("r", 2)
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "darkred"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "royalblue"; // Downregulated
                                } else {
                                    return "grey"; // Not significant
                                }
                            } else {
                                return "grey"; // Not significant
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "darkred"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "royalblue"; // Downregulated
                                } else {
                                    return "grey"; // Not significant
                                }
                            } else {
                                return "grey"; // Not significant
                            }
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })


                    // To get the current scale
                    var currentXScale = xScale; // This will give you the reference to the xScale
                    var currentYScale = yScale

                    // Define brush for the left side (x < 0)
                    var brushLeft = d3.brush()
                        .extent([[0, 0], [xScale(0), height]])  // Constrain the brush to the left side
                        .on("end", updateBrushLeft);

                    // Define brush for the right side (x > 0)
                    var brushRight = d3.brush()
                        .extent([[xScale(0), 0], [width, height]])  // Constrain the brush to the right side
                        .on("end", updateBrushRight);


                    // Functions to handle brush events
                    function updateBrushLeft() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            leftBrushExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                console.log(d.logFC)
                                console.log("X0>=log", leftBrushExtent[0][0], "X1<=log", leftBrushExtent[1][0])
                                console.log(-Math.log10(d.pval_adj))
                                console.log("Y0<=pval", leftBrushExtent[0][1], "Y0<=pval", leftBrushExtent[1][1])
                                return (
                                    d.logFC >= leftBrushExtent[0][0] && d.logFC <= leftBrushExtent[1][0] &&
                                    -Math.log10(d.pval_adj) <= leftBrushExtent[0][1] && -Math.log10(d.pval_adj) >= leftBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesLeft.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesLeft.push(point.gene);
                                }
                            });
                            console.log("Brushed genes left", brushedGenesLeft)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes left", brushedGenesLeft)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesLeft.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with grey
                                    if (currentFill === "grey") {
                                        return; // If grey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "darkred";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "royalblue";
                                            } else {
                                                return "grey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        var select = document.getElementById("selectButton");
                                        var options = select.options;

                                        for (var i = 0; i < options.length; i++) {
                                            if (!selectedGeneData.includes(options[i].value)) {
                                                select.removeChild(options[i]);
                                                break; // Exit the loop once the option is removed
                                            }
                                        }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);

                            brushedGenesLeft = []
                            leftBrushExtent = null; // Reset if there's no selection
                        }
                    }

                    function updateBrushRight() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for right brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            rightBrushExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d =>
                                d.logFC >= rightBrushExtent[0][0] && d.logFC <= rightBrushExtent[1][0] &&
                                -Math.log10(d.pval_adj) <= rightBrushExtent[0][1] && -Math.log10(d.pval_adj) >= rightBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                            );
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesRight.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesRight.push(point.gene);
                                }
                            });
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesRight.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with grey
                                    if (currentFill === "grey") {
                                        return; // If grey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "darkred";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "royalblue";
                                            } else {
                                                return "grey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        var select = document.getElementById("selectButton");
                                        var options = select.options;

                                        for (var i = 0; i < options.length; i++) {
                                            if (!selectedGeneData.includes(options[i].value)) {
                                                select.removeChild(options[i]);
                                                break; // Exit the loop once the option is removed
                                            }
                                        }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);

                            brushedGenesRight = []
                            rightBrushExtent = null; // Reset if there's no selection
                        }
                    }


                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {

                        // Select all circles and filter only those that are in the selected points
                        scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                            .each(function (d) {
                                var selectedElement = d3.select(this);
                                var currentFill = selectedElement.style("fill");

                                // Check if the element is already filled with grey
                                if (currentFill === "grey") {
                                    return; // If grey, do nothing
                                }

                                // Check if the element is already highlighted
                                var isHighlighted = selectedElement.classed('pulse');

                                if (!isHighlighted) {
                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("fill", "green")
                                        .style("stroke-width", 2)
                                        .classed('pulse', true)
                                        .classed('pulse1', false)
                                        .raise();  // Move this element to the top

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                    // Get the select element
                                    var select = document.getElementById("selectButton");

                                    // Add new options for the genes in selectedGeneData that are not already in the select element
                                    selectedGeneData.forEach(function (gene) {
                                        if (!Array.from(select.options).some(option => option.value === gene)) {
                                            var option = document.createElement("option");
                                            option.value = gene;
                                            option.text = gene;
                                            select.appendChild(option);
                                        }
                                    });

                                    synchronizeAnimations(this);
                                }
                            });

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }

                    }


                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {

                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false

                            document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Brush Mode"
                            svg.call(zoom); // Re-enable zooming

                            brushLeftG.remove();
                            brushRightG.remove();
                            brushedGenesLeft = []
                            brushedGenesRight = []
                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Save Brushed Genes"
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushLeft.extent([[0, 0], [currentXScale(0), height]]);
                            brushRight.extent([[currentXScale(0), 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushLeftG = svg.append("g")
                                .attr("class", "brush-left")
                                .call(brushLeft);

                            brushRightG = svg.append("g")
                                .attr("class", "brush-right")
                                .call(brushRight);

                            brushedGenesLeft = []
                            brushedGenesRight = []

                        }
                    });


                    function updateChart1() {

                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled

                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        currentXScale = newX
                        currentYScale = newY

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "white");

                        xAxis.selectAll("text")
                            .style("fill", "white");

                        yAxis.selectAll("line, path")
                            .style("stroke", "white");

                        yAxis.selectAll("text")
                            .style("fill", "white");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) {
                                if (d.pval_adj !== null && !isNaN(d.pval_adj)) {
                                    return newX(d.logFC);
                                } else {
                                    return null;
                                }
                            })
                            .attr('cy', function (d) {
                                if (d.pval_adj !== null && !isNaN(d.pval_adj)) {
                                    const pvalAdjLog = -Math.log10(d.pval_adj);
                                    if (!isNaN(pvalAdjLog)) {
                                        return newY(pvalAdjLog);
                                    }
                                }
                                return null;
                            });

                        // Update the brush extents
                        brushLeft.extent([[0, 0], [newX(0), height]]);
                        brushRight.extent([[newX(0), 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            brushLeftG.call(brushLeft);
                            brushRightG.call(brushRight);
                        }

                    }
                    xlab.html("")
                    ylab.html("")

                    // Add X axis label with logarithmic notation
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "white")
                        .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

                    // Add Y axis label with logarithmic notation
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
                        .style("fill", "white");
                }

                else {
                    if (brushLeftG) brushLeftG.remove();
                    if (brushRightG) brushRightG.remove();
                    brushedGenesLeft = []
                    brushedGenesRight = []
                    xScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsN)))
                        .range([0, width]);
                    //console.log("Domain:", xScale.domain());


                    //console.log(averageExpressionsN);
                    //console.log(averageExpressionsC);
                    yScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsC)))
                        .range([height, 0])
                        .nice()

                    var currentXScale = xScale; // This will give you the reference to the xScale
                    var currentYScale = yScale

                    //console.log(yScale);

                    // Set the zoom and pan features
                    zoom = d3.zoom()
                        .scaleExtent([0.05, 20])
                        .extent([[0, 0], [width, height]])
                        .on("zoom", updateChart)
                        .on("end", function () {
                        })


                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    // if (brushScatterExtent) {
                    //     brushScatterG.call(brushScatter.move, [
                    //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                    //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                    //     ]);
                    // }
                    zoom.on("zoom", updateChart);
                    svg.call(zoom)

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    xAxis.selectAll("text")
                        .style("fill", "white");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    yAxis.selectAll("text")
                        .style("fill", "white");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Scatter Plot")
                        .style("fill", "white");

                    xlab.html("")
                    ylab.html("")
                    // Add X axis label
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "white")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta2 + "))</tspan>");

                    // Add Y axis label
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta1 + "))</tspan>")
                        .style("fill", "white");

                    //svg.select("#scatter").selectAll("*").remove();

                    // Update dots
                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            return selectedGeneData.some(selectedGene => selectedGene === d.gene);
                        })

                    // Remove existing circles
                    dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                return true;
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                return true;
                            } else {
                                return false;
                            }

                        })
                        .on("mouseover", function (d) {
                            // Highlight the gene on mouseover
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            // Display tooltip on mouseover
                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            const parts = d.gene.split('|');
                            // Use the first part as the gene name
                            const geneName = parts[0];

                            tooltip.html(`<strong>Gene:</strong> ${geneName}<br><strong>${chosen_meta2}:</strong> ${d.Normal.toFixed(2)}<br><strong>${chosen_meta1}:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? formatPValue(d.pval_adj) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                console.log("sono verde")
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }

                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);
                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }
                                heatmap(heatmap_data)

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                            } else {
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("fill", "green")
                                    .style("stroke-width", 2)
                                    .classed('pulse', true)
                                    .classed('pulse1', false)
                                    .raise();  // Move this element to the top

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                var select = document.getElementById("selectButton");

                                // Add new options for the genes in selectedGeneData that are not already in the select element
                                selectedGeneData.forEach(function (gene) {
                                    if (!Array.from(select.options).some(option => option.value === gene)) {
                                        var option = document.createElement("option");
                                        option.value = gene;
                                        option.text = gene;
                                        select.appendChild(option);
                                    }
                                });

                                synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                            }
                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", d => {
                            // Log the value of d['Normal'] to inspect its format
                            if (isNaN(d['Normal'])) {
                                console.log("NaN value found in 'Normal':", d['Normal']);
                            }
                            // Convert the value to a number, assuming it's a string
                            return xScale(parseFloat(d['Normal']));
                        })
                        .attr("cy", d => yScale(d['Case']))
                        .attr("r", d => {
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            } else if (d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            } else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "4"
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName) {
                                return "4"
                            }
                        })
                        .style("fill", d => {

                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                                return "green";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                                return "green";
                            }
                            else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {

                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {

                                return "royalblue";
                            }
                            else {
                                return "grey";
                            }
                        })
                        .attr("data-initial-fill", d => {

                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                currentCircleFill = "green"
                                return "green";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                currentCircleFill = "green"
                                return "green";
                            }
                            else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                currentCircleFill = "darkred"
                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                currentCircleFill = "royalblue"
                                return "royalblue";
                            }
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })

                    brushScatter = d3.brush()
                        .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                        .on("end", updateBrushScatter);

                    // Attach click event to the reset button
                    d3.select("#resetButton").on("click", resetZoom);

                    // Functions to handle brush events
                    function updateBrushScatter() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            brushScatterExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.Normal >= brushScatterExtent[0][0] && d.Normal <= brushScatterExtent[1][0] &&
                                    d.Case <= brushScatterExtent[0][1] && d.Case >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesScatter.push(point.gene);
                                }
                            });
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with grey
                                    if (currentFill === "grey") {
                                        return; // If grey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "darkred";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "royalblue";
                                            } else {
                                                return "grey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        var select = document.getElementById("selectButton");
                                        var options = select.options;

                                        for (var i = 0; i < options.length; i++) {
                                            if (!selectedGeneData.includes(options[i].value)) {
                                                select.removeChild(options[i]);
                                                break; // Exit the loop once the option is removed
                                            }
                                        }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);

                            brushedGenesScatter = []
                            brushScatterExtent = null; // Reset if there's no selection
                        }
                    }

                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {

                        // Select all circles and filter only those that are in the selected points
                        scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                            .each(function (d) {
                                var selectedElement = d3.select(this);
                                var currentFill = selectedElement.style("fill");

                                // Check if the element is already filled with grey
                                if (currentFill === "grey") {
                                    return; // If grey, do nothing
                                }

                                // Check if the element is already highlighted
                                var isHighlighted = selectedElement.classed('pulse');

                                if (!isHighlighted) {
                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("fill", "green")
                                        .style("stroke-width", 2)
                                        .classed('pulse', true)
                                        .classed('pulse1', false)
                                        .raise();  // Move this element to the top

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                    // Get the select element
                                    var select = document.getElementById("selectButton");

                                    // Add new options for the genes in selectedGeneData that are not already in the select element
                                    selectedGeneData.forEach(function (gene) {
                                        if (!Array.from(select.options).some(option => option.value === gene)) {
                                            var option = document.createElement("option");
                                            option.value = gene;
                                            option.text = gene;
                                            select.appendChild(option);
                                        }
                                    });

                                    synchronizeAnimations(this);
                                }
                            });

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }

                    }

            // Attach click event to the toggle zoom button
            d3.select("#toggleZoomButton").on("click", function () {
                zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                if (zoomEnabled) {
                    document.getElementById("resetButton").style.cursor = "pointer"
                    document.getElementById("resetButton").style.opacity = 1
                    document.getElementById("resetButton").disabled = false
                    document.getElementById("switchButton").style.cursor = "pointer"
                    document.getElementById("switchButton").style.opacity = 1
                    document.getElementById("switchButton").disabled = false

                    document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Brush Mode"
                    svg.call(zoom); // Re-enable zooming

                    brushScatterG.remove();
                    brushedGenesScatter = []

                } else {
                    document.getElementById("resetButton").style.cursor = "not-allowed"
                    document.getElementById("resetButton").style.opacity = 0.6
                    document.getElementById("resetButton").disabled = true
                    document.getElementById("switchButton").style.cursor = "not-allowed"
                    document.getElementById("switchButton").style.opacity = 0.6
                    document.getElementById("switchButton").disabled = true

                    document.getElementById("toggleZoomButton").textContent = "Toggle Zoom/Save Brushed Genes"
                    svg.on(".zoom", null); // Disable zooming by removing the zoom event

                    // Remove the brushes from the SVG

                    // Optionally, you can update the brush extents
                    brushScatter.extent([[0, 0], [width, height]]);

                    // Redraw brushes to reflect new zoom scale
                    brushScatterG = svg.append("g")
                        .attr("class", "brush-scatter")
                        .call(brushScatter);


                    brushedGenesScatter = []

                }
            });
                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (brushScatterExtent) {
                        //     brushScatterG.call(brushScatter.move, [
                        //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                        //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                        //     ]);
                        // }
                    }

                    function updateChart() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        currentXScale = newX
                        currentYScale = newY

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "white");

                        xAxis.selectAll("text")
                            .style("fill", "white");

                        yAxis.selectAll("line, path")
                            .style("stroke", "white");

                        yAxis.selectAll("text")
                            .style("fill", "white");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) { return newX(d.Normal); })
                            .attr('cy', function (d) { return newY(d.Case); });

                        brushScatter.extent([[0, 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            // brushScatterG.call(brushScatter);
                        }

                    }



                }

            }



            d3.select("#switchButton").on("click", function () {
                if (currentPlot === 'volcano') {
                    currentPlot = 'scatter';
                    SwitchingPlot(data, currentPlot)
                } else {
                    currentPlot = 'volcano';
                    SwitchingPlot(data, currentPlot)
                }
            });
            // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

        }


        function formatPValue(pval) {
            // Check if the p-value is too small to be displayed without scientific notation
            if (pval < 0.01) {
                // Use toExponential to format the p-value in scientific notation with two decimal places
                return pval.toExponential(3);
            } else {
                // Otherwise, use toFixed to format the p-value with two decimal places
                return pval.toFixed(2);
            }
        }


        let last_box = ""

        function updateBoxPlot(genename, parsedLogFC, dataN, dataC) {
            console.log(genename)
            if (combinedData.length == 0) {
                last_box = genename
                geneNameUP = genename;

                console.log(dataN_copy_pval[0])


                var geneDataN = dataN_copy.filter(d => d.gene === geneNameUP)
                var geneDataC = dataC_copy.filter(d => d.gene === geneNameUP)


                console.log(geneDataC)

                // Extract GSM values for each gene
                var gsmValuesC = Object.keys(geneDataC[0]).filter(key => !key.startsWith('gene'));
                var gsmValuesN = Object.keys(geneDataN[0]).filter(key => !key.startsWith('gene'));


                function computeBoxPlotStatistics(data1) {
                    var expressionValues = data1.map(entry => entry.expression);

                    // Sort the data for calculating quartiles
                    expressionValues.sort((a, b) => a - b);

                    // Calculate quartiles and median
                    var q1 = d3.quantile(expressionValues, 0.25);
                    var q3 = d3.quantile(expressionValues, 0.75);
                    var median = d3.median(expressionValues);

                    // Calculate interquartile range (IQR)
                    var iqr = q3 - q1;


                    var min = q1 - 1.5 * iqr
                    var max = q3 + 1.5 * iqr

                    return {
                        q1: q1,
                        median: median,
                        q3: q3,
                        iqr: iqr,
                        min: min,
                        max: max
                    };
                }

                let expressionValuesC
                geneDataC.forEach(entry => {
                    expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

                })

                //console.log(expressionValuesC)

                let expressionValuesN
                geneDataN.forEach(entry => {
                    expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

                })
                // Assuming you have expressionValuesC and expressionValuesN

                // Create a new array to store the combined data
                //combinedData;

                // Iterate over expressionValuesC and add objects to combinedData with type 'case'
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: chosen_meta1 });
                });

                // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: chosen_meta2 });
                });

                console.log(combinedData)

                var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


                sumstat = d3.nest()
                    .key(function (d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
                    .rollup(function (d) {
                        q1 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.25);
                        median = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.5);
                        q3 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.75);
                        interQuantileRange = q3 - q1;
                        min = q1 - 1.5 * interQuantileRange;
                        max = q3 + 1.5 * interQuantileRange;

                        return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
                    })
                    .entries(combinedData);

                var margin = { top: 10, right: 30, bottom: 30, left: 50 },
                    width = 500,
                    height = 330;


                var svg = d3.select("#boxPlot")
                    .html("")  // Clear previous content
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");

                var x = d3.scaleBand()
                    .range([0, width])
                    .domain([chosen_meta2, chosen_meta1])
                    .paddingInner(1)
                    .paddingOuter(.5)

                var xAxis = svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x))
                xAxis.selectAll("line, path")
                    .style("stroke", "white");
                xAxis.selectAll("text")
                    .style("fill", "white");

                // Calculate min and max from sumstat
                const minSumStat = d3.min(sumstat, d => d.value.min);
                const maxSumStat = d3.max(sumstat, d => d.value.max);

                // Calculate min and max from expressionValuesC and expressionValuesN
                const minExpressionC = d3.min(expressionValuesC);
                const maxExpressionC = d3.max(expressionValuesC);
                const minExpressionN = d3.min(expressionValuesN);
                const maxExpressionN = d3.max(expressionValuesN);

                // Determine the overall min and max for the y-axis
                const overallMin = Math.min(minSumStat, minExpressionC, minExpressionN);
                const overallMax = Math.max(maxSumStat, maxExpressionC, maxExpressionN);

                // Set the y-axis scale
                var y = d3.scaleLinear()
                    .domain([overallMin - 4, overallMax + 4]) // Adding padding of 4
                    .range([height, 0]);

                var yAxisGroup = svg.append("g")
                    .attr("class", "y-axis") // Assign a class to the group element
                    .call(d3.axisLeft(y));

                // Append the y-axis label
                yAxisGroup.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -40)  // Adjust the position as needed
                    .attr("x", -height / 2)
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .style("fill", "white")
                    .style("font-size", "14px")
                    .html("log<tspan dy='5'>2</tspan> <tspan dy ='-5'>(Expression)");


                // You can further customize the appearance of the axis elements if needed
                yAxisGroup.selectAll("line, path")
                    .style("stroke", "white");

                yAxisGroup.selectAll("text")
                    .style("fill", "white");

                // Add a title
                var title = svg.append("text")
                    .attr("class", "title")
                    .attr("x", width / 2)
                    .attr("y", margin.top)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .text("Gene " + geneNameUP)
                    .style("fill", "white");

                svg.selectAll(".vertLines")
                    .data(sumstat)
                    .transition()
                    .duration(1000)

                var line1 = svg
                    .selectAll(".vertLines")
                    .data(sumstat)
                    .enter()
                    .append("line")
                    .attr("class", "vertLines")
                    .attr("x1", function (d) { return (x(d.key)) })
                    .attr("x2", function (d) { return (x(d.key)) })
                    .attr("y1", function (d) { return (y(d.value.min)) })
                    .attr("y2", function (d) { return (y(d.value.max)) })
                    .attr("stroke", "black")
                    .style("width", 40)


                // rectangle for the main box
                var boxWidth = 100
                var box1 = svg
                    .selectAll(".boxes")
                    .data(sumstat)
                    .enter()
                    .append("rect")
                    .attr("class", "boxes")
                    .attr("x", function (d) { return (x(d.key) - boxWidth / 2) })
                    .attr("y", function (d) { return (y(d.value.q3)) })
                    .attr("height", function (d) { return (y(d.value.q1) - y(d.value.q3)) })
                    .attr("width", boxWidth)
                    .attr("stroke", "black")
                    .style("fill", function (d) {
                        if (d.key === chosen_meta1) {
                            return "#a05853"
                        }
                        else {
                            return "#118e91"
                        }
                    })
                var line2 = svg
                    .selectAll(".medianLines")
                    .data(sumstat)
                    .enter()
                    .append("line")
                    .attr("class", "medianLines")
                    .attr("x1", function (d) { return (x(d.key) - boxWidth / 2) })
                    .attr("x2", function (d) { return (x(d.key) + boxWidth / 2) })
                    .attr("y1", function (d) { return (y(d.value.median)) })
                    .attr("y2", function (d) { return (y(d.value.median)) })
                    .attr("stroke", "black")
                    .style("width", 80)

                var jitterWidth = 50
                var jitter = svg
                    .selectAll(".indPoints")
                    .data(combinedData)
                    .enter()
                    .append("circle")
                    .attr("class", function (d) {
                        // Add the pulse-red class if the GSM is in the gsmList
                        return gsmList.includes(d.GSM) ? "indPoints pulse-red" : "indPoints";
                    })
                    .attr("cx", function (d) { return (x(d.type) - jitterWidth / 2 + Math.random() * jitterWidth) })
                    .attr("cy", function (d) { return (y(d.expression)) })
                    .attr("r", 2)
                    .style("fill", "white")
                    .attr("stroke", function (d) {

                        return gsmList.includes(d.GSM) ? "black" : "black";

                    })
                    .attr("stroke-width", function (d) {
                        // Set stroke width based on presence in gsmList
                        return gsmList.includes(d.GSM) ? 3 : 1;
                    })
                    .on("click", function (d) {
                        // On click, select the circle and add the GSM value to the list
                        var selectedGSM = d.GSM;
                        var isSelected = gsmList.includes(selectedGSM);
                        // console.log(isSelected);

                        // Toggle selection state
                        if (!isSelected) {
                            gsmList.push(selectedGSM);

                        } else {
                            gsmList = gsmList.filter(gsm => gsm !== selectedGSM);
                        }

                        // Update class, stroke, and stroke-width
                        d3.select(this)
                            .classed("pulse-red", !isSelected)
                            .attr("stroke", isSelected ? "black" : "black")
                            .attr("stroke-width", isSelected ? 1 : 2);

                        synchronizeAnimations();

                        // Call necessary update functions
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                        console.log("PCA DATA IN BOXPLOT", pca_data)
                        pca(pca_data);


                    });


                // Determine the X positions for each group (left and right rectangles)
                const leftBoxX = x(chosen_meta2) - boxWidth / 2;
                const rightBoxX = x(chosen_meta1) - boxWidth / 2;

                // Set the extent of the brush for the left box (chosen_meta2)
                const brushLeft = d3.brush()
                    .extent([[leftBoxX, 0], [leftBoxX + boxWidth, height]]) // Constrain to the left box
                    .on("end", brushended);

                // Set the extent of the brush for the right box (chosen_meta1)
                const brushRight = d3.brush()
                    .extent([[rightBoxX, 0], [rightBoxX + boxWidth, height]]) // Constrain to the right box
                    .on("end", brushended);

                // Function to handle brushing for both sides
                function brushended() {
                    var selection = d3.event.selection; // Get the brush selection
                    var isLeftBrush = d3.select(this).attr("class").includes("brush-left"); // Check if it's the left brush
                    var isRightBrush = d3.select(this).attr("class").includes("brush-right"); // Check if it's the right brush

                    // Define brush regions (left or right)
                    const leftBoxX = x(chosen_meta2) - boxWidth / 2;
                    const rightBoxX = x(chosen_meta1) - boxWidth / 2;

                    // Handle deselection when no selection is made
                    if (!selection) {
                        svg.selectAll(".indPoints")
                            .filter(function (d) {
                                const cx = d3.select(this).attr("cx");

                                // Filter only for the left or right points depending on the brush
                                if (isLeftBrush) {
                                    return cx >= leftBoxX && cx <= leftBoxX + boxWidth;
                                } else if (isRightBrush) {
                                    return cx >= rightBoxX && cx <= rightBoxX + boxWidth;
                                }
                            })
                            .each(function (d) {
                                // Clear selection for these points
                                d3.select(this)
                                    .classed("pulse-red", false)
                                    .attr("stroke", "black")
                                    .attr("stroke-width", 1);

                                // Clear GSM list for this region
                                gsmList = gsmList.filter(gsm => gsm !== d.GSM);
                            });
                    } else {
                        // Handle the case when there is a selection
                        svg.selectAll(".indPoints")
                            .filter(function (d) {
                                const cx = d3.select(this).attr("cx");
                                const cy = d3.select(this).attr("cy");

                                // Apply filtering for the respective region
                                if (isLeftBrush) {
                                    return cx >= leftBoxX && cx <= leftBoxX + boxWidth &&
                                        selection[0][0] <= cx && cx <= selection[1][0] &&
                                        selection[0][1] <= cy && cy <= selection[1][1];
                                } else if (isRightBrush) {
                                    return cx >= rightBoxX && cx <= rightBoxX + boxWidth &&
                                        selection[0][0] <= cx && cx <= selection[1][0] &&
                                        selection[0][1] <= cy && cy <= selection[1][1];
                                }
                            })
                            .each(function (d) {
                                // On click, select the circle and add the GSM value to the list
                                var selectedGSM = d.GSM;
                                var isSelected = gsmList.includes(selectedGSM);

                                if (!isSelected) {
                                    gsmList.push(selectedGSM);
                                }

                                // Update class, stroke, and stroke-width
                                d3.select(this)
                                    .classed("pulse-red", gsmList.includes(selectedGSM))
                                    .attr("stroke", isSelected ? "black" : "black")
                                    .attr("stroke-width", !gsmList.includes(selectedGSM) ? 1 : 2);
                            });
                    }

                    // Call necessary update functions
                    synchronizeAnimations();
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                    pca(pca_data);
                }

                // Append the left brush (for left rectangle)
                svg.append("g")
                    .attr("class", "brush-left")
                    .call(brushLeft);

                // Append the right brush (for right rectangle)
                svg.append("g")
                    .attr("class", "brush-right")
                    .call(brushRight);


            } else {

                if (genename !== last_box) {
                    console.log(last_box)
                    last_box = genename
                    combinedData = []
                    geneNameUP = genename;
                    console.log(genename)

                    var geneDataN = dataN_copy.filter(d => d.gene === geneNameUP)
                    var geneDataC = dataC_copy.filter(d => d.gene === geneNameUP)



                    // Extract GSM values for each gene
                    console.log(geneDataC[0])
                    var gsmValuesC = Object.keys(geneDataC[0]).filter(key => !key.startsWith('gene'));
                    var gsmValuesN = Object.keys(geneDataN[0]).filter(key => !key.startsWith('gene'));
                    console.log(gsmValuesN)


                    function computeBoxPlotStatistics(data1) {
                        var expressionValues = data1.map(entry => entry.expression);

                        // Sort the data for calculating quartiles
                        expressionValues.sort((a, b) => a - b);

                        // Calculate quartiles and median
                        var q1 = d3.quantile(expressionValues, 0.25);
                        var q3 = d3.quantile(expressionValues, 0.75);
                        var median = d3.median(expressionValues);

                        // Calculate interquartile range (IQR)
                        var iqr = q3 - q1;


                        var min = q1 - 1.5 * iqr
                        var max = q3 + 1.5 * iqr

                        return {
                            q1: q1,
                            median: median,
                            q3: q3,
                            iqr: iqr,
                            min: min,
                            max: max
                        };
                    }

                    let expressionValuesC
                    geneDataC.forEach(entry => {
                        expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));
                    })

                    //console.log(expressionValuesC)

                    let expressionValuesN
                    geneDataN.forEach(entry => {
                        expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));
                    })
                    // Assuming you have expressionValuesC and expressionValuesN

                    // Create a new array to store the combined data
                    //combinedData;

                    // Iterate over expressionValuesC and add objects to combinedData with type 'case'
                    expressionValuesC.forEach((expression, i) => {
                        combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: chosen_meta1 });
                    });

                    // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
                    expressionValuesN.forEach((expression, i) => {
                        combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: chosen_meta2 });
                    });

                    console.log(combinedData)

                    var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


                    sumstat = d3.nest()
                        .key(function (d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
                        .rollup(function (d) {
                            q1 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.25);
                            median = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.5);
                            q3 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.75);
                            interQuantileRange = q3 - q1;
                            min = q1 - 1.5 * interQuantileRange;
                            max = q3 + 1.5 * interQuantileRange;

                            return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
                        })
                        .entries(combinedData);
                    var margin = { top: 10, right: 30, bottom: 30, left: 50 },
                        width = 500,
                        height = 330;


                    // Select the SVG element
                    var svg = d3.select("#boxPlot").select("svg").select("g");

                    var x = d3.scaleBand()
                        .range([0, width])
                        .domain([chosen_meta2, chosen_meta1])
                        .paddingInner(1)
                        .paddingOuter(.5)

                    // Calculate min and max from sumstat
                    const minSumStat = d3.min(sumstat, d => d.value.min);
                    const maxSumStat = d3.max(sumstat, d => d.value.max);

                    // Calculate min and max from expressionValuesC and expressionValuesN
                    const minExpressionC = d3.min(expressionValuesC);
                    const maxExpressionC = d3.max(expressionValuesC);
                    const minExpressionN = d3.min(expressionValuesN);
                    const maxExpressionN = d3.max(expressionValuesN);

                    // Determine the overall min and max for the y-axis
                    const overallMin = Math.min(minSumStat, minExpressionC, minExpressionN);
                    const overallMax = Math.max(maxSumStat, maxExpressionC, maxExpressionN);

                    // Set the y-axis scale
                    var y = d3.scaleLinear()
                        .domain([overallMin - 4, overallMax + 4]) // Adding padding of 4
                        .range([height, 0]);

                    // Update y-axis
                    svg.select(".y-axis")
                        .transition()
                        .duration(1000)
                        .call(d3.axisLeft(y));

                    // Update axis styles
                    svg.selectAll(".y-axis line, .y-axis path")
                        .style("stroke", "white");

                    svg.selectAll(".y-axis text")
                        .style("fill", "white");


                    // Select the existing title element
                    var title = svg.select(".title");

                    // Update the title text and transition its position
                    title.text("Gene " + geneNameUP)
                        .transition()
                        .duration(1000)
                        .attr("x", width / 2)
                        .attr("y", margin.top);

                    var line1 = svg.selectAll(".vertLines")
                        .data(sumstat);

                    // Remove old lines
                    line1.exit().remove();

                    // Update existing lines
                    line1.transition()
                        .duration(1000)
                        .attr("x1", function (d) { return x(d.key); })
                        .attr("x2", function (d) { return x(d.key); })
                        .attr("y1", function (d) { return y(d.value.min); })
                        .attr("y2", function (d) { return y(d.value.max); })
                        .attr("stroke", "black")
                        .style("width", 40);

                    // Append new lines
                    line1.enter()
                        .append("line")
                        .attr("class", "vertLines")
                        .attr("x1", function (d) { return x(d.key); })
                        .attr("x2", function (d) { return x(d.key); })
                        .attr("y1", function (d) { return y(d.value.min); })
                        .attr("y2", function (d) { return y(d.value.max); })
                        .attr("stroke", "black")
                        .style("width", 40);

                    boxWidth = 100

                    // Define the initial position and size of the boxes
                    var box1 = svg.selectAll(".boxes")
                        .data(sumstat);

                    // Remove old boxes
                    box1.exit().remove();

                    // Update existing boxes
                    box1.transition()
                        .duration(1000)
                        .attr("x", function (d) {
                            return x(d.key) - boxWidth / 2;
                        })
                        .attr("y", function (d) {
                            return y(d.value.q3);
                        })
                        .attr("height", function (d) {
                            return y(d.value.q1) - y(d.value.q3);
                        })
                        .attr("width", boxWidth) // Keep width constant
                        .style("fill", function (d) {
                            return d.key === chosen_meta1 ? "#a05853" : "#118e91";
                        });

                    // Append new boxes and smoothly transition them to their new positions
                    box1.enter()
                        .append("rect")
                        .attr("class", "boxes")
                        .attr("stroke", "black")
                        .style("fill", function (d) {
                            return d.key === chosen_meta1 ? "#a05853" : "#118e91";
                        })
                        .attr("x", function (d) { return x(d.key) - boxWidth / 2; }) // Set initial position
                        .attr("y", function (d) { return y(d.value.q3); }) // Set initial position
                        .attr("height", 0) // Set initial height to 0
                        .attr("width", boxWidth) // Keep width constant
                        .transition() // Transition to new position and size
                        .duration(1000)
                        .attr("y", function (d) { return y(d.value.q3); }) // Transition to new y position
                        .attr("height", function (d) { return y(d.value.q1) - y(d.value.q3); }); // Transition to new height

                    // Select existing median lines and smoothly update them
                    var medianLines = svg.selectAll(".medianLines")
                        .data(sumstat);

                    // Remove old median lines
                    medianLines.exit().remove();

                    // Update existing median lines
                    medianLines.transition()
                        .duration(1000)
                        .attr("x1", function (d) { return x(d.key) - boxWidth / 2; })
                        .attr("x2", function (d) { return x(d.key) + boxWidth / 2; })
                        .attr("y1", function (d) { return y(d.value.median); })
                        .attr("y2", function (d) { return y(d.value.median); });

                    // Append new median lines
                    medianLines.enter()
                        .append("line")
                        .attr("class", "medianLines")
                        .attr("stroke", "black")
                        .style("width", 80)
                        .attr("x1", function (d) { return x(d.key) - boxWidth / 2; })
                        .attr("x2", function (d) { return x(d.key) + boxWidth / 2; })
                        .attr("y1", function (d) { return y(d.value.median); })
                        .attr("y2", function (d) { return y(d.value.median); });

                    // Select the existing title or append a new one if it doesn't exist
                    var title = svg.selectAll(".title")
                        .data([0]); // Use dummy data to ensure only one title is selected or appended

                    // Update existing title text
                    title.text("Gene " + geneNameUP);

                    // Append new title if it doesn't exist
                    title.enter()
                        .append("text")
                        .attr("class", "title")
                        .attr("x", width / 2)
                        .attr("y", margin.top)
                        .attr("text-anchor", "middle")
                        .style("font-size", "18px")
                        .style("fill", "white")
                        .text("Gene " + geneNameUP);

                    // Smoothly transition the title position
                    title.transition()
                        .duration(1000)
                        .attr("x", width / 2)
                        .attr("y", margin.top);

                    // Update jitter points
                    var jitterWidth = 50;
                    var jitter = svg.selectAll(".indPoints")
                        .data(combinedData);

                    jitter.enter()
                        .append("circle")
                        .attr("class", ".indPoints")
                        .attr("stroke", "black")
                        .style("fill", "white")
                        .attr("r", 2)
                        .merge(jitter)
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) { console.log("circle"); return x(d.type) - jitterWidth / 2 + Math.random() * jitterWidth; })
                        .attr("cy", function (d) { return y(d.expression); });

                    jitter.exit().remove();

                } else {
                    console.log(dataN_copy_pval[0])

                    console.log("Sono update box, gene ricevuto " + genename)

                    // Select the SVG element
                    var svg = d3.select("#boxPlot").select("svg").select("g");


                    var jitterWidth = 50
                    // Define the update selection for the jitter circles
                    var jitterUpdate = svg.selectAll(".indPoints")
                        .data(combinedData);

                    console.log(combinedData)

                    // Update the class, stroke, and stroke width based on the GSM list
                    jitterUpdate.attr("class", function (d) {
                        // console.log(gsmList.includes(d.GSM));
                        if (gsmList.includes(d.GSM)) {
                            // this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                        }
                        return gsmList.includes(d.GSM) ? "indPoints pulse-red" : "indPoints";
                    })
                        .attr("stroke", function (d) {
                            return gsmList.includes(d.GSM) ? "black" : "black";
                        })
                        .attr("stroke-width", function (d) {
                            return gsmList.includes(d.GSM) ? 3 : 1;
                        })
                        .on("click", function (d) {
                            console.log(d)
                            var selectedGSM = d.GSM;
                            var isSelected = gsmList.includes(selectedGSM);
                            // console.log(isSelected);

                            // Toggle selection state
                            if (!isSelected) {
                                gsmList.push(selectedGSM);
                            } else {
                                gsmList = gsmList.filter(gsm => gsm !== selectedGSM);
                            }

                            // Update class, stroke, and stroke-width
                            d3.select(this)
                                .classed("pulse-red", !isSelected)
                                .attr("stroke", isSelected ? "black" : "black")
                                .attr("stroke-width", isSelected ? 1 : 2);
                            synchronizeAnimations()
                            // Call necessary update functions
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                            console.log("PCA DATA IN BOXPLOT", pca_data)
                            pca(pca_data);
                        });

                    // Enter selection: No need to append new circles, as we're only updating existing ones

                    // Remove old circles
                    jitterUpdate.exit().remove();
                }
            }
            d3.select("#selectButton").on("change", function (d) {

                // recover the option that has been chosen
                var selectedOption = d3.select(this).property("value")
                console.log(selectedOption)
                updateBoxPlot(selectedOption, parsedLogFC, dataN_copy, dataC_copy)
            })

            synchronizeAnimations()


            function synchronizeAnimations() {
                // Retrieve all elements with the class 'pulse'
                const elements = document.querySelectorAll(".pulse-red")
                console.log(elements)
                if (elements.length === 0) {
                    return
                }

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(elements[0], 'pulseRedAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseRedAnimation');

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }
            // combinedData = []
        }

        function dynamicParallel(geneselected, data, dataC, dataN, first_dims, totalOrder) {

            let structureCombinedData = [];

            console.log(geneselected)

            console.log(dataN)

            geneselected.forEach(geneName => {
                var geneDataN = dataN.filter(d => d.gene === geneName);
                var geneDataC = dataC.filter(d => d.gene === geneName);
                console.log(geneDataN)
                console.log(geneDataC)
                if (geneDataN.length == 0) {
                    selectedGeneData = [];
                    geneselected = [];
                    return;
                }

                // Extract sample names for each gene
                var sampleKeysC = Object.keys(geneDataC[0]).filter(key => key !== "gene");
                var sampleKeysN = Object.keys(geneDataN[0]).filter(key => key !== "gene");

                let expressionValuesC = [];
                geneDataC.forEach(entry => {
                    expressionValuesC.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                let expressionValuesN = [];
                geneDataN.forEach(entry => {
                    expressionValuesN.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                var combinedData = [];
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ sample: sampleKeysC[i], expression: expression, type: chosen_meta2, index: i });
                });
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ sample: sampleKeysN[i], expression: expression, type: chosen_meta1, index: i });
                });

                structureCombinedData.push({
                    gene: geneName,
                    expressions: combinedData
                });
            });

            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 50, bottom: 10, left: 50 },
                width = 1000 - margin.left - margin.right,
                height = 320 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#parallelcoordinates")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var color;
            if (selectedVariable === "case") {
                color = d3.scaleOrdinal()
                    .domain([chosen_meta1, chosen_meta2])
                    .range(["#0d0887", "#fddb6d"]);
            }

            // Extract metadata categories from the values of the first column
            var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
            console.log("Metadata categories:", metadataCategories);
            var orderedCategories = Object.keys(colorScaleValues);
            console.log("Ordered categories:", orderedCategories);

            // Initialize y scale object
            var y = {};

            // Iterate through ordered categories to create y scales
            metadataCategories.forEach((category, i) => {
                if (colorScaleValues[category]) {
                    var values = Object.keys(colorScaleValues[category]); // Extract values for the current category
                    console.log("Values for", category, ":", values);
                    y[category] = d3.scaleOrdinal()
                        .domain(values) // Use unique values for the current category
                        .range([...Array(values.length).keys()].map(i => i * (height / (values.length - 1))));
                } else {
                    console.log("No colorscalevalues");
                    var values = Object.values(metadata[i]); // Extract values for the current category
                    values.shift(); // Remove the first value (Sample_source_name_ch1)
                    var uniqueValues = [...new Set(values)]; // Filter out duplicates
                    uniqueValues.sort((a, b) => a - b); // Sort numerically
                    console.log("Values for", category, ":", uniqueValues);

                    // Check if all unique values are numeric
                    const allNumeric = uniqueValues.every(value => !isNaN(value) && value !== null && value !== '');

                    if (allNumeric) {
                        // If all values are numeric, use a linear scale
                        const min = d3.min(uniqueValues);
                        const max = d3.max(uniqueValues);
                        y[category] = d3.scaleLinear()
                            .domain([min, max]) // Set domain from min to max
                            .range([height, 0]); // Adjust the range as needed
                    } else {
                        // If there are non-numeric values, create an ordinal scale
                        console.log("Non-numeric values found. Using ordinal scale.");
                        var stepSize = height / (uniqueValues.length + 1); // Adjust +1 to leave some space at the top
                        y[category] = d3.scaleOrdinal()
                            .domain(uniqueValues) // Use unique values for the current category
                            .range([...Array(uniqueValues.length).keys()].map(i => (i + 1) * stepSize)); // Adjust the range
                    }
                }
            });

            // Now y scales are ordered according to colorScaleValues
            console.log("Y scales:", y);


            // Iterate through metadata categories to create y scales
            // metadataCategories.forEach((category, i) => {
            //     var values = Object.values(metadata[i]); // Extract values for the current category
            //     values.shift(); // Remove the first value (Sample_source_name_ch1)
            //     var uniqueValues = [...new Set(values)]; // Filter out duplicate
            //     console.log("Values for", category, ":", uniqueValues);
            //     y[category] = d3.scaleOrdinal()
            //         .domain(uniqueValues) // Use unique values for the current category
            //         .range([...Array(uniqueValues.length).keys()].map(i => height - i * (height / (uniqueValues.length - 1))));
            // });

            // Step 1: Find the global maximum expression value across all selected genes
            var globalMax = d3.max(geneselected, function (geneName) {
                var geneData = structureCombinedData.find(d => d.gene === geneName);
                var expressionValues = geneData.expressions.map(d => d.expression);
                return d3.max(expressionValues) + 3; // Get the max expression value for this gene
            });

            // Step 2: Define the Y-scale for all genes using the same domain (0 to globalMax)
            for (var i in geneselected) {
                var name = geneselected[i];

                // Define the Y-scale for the current gene with a domain of [0, globalMax]
                y[name] = d3.scaleLinear()
                    .domain([0, globalMax]) // Set the domain to 0 and the global max value
                    .range([height, 0]); // Map the domain to the visual height
            } console.log("Y scales:", y);

            // Initialize transposedData array
            var transposedData = [];

            // Iterate over each metadata category
            metadataCategories.forEach((category, index) => {
                // Skip the first category (Sample_geo_accession)
                if (index === 0) return;

                // Iterate over each sample in the metadata
                Object.keys(metadata[index]).forEach((sampleKey, sampleIndex) => {
                    // Skip the first key (Sample_geo_accession)
                    if (sampleIndex === 0) return;

                    // If transposedData is not initialized for this sample, initialize it
                    if (!transposedData[sampleKey]) {
                        transposedData[sampleKey] = { [metadataCategories[0]]: metadata[0][sampleKey] };
                    }

                    // Add metadata values for each category to the transposedData
                    transposedData[sampleKey][category] = metadata[index][sampleKey];
                });
            });

            // Extract gene names from structureCombinedData
            var geneNames = structureCombinedData.map(d => d.gene);

            // Combine metadata categories and gene names
            var allCategories = [...metadataCategories, ...geneNames];
            console.log("All Categories " + allCategories)

            if (totalOrder !== undefined) {
                dimensions = totalOrder
            } else {
                dimensions = first_dims.concat(geneselected);

            }

            var colorScale
            console.log(selectedVariable)

            function getColorScale(selectedVariable) {
                // Retrieve the predefined colors for the selected variable
                var variableColors = colorScaleValues[selectedVariable];

                // Get the unique values (keys) and their corresponding colors
                var uniqueValues = Object.keys(variableColors);
                var colors = uniqueValues.map(value => variableColors[value]);

                // Generate a color scale using the predefined colors
                colorScale = d3.scaleOrdinal()
                    .domain(uniqueValues)
                    .range(colors);

                // Log the domain and range of the color scale
                console.log("Color scale domain (unique values):", colorScale.domain());
                console.log("Color scale range (assigned colors):", colorScale.range());

                return colorScale;
            }


            getColorScale(selectedVariable)

            var legend = d3.select("#parallelLegend");
            legend.html(""); // Clear previous legend content

            // Define legend dimensions and position
            var legendWidth = 550;
            var legendHeight = 60;
            var legendX = 20;
            var legendY = 10;


            // Create legend
            legend = d3.select("#parallelLegend")
                .append("svg")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .append("g")
                .attr("class", "legendOrdinal")
                .attr("transform", "translate(" + legendX + "," + legendY + ")");

            // Define legend color scale
            var legendColor = d3.legendColor()
                .shapeWidth(60) // Adjust shape width as needed
                .orient('horizontal')
                .labelWrap(30)
                .scale(colorScale);

            // Append legend to the SVG
            legend.call(legendColor);

            // Truncate labels and add tooltips for full text
            legend.selectAll(".label")
                .each(function (d) {
                    var self = d3.select(this);
                    var textNode = self.node().childNodes[0]; // Get the text node
                    var text = textNode.textContent; // Get the text content
                    console.log(text)
                    var maxLength = 7; // Set the maximum length for the label before truncating
                    if (this.textContent.length > maxLength) {
                        var truncatedText = text.slice(0, maxLength) + '...';
                        self.text(truncatedText);
                        self.append("title").text(d); // Add full text as a tooltip
                    }
                });

            // Set legend label color and style
            legend.selectAll(".label")
                .style("fill", "white") // Set label color to white
                .style("font-size", "14px")  // Adjust font size
                .style("white-space", "pre")

            // Adjust label position
            legend.selectAll("text")
                .attr("dy", "-0.35em"); // Adjust vertical alignment

            console.log(dimensions)

            // Build the X scale -> it finds the best position for each Y axis
            var x = d3.scalePoint()
                .range([0, width])
                .domain(dimensions);

            // Iterate over each gene in structureCombinedData
            structureCombinedData.forEach(geneData => {
                // Loop through each sample in the gene's expression data
                geneData.expressions.forEach(sampleData => {
                    const sampleKey = sampleData.sample;

                    // If transposedData is not initialized for this sample, initialize it
                    if (!transposedData[sampleKey]) {
                        transposedData[sampleKey] = { [metadataCategories[0]]: metadata[0][sampleKey] };
                    }

                    // Add gene expression values for each gene to the transposedData
                    transposedData[sampleKey][geneData.gene] = sampleData.expression;
                });
            });


            // Log transposedData
            console.log("Transposed Data:", transposedData);
            var test = 0;
            var gsmPaths = svg.selectAll(".gsm-path")
                .data(Object.keys(transposedData))
                .enter()
                .append("path")
                .attr("class", function (d) {
                    // Add the pulse-red class if the GSM is in the gsmList
                    return gsmList.includes(d) ? "gsm-path pulse-red" : "gsm-path";
                })
                .attr("d", function (d) {
                    // Construct the path string using the order of dimensions specified by metadataCategories
                    return pathString(transposedData[d]);
                })
                .style("fill", "none")
                .style("stroke", function (d) {
                    var selectedValue = transposedData[d][selectedVariable];
                    // Add logic here to set stroke color based on sampleSource
                    return colorScale(selectedValue);
                    // Add logic here to set stroke color based on selectedVariable
                });

            // Function to construct the path string
            // Initialize an empty array to store coordinates
            function pathString(sampleData) {
                // Initialize an empty array to store coordinates
                var coordinates = [];
                // Loop through each dimension in metadataCategories
                dimensions.forEach(function (category) {
                    // Push the x and y coordinates to the coordinates array
                    coordinates.push([x(category), y[category](sampleData[category])]);
                });
                // Use D3's line generator to generate the path string
                return d3.line()(coordinates);
            }

            gsmPaths.on("click", function (d) {
                console.log(d)
                var clickedGSM = d; // Get the GSM value of the clicked path

                // Check if the clicked GSM is already in gsmList
                var index = gsmList.indexOf(clickedGSM);
                if (index === -1) {
                    // If not in the list, add it
                    gsmList.push(clickedGSM);
                    synchronizeAnimations(this)
                } else {
                    // If already in the list, remove it
                    gsmList.splice(index, 1);
                }
                console.log(gsmList)

                // Update the class of the clicked path based on its presence in gsmList
                d3.select(this)
                    .classed("pulse-red", gsmList.includes(clickedGSM));

                console.log("PCA DATA IN PARRALLEL", pca_data)

                pca(pca_data)

                updateBoxPlot(last_box, parsedLogFC, dataN_copy, dataC_copy)
                heatmap(heatmap_data)


            });

            function path(d) {
                return d3.line()(dimensions.map(function (geneName) { return [x(geneName), y[geneName](d[geneName])]; }));
            }

            svg.selectAll(".gsm-path").each(function (data, i) {
                // Reorder the SVG elements to bring paths with selected GSM to the front
                gsmPaths.each(function () {
                    var selectedGSM = d3.select(this).datum();
                    if (gsmList.includes(selectedGSM)) {
                        this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                    }
                });

                //console.log("Data bound to path " + (i + 1) + ":", data);
            });

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = document.querySelectorAll(".pulse-red")

                console.log(elements)

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseRedAnimation');

                if (!targetAnimation) {
                    return
                }

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseRedAnimation');

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }


            // Draw the axis:
            var axis = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    d3.select(this).call(d3.axisLeft().scale(y[d]));
                });

            // Add axis labels and truncate if necessary
            axis.append("text")
                .attr("class", "dragging") // Add the axis-label class
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    var maxLength = 5; // Max length before truncating
                    return d.length > maxLength ? d.slice(0, maxLength) + '...' : d;
                })
                .style("fill", "white")
                .append("title")
                .text(function (d) { return d; }); // Add full text as a tooltip

            axis.selectAll(".domain")
                .attr("stroke", "white");

            axis.selectAll(".tick text")
                .style("fill", "white");
            axis.selectAll(".tick line")
                .attr("stroke", "white");

            // Add truncated y-axis labels with tooltips
            axis.selectAll(".tick text")
                .each(function (d) {
                    var self = d3.select(this);
                    var text = d; // Full label text from the data bound
                    var maxLength = 5; // Set the maximum length for the label before truncating

                    // Add tooltip
                    self.append("title").text(text); // Add full text as a tooltip

                    // Truncate text if necessary
                    if (text.length > maxLength) {
                        var truncatedText = text.slice(0, maxLength) + '...';
                        self.text(truncatedText);
                    }
                });


            // Define drag behavior
            var drag = d3.drag()
                .on("start", dragstart)
                .on("drag", dragmove)
                .on("end", dragend);

            // Draw the axis:
            var axisGroups = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("class", "axis-group")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    d3.select(this).call(d3.axisLeft().scale(y[d]));
                })
                .call(drag); // Apply drag behavior to each axis group;

            // Add axis labels and truncate if necessary
            axisGroups.append("text")
                .attr("class", "dragging") // Add the axis-label class
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    var maxLength = 5; // Max length before truncating
                    return d.length > maxLength ? d.slice(0, maxLength) + '...' : d;
                })
                .style("fill", "white")
                .append("title")
                .text(function (d) { return d; }); // Add full text as a tooltip

            axisGroups.selectAll(".domain")
                .attr("stroke", "white");

            axisGroups.selectAll(".tick text")
                .style("fill", "white");

            axisGroups.selectAll(".tick line")
                .attr("stroke", "white");

            // Add truncated y-axis labels with tooltips
            axisGroups.selectAll(".tick text")
                .each(function (d) {
                    var self = d3.select(this);
                    var text = d; // Full label text from the data bound
                    var maxLength = 5; // Set the maximum length for the label before truncating

                    // Add tooltip
                    self.append("title").text(text); // Add full text as a tooltip

                    // Truncate text if necessary
                    if (text.length > maxLength) {
                        var truncatedText = text.slice(0, maxLength) + '...';
                        self.text(truncatedText);
                    }
                });


            // Drag start function
            function dragstart(d) {
                // Raise the dragged axis to the front
                d3.select(this).raise().classed("active", true);
                d3.select(this).classed("dragging", true);

            }

            // Drag move function
            function dragmove(d) {
                // Update the position of the dragged axis
                var newPosition = d3.event.x;
                d3.select(this).attr("transform", "translate(" + newPosition + ")");
            }

            function dragend(d) {
                // Get the new positions of the axis groups
                var newPositions = [];
                svg.selectAll(".axis-group").each(function (d) {
                    var transform = d3.select(this).attr("transform");
                    var translateX = +transform.split("(")[1].split(")")[0];
                    console.log(translateX)
                    newPositions.push({ dimension: d, position: translateX });
                });

                // Sort newPositions array based on position
                newPositions.sort(function (a, b) {
                    return a.position - b.position;
                });

                // Separate dimensions into geneselected, metadata (first_dims), and total ordering
                var geneselectedOrder = [];
                var metadataOrder = [];
                totalOrder = [];
                newPositions.forEach(function (d) {
                    if (geneselected.includes(d.dimension)) {
                        geneselectedOrder.push(d.dimension);
                    } else if (first_dims.includes(d.dimension)) {
                        metadataOrder.push(d.dimension);
                    }
                    totalOrder.push(d.dimension);
                });
                console.log(totalOrder)

                // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
                var removedDimensions = [];
                newPositions.forEach(function (d) {
                    console.log(d.position)
                    if ((d.position < -100 || d.position > 1000) && geneselected.includes(d.dimension)) {
                        var index = geneselectedOrder.indexOf(d.dimension);
                        if (index !== -1) {
                            removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                            // Remove highlighting color in the scatter plot
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === d.dimension)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                });
                        }
                    }
                });

                // Remove corresponding data from transposedData
                // transposedData = transposedData.filter(function (d) {
                //     return !removedDimensions.includes(d.gene);
                // });

                // Update totalOrder by removing removedDimensions
                totalOrder = totalOrder.filter(function (d) {
                    return !removedDimensions.includes(d);
                });

                console.log("Geneselected order:", geneselectedOrder);
                console.log("Metadata order:", metadataOrder);
                console.log("Total order:", totalOrder);
                console.log("Removed dimensions:", removedDimensions);

                selectedGeneData = geneselectedOrder
                // Find and remove the corresponding option from the select element
                var select = document.getElementById("selectButton");
                var options = select.options;

                for (var i = 0; i < options.length; i++) {
                    if (removedDimensions[0] === options[i].value) {
                        select.removeChild(options[i]);
                        break; // Exit the loop once the option is removed
                    }
                }
                heatmap(heatmap_data)


                first_dims = metadataOrder

                ordering = totalOrder
                heatmap(heatmap_data)

                // Update dimensions with new order

                // Redraw the parallel coordinates plot
                // Call updateParallel or relevant function here with updated dimensions
                dynamicParallel(geneselectedOrder, data, dataC, dataN, metadataOrder, totalOrder);
                if (currentPlot === 'volcano') {
                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else {
                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } d3.selectAll(".axis-label").classed("dragging", false);

            }

            // Function to handle mouseover event
            function highlight(d) {
                // Determine the value to highlight based on the selected variable
                var selected_reg = transposedData[d][selectedVariable];

                // First, every group turns grey and reduces opacity
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        // Highlight only the selected category, reduce opacity for others
                        return transposedData[data][selectedVariable] === selected_reg ? colorScale(selected_reg) : "lightgrey";
                    })
                    .style("opacity", function (data) {
                        // Set opacity based on whether it's the selected category or not
                        return transposedData[data][selectedVariable] === selected_reg ? "1" : "0.2";
                    });

                // Apply pulsing effect directly to the hovered element
                d3.select(this)
                    .classed("pulse-red", true);
                this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
            }

            // Function to handle mouseout event
            function doNotHighlight() {
                // Reset stroke color and opacity for all lines
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        var selectedValue = transposedData[data][selectedVariable];
                        // Add logic here to set stroke color based on sampleSource
                        return colorScale(selectedValue);
                        // Set stroke color based on the selected variable
                    })
                    .style("opacity", "1"); // Reset opacity to 1

                // Pulsing effect for paths with GSM in gsmList
                d3.selectAll(".gsm-path")
                    .filter(function (data) {
                        return !gsmList.includes(data);
                    })
                    .classed("pulse-red", false);
            }

            // Bind mouseover and mouseleave events to all lines
            svg.selectAll(".gsm-path")
                .on("mouseover", highlight)
                .on("mouseleave", doNotHighlight);


        }



        function updateParallel(geneselected, data, dataC, dataN, first_dims, totalOrder) {
            let structureCombinedData = [];

            geneselected.forEach(geneName => {
                var geneDataN = dataN.filter(d => d.gene === geneName);
                var geneDataC = dataC.filter(d => d.gene === geneName);

                // Extract GSM values for each gene
                var gsmValuesC = Object.keys(geneDataC[0]).filter(key => key.startsWith('GSM'));
                var gsmValuesN = Object.keys(geneDataN[0]).filter(key => key.startsWith('GSM'));

                let expressionValuesC = [];
                geneDataC.forEach(entry => {
                    expressionValuesC.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                let expressionValuesN = [];
                geneDataN.forEach(entry => {
                    expressionValuesN.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                var combinedData = [];
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: 'Case', index: i });
                });
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: 'Normal', index: i });
                });

                structureCombinedData.push({
                    gene: geneName,
                    expressions: combinedData
                });
            });

            //console.log(structureCombinedData);

            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 50, bottom: 10, left: 50 },
                width = 1000 - margin.left - margin.right,
                height = 320 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#parallelcoordinates")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            //var selectedVariable = document.querySelector('input[name="variable"]:checked').value;


            var color;
            if (selectedVariable === "case") {
                color = d3.scaleOrdinal()
                    .domain(["Normal", "Case"])
                    .range(["#0d0887", "#fddb6d"]);
            } else if (selectedVariable === "Smoker") {
                color = d3.scaleOrdinal()
                    .domain(["Never Smoked", "Former Smoker", "Current Smoker"])
                    .range(["#0d0887", "#bd3786", "#fddb6d"]);
            } else if (selectedVariable === "Gender") {
                color = d3.scaleOrdinal()
                    .domain(["Male", "Female"]) // Set the domain based on the age data
                    .range(["#0d0887", "#fddb6d"]);
            } else if (selectedVariable === "Stage") {
                color = d3.scaleOrdinal()
                    .domain(["Normal", "IA", "IB", "IIA", "IIB", "IIIA", "IIIB", "IV"])
                    .range(["#0d0887", "#46039f", "#7201a8", "#9c179e", "#bd3786", "#d8576b", "#ed7953", "#fddb6d"]);
            }

            var ageAtDiagnosisValues = metadata['Age at Diagnosis:ch1'];

            if (totalOrder !== undefined) {
                dimensions = totalOrder
            } else {
                dimensions = first_dims.concat(geneselected);

            }

            var y = {};
            for (var i in dimensions) {
                var name = dimensions[i];
                y[name] = d3.scaleLinear()
                    .domain([0, 20])
                    .range([height, 0]);
            }
            // Extract age data from metadata
            var ageData = metadata["Age at Diagnosis:ch1"];
            var genderData = metadata["Gender:ch1"];
            var smokerData = metadata["Cigarette Smoking Status:ch1"];
            var stageData = metadata["Stage:ch1"];

            // Convert age data to numbers
            ageData = ageData.map(function (age) {
                return parseFloat(age);
            });

            // Determine the age domain
            var ageDomain = d3.extent(ageData);

            // Update the y-scale for the age dimension
            y["Age at Diagnosis"] = d3.scaleLinear()
                .domain([30, 90]) // Set the domain based on the age data
                .range([height, 0]);

            // Update the y-scale for the age dimension
            y["Gender"] = d3.scaleOrdinal()
                .domain(["Male", "Female"]) // Set the domain based on the age data
                .range([height, 0]);

            // Update the y-scale for Cigarette Smoking Status
            y["Smoking Status"] = d3.scaleOrdinal()
                .domain(["Never Smoked", "Former Smoker", "Current Smoker"])
                .range([height, height / 2, 0])

            var interval = height / 7;

            y["Stage"] = d3.scaleOrdinal()
                .domain(["Normal", "IA", "IB", "IIA", "IIB", "IIIA", "IIIB", "IV"])
                .range([height, height - interval, height - 2 * interval, height - 3 * interval, height - 4 * interval, height - 5 * interval, height - 6 * interval, 0]);

            // Update the y-scale for type
            y["type"] = d3.scaleOrdinal()
                .domain(["Normal", "Case"])
                .range([height, 0])


            // Build the X scale -> it finds the best position for each Y axis
            var x = d3.scalePoint()
                .range([0, width])
                .domain(dimensions);

            //console.log(metadata)

            var legend = d3.select("#parallelLegend");
            legend.html(""); // Clear previous legend content

            // Define legend dimensions and position
            var legendWidth = 550;
            var legendHeight = 60;
            var legendX = 20;
            var legendY = 10;


            // Create legend
            legend = d3.select("#parallelLegend")
                .append("svg")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .append("g")
                .attr("class", "legendOrdinal")
                .attr("transform", "translate(" + legendX + "," + legendY + ")");

            // Define legend color scale
            var legendColor = d3.legendColor()
                .shapeWidth(60) // Adjust shape width as needed
                .orient('horizontal')
                .labelWrap(30)
                .scale(color);

            // Append legend to the SVG
            legend.call(legendColor);

            // Set legend label color and style
            legend.selectAll(".label")
                .style("fill", "white") // Set label color to white
                .style("font-size", "14px")  // Adjust font size

            // Adjust label position
            legend.selectAll("text")
                .attr("dy", "-0.35em"); // Adjust vertical alignment

            // Transpose the structureCombinedData
            transposedData = [];
            if (geneselected.length > 0) {
                // Use geneselected when it's not empty
                geneselected.forEach(function (geneName) {
                    var geneData = structureCombinedData.find(d => d.gene === geneName);
                    geneData.expressions.forEach(function (expression, i) {
                        if (!transposedData[i]) transposedData[i] = { GSM: expression.GSM }; // Use GSM value from expression
                        transposedData[i][geneName] = expression.expression;
                        transposedData[i].type = expression.type; // Add the type property to each observation
                        // Find the index of the GSM in the metadata's geo_accession array
                        var gsmIndex = metadata.geo_accession.findIndex(item => item === expression.GSM);
                        if (gsmIndex !== -1) {
                            // If the GSM is found in metadata, insert the corresponding Age at Diagnosis
                            transposedData[i]['Age at Diagnosis'] = metadata['Age at Diagnosis:ch1'][gsmIndex];
                            transposedData[i]['Gender'] = metadata['Gender:ch1'][gsmIndex];
                            transposedData[i]['Smoking Status'] = metadata['Cigarette Smoking Status:ch1'][gsmIndex];
                            transposedData[i]['Stage'] = metadata['Stage:ch1'][gsmIndex];
                        }
                    });
                });
            } else {
                // Use first_dims when geneselected is empty
                transposedData = metadata.geo_accession.map((gsm, i) => ({
                    GSM: gsm,
                    'Age at Diagnosis': metadata['Age at Diagnosis:ch1'][i],
                    'Gender': metadata['Gender:ch1'][i],
                    'Smoking Status': metadata['Cigarette Smoking Status:ch1'][i],
                    'Stage': metadata['Stage:ch1'][i],
                    type: metadata['Stage:ch1'][i] === "Normal" ? "Normal" : "Case"
                }));
            }
            //console.log(transposedData);
            // Select all paths with the class "gsm-path"
            var gsmPaths = svg.selectAll(".gsm-path")
                .data(transposedData)
                .enter()
                .append("path")
                .attr("class", function (d) {
                    // Add the pulse-red class if the GSM is in the gsmList
                    return gsmList.includes(d.GSM) ? "gsm-path pulse-red" : "gsm-path";
                })
                .attr("d", function (d) {
                    var pathString = path(d);
                    return pathString;
                })
                .style("fill", "none")
                .style("stroke", function (d) {
                    if (selectedVariable === "case") {
                        return color(d.type);
                    } else if (selectedVariable === "Smoker") {
                        return color(d['Smoking Status']);
                    } else if (selectedVariable === "Gender") {
                        return color(d['Gender']);
                    } else if (selectedVariable === "Stage") {
                        return color(d['Stage']);
                    }
                })

            gsmPaths.on("click", function (d) {
                var clickedGSM = d.GSM; // Get the GSM value of the clicked path

                // Check if the clicked GSM is already in gsmList
                var index = gsmList.indexOf(clickedGSM);
                if (index === -1) {
                    // If not in the list, add it
                    gsmList.push(clickedGSM);
                    synchronizeAnimations(this)
                } else {
                    // If already in the list, remove it
                    gsmList.splice(index, 1);
                }

                // Update the class of the clicked path based on its presence in gsmList
                d3.select(this)
                    .classed("pulse-red", gsmList.includes(clickedGSM));


                pca(pca_data)

                updateBoxPlot(last_box, parsedLogFC, dataN_copy, dataC_copy)

                heatmap(heatmap_data)

                console.log("GSM List:", gsmList);
            });

            function path(d) {
                return d3.line()(dimensions.map(function (geneName) { return [x(geneName), y[geneName](d[geneName])]; }));
            }

            svg.selectAll(".gsm-path").each(function (data, i) {
                // Reorder the SVG elements to bring paths with selected GSM to the front
                gsmPaths.each(function () {
                    var selectedGSM = d3.select(this).datum().GSM;
                    if (gsmList.includes(selectedGSM)) {
                        this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                    }
                });

                //console.log("Data bound to path " + (i + 1) + ":", data);
            });

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = document.querySelectorAll(".pulse-red")


                console.log(elements)

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseRedAnimation');

                if (!targetAnimation) {
                    return
                }

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseRedAnimation');

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }




            // Draw the axis:
            var axis = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    if (d === "Smoking Status") {
                        // For "Smoking Status" dimension, customize the tick format
                        d3.select(this).call(d3.axisLeft().scale(y[d]).tickFormat(function (d) {
                            // Customize the tick format here
                            return d === "Never Smoked" ? "Never" : d === "Former Smoker" ? "Former" : "Current";
                        }));
                    } else {
                        d3.select(this).call(d3.axisLeft().scale(y[d]));
                    }
                });

            axis.append("text")
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    // Set the label text for "Type" axis
                    return d === "type" ? "Type" : d;
                })
                .style("fill", "white");

            axis.selectAll(".domain")
                .attr("stroke", "white");

            axis.selectAll(".tick text")
                .style("fill", "white");
            axis.selectAll(".tick line")
                .attr("stroke", "white");


            // Define drag behavior
            var drag = d3.drag()
                .on("start", dragstart)
                .on("drag", dragmove)
                .on("end", dragend);

            // Draw the axis:
            var axisGroups = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("class", "axis-group")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    if (d === "Smoking Status") {
                        // For "Smoking Status" dimension, customize the tick format
                        d3.select(this).call(d3.axisLeft().scale(y[d]).tickFormat(function (d) {
                            // Customize the tick format here
                            return d === "Never Smoked" ? "Never" : d === "Former Smoker" ? "Former" : "Current";
                        }));
                    } else {
                        d3.select(this).call(d3.axisLeft().scale(y[d]));
                    }
                })
                .call(drag); // Apply drag behavior to each axis group;

            axisGroups.append("text")
                .attr("class", "dragging") // Add the axis-label class
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    // Set the label text for "Type" axis
                    return d === "type" ? "Type" : d;
                })
                .style("fill", "white");

            axisGroups.selectAll(".domain")
                .attr("stroke", "white");

            axisGroups.selectAll(".tick text")
                .style("fill", "white");
            axisGroups.selectAll(".tick line")
                .attr("stroke", "white");



            // Drag start function
            function dragstart(d) {
                // Raise the dragged axis to the front
                d3.select(this).raise().classed("active", true);
                d3.select(this).classed("dragging", true);

            }

            // Drag move function
            function dragmove(d) {
                // Update the position of the dragged axis
                var newPosition = d3.event.x;
                d3.select(this).attr("transform", "translate(" + newPosition + ")");
            }

            function dragend(d) {
                // Get the new positions of the axis groups
                var newPositions = [];
                svg.selectAll(".axis-group").each(function (d) {
                    var transform = d3.select(this).attr("transform");
                    var translateX = +transform.split("(")[1].split(")")[0];
                    console.log(translateX)
                    newPositions.push({ dimension: d, position: translateX });
                });

                // Sort newPositions array based on position
                newPositions.sort(function (a, b) {
                    return a.position - b.position;
                });

                // Separate dimensions into geneselected, metadata (first_dims), and total ordering
                var geneselectedOrder = [];
                var metadataOrder = [];
                totalOrder = [];
                newPositions.forEach(function (d) {
                    if (geneselected.includes(d.dimension)) {
                        geneselectedOrder.push(d.dimension);
                    } else if (first_dims.includes(d.dimension)) {
                        metadataOrder.push(d.dimension);
                    }
                    totalOrder.push(d.dimension);
                });

                // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
                var removedDimensions = [];
                newPositions.forEach(function (d) {
                    console.log(d.position)
                    if ((d.position < -100 || d.position > 1000) && geneselected.includes(d.dimension)) {
                        var index = geneselectedOrder.indexOf(d.dimension);
                        if (index !== -1) {
                            removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                            // Remove highlighting color in the scatter plot
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === d.dimension)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                });
                        }
                    }
                });

                // Remove corresponding data from transposedData
                transposedData = transposedData.filter(function (d) {
                    return !removedDimensions.includes(d.gene);
                });

                // Update totalOrder by removing removedDimensions
                totalOrder = totalOrder.filter(function (d) {
                    return !removedDimensions.includes(d);
                });

                console.log("Geneselected order:", geneselectedOrder);
                console.log("Metadata order:", metadataOrder);
                console.log("Total order:", totalOrder);
                console.log("Removed dimensions:", removedDimensions);

                selectedGeneData = geneselectedOrder

                selectedGeneData = geneselectedOrder
                // Find and remove the corresponding option from the select element
                var select = document.getElementById("selectButton");
                var options = select.options;

                for (var i = 0; i < options.length; i++) {
                    if (removedDimensions[0] === options[i].value) {
                        select.removeChild(options[i]);
                        break; // Exit the loop once the option is removed
                    }
                }


                first_dims = metadataOrder

                ordering = totalOrder

                // Update dimensions with new order

                // Redraw the parallel coordinates plot
                // Call updateParallel or relevant function here with updated dimensions
                updateParallel(geneselectedOrder, data, dataC, dataN, metadataOrder, totalOrder);
                if (currentPlot === 'volcano') {
                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else {
                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } d3.selectAll(".axis-label").classed("dragging", false);

            }
            var newPositions = [];
            svg.selectAll(".axis-group").each(function (d) {
                var transform = d3.select(this).attr("transform");
                var translateX = +transform.split("(")[1].split(")")[0];
                console.log(translateX)
                newPositions.push({ dimension: d, position: translateX });
            });
            console.log(newPositions)

            // Sort newPositions array based on position
            newPositions.sort(function (a, b) {
                return a.position - b.position;
            });

            // Separate dimensions into geneselected, metadata (first_dims), and total ordering
            var geneselectedOrder = [];
            var metadataOrder = [];
            totalOrder = [];
            newPositions.forEach(function (d) {
                if (geneselected.includes(d.dimension)) {
                    geneselectedOrder.push(d.dimension);
                } else if (first_dims.includes(d.dimension)) {
                    metadataOrder.push(d.dimension);
                }
                totalOrder.push(d.dimension);
            });

            // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
            var removedDimensions = [];
            newPositions.forEach(function (d) {
                if (d.position < -100 && geneselected.includes(d.dimension)) {
                    var index = geneselectedOrder.indexOf(d.dimension);
                    if (index !== -1) {
                        removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                        // Remove highlighting color in the scatter plot
                        scatter.selectAll("circle")
                            .filter(circleData => circleData.gene === d.dimension)
                            .style("fill", d => {
                                // Check if logFC is greater than or equal to the threshold
                                if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                    return "darkred";
                                } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                    return "royalblue";
                                } else {
                                    return "grey";
                                }
                            });
                    }
                }
            });

            // Remove corresponding data from transposedData
            transposedData = transposedData.filter(function (d) {
                return !removedDimensions.includes(d.gene);
            });

            // Update totalOrder by removing removedDimensions
            totalOrder = totalOrder.filter(function (d) {
                return !removedDimensions.includes(d);
            });

            console.log("Geneselected order:", geneselectedOrder);
            console.log("Metadata order:", metadataOrder);
            console.log("Total order:", totalOrder);
            console.log("Removed dimensions:", removedDimensions);

            selectedGeneData = geneselectedOrder


            first_dims = metadataOrder

            ordering = totalOrder
            // Function to handle mouseover event
            function highlight(d) {
                // Determine the value to highlight based on the selected variable
                var selected_reg;
                if (selectedVariable === "case") {
                    selected_reg = d.type;
                } else if (selectedVariable === "Smoker") {
                    selected_reg = d['Smoking Status'];
                } else if (selectedVariable === "Gender") {
                    selected_reg = d['Gender'];
                } else if (selectedVariable === "Stage") {
                    selected_reg = d['Stage']; // Set default value
                }

                // First, every group turns grey and reduces opacity
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        // Highlight only the selected category, reduce opacity for others
                        if (selectedVariable === "case") {
                            return data.type === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Smoker") {
                            return data['Smoking Status'] === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Gender") {
                            return data['Gender'] === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Stage") {
                            return data['Stage'] === selected_reg ? color(selected_reg) : "lightgrey";
                        }
                    })
                    .style("opacity", function (data) {
                        // Set opacity based on whether it's the selected category or not
                        if (selectedVariable === "case") {
                            return data.type === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Smoker") {
                            return data['Smoking Status'] === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Gender") {
                            return data['Gender'] === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Stage") {
                            return data['Stage'] === selected_reg ? "1" : "0.2";
                        }
                    });

                // Apply pulsing effect directly to the hovered element
                d3.select(this)
                    .classed("pulse-red", true);
                this.parentNode.appendChild(this); // Append to the parent node to bring it to the front

            }

            // Function to handle mouseout event
            function doNotHighlight() {
                // Reset stroke color and opacity for all lines
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        // Set stroke color based on the selected variable
                        if (selectedVariable === "case") {
                            return color(data.type);
                        } else if (selectedVariable === "Smoker") {
                            return color(data['Smoking Status']);
                        } else if (selectedVariable === "Gender") {
                            return color(data['Gender']);
                        } else if (selectedVariable === "Stage") {
                            return color(data['Stage']);
                        }
                    })
                    .style("opacity", "1"); // Reset opacity to 1

                // Pulsing effect for paths with GSM in gsmList
                d3.selectAll(".gsm-path")
                    .filter(function (data) {
                        return !gsmList.includes(data.GSM);
                    })
                    .classed("pulse-red", false);
            }

            // Bind mouseover and mouseleave events to all lines
            svg.selectAll(".gsm-path")
                .on("mouseover", highlight)
                .on("mouseleave", doNotHighlight);


        }

        function heatmap(heatmap_data) {
            console.log(heatmap_data)
            document.getElementById("loadingOverlay").style.display = "none";

            var heatmap_data_subset = heatmap_data.slice(0, displayed_rows);
            console.log(heatmap_data_subset)
            // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
            var myGroups = heatmap_data_subset.map(d => d.gene);
            var myVars = Object.keys(heatmap_data_subset[0]).filter(d => d !== "gene");
            // set the dimensions and margins of the graph

            var margin = { top: 40, right: 75, bottom: 30, left: 100 },
                width = 600 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#heatmap")
                .html("")
                .append("svg")
                .attr("width", 670)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + (margin.left + 46) + "," + margin.top + ")");

            // Build X scales and axis:
            var x = d3.scaleBand()
                .range([0, width])
                .domain(myVars)
                .padding(0.05);

            svg.append("g")
                .style("font-size", 15)
                .attr("transform", "translate(0,0)")
                .call(d3.axisTop(x).tickSize(0))
                .select(".domain").remove();

            // Add click event listener to the X-axis tick texts
            svg.selectAll(".tick text")
                .style("fill", "white")
                .style("text-transform", "uppercase")

            // Build Y scales and axis:
            var y = d3.scaleBand()
                .range([0, height])
                .domain(myGroups)
                .padding(0.05);

            // Add title text
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -25)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Heatmap")
                .style("fill", "white");
            // Build color scale
            var myColor = d3.scaleSequential()
                .interpolator(d3.interpolateInferno)
                .domain([d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v])),
                d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v]))]);

            // create a tooltip
            var tooltip = d3.select("#heatmap")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px");

            // Three functions that change the tooltip when user hover / move / leave a cell
            var mouseover = function (d) {
                tooltip
                    .style("opacity", 1);

                if (d3.select(this).style("stroke") === "none") {
                    d3.select(this)
                        .style("stroke", "yellow")
                        .style("opacity", 1);
                }

            };

            var mousemove = function (d) {
                var valueString;
                if (d.value < 0.01) {
                    valueString = d.value.toExponential(2) + "%";
                } else {
                    valueString = (d.value).toFixed(2) + "%";
                }
                // Calculate the position of the tooltip
                var xPosition = d3.event.pageX + 10; // 10 pixels to the right of the mouse pointer
                var yPosition = d3.event.pageY - 10; // 10 pixels above the mouse pointer

                var variableUppercase = d.variable.toUpperCase();

                tooltip
                    .html("The contribution percentage of<br>" + d.gene + " in " + variableUppercase + " is: " + valueString)
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px");
            };

            var mouseleave = function (d) {
                tooltip
                    .style("opacity", 0)
                    .style("pointer-events", "none"); // Disable pointer events for the tooltip

                if (d3.select(this).style("stroke") === "yellow") {

                    d3.select(this).style("stroke", "none")
                        .style("opacity", 0.8)

                }

                // Highlight the corresponding heatmap squares
                square
                    .filter(function (heatmapData) {
                        console.log(heatmapData)

                        return selectedGeneData.includes(heatmapData.gene);
                    })
                    .style("opacity", 1) // Change opacity to highlight
                    .style("stroke", "yellow") // Change stroke color to highlight (optional)
                    .style("stroke-width", 2); // Increase stroke width (optional)



            };

            // add the squares
            square = svg.selectAll(".heatmap-rect")
                .data(heatmap_data_subset.flatMap(d => myVars.map(v => ({ gene: d.gene, variable: v, value: d[v] }))))
                .enter()
                .append("rect")
                .attr("x", function (d) { return x(d.variable); })
                .attr("y", function (d) { return y(d.gene); })
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", function (d) { return myColor(d.value); })
                .style("stroke-width", 4)
                .style("stroke", "none")
                .style("opacity", 0.8)
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseout", mouseleave)
                .on("click", function (d) {
                    var selectedElement = d3.select(this);

                    // Check if the rectangle is already stroked
                    var isRectangleStroked = selectedElement.style("stroke") === "red";

                    // Find the corresponding scatterplot circle and toggle its selection
                    var correspondingCircle = scatter.selectAll("circle")
                        .filter(function (circleData) {
                            return circleData.gene === d.gene;
                        });

                    // Store the selected rectangle's variable
                    var selectedVariable = d.variable;

                    // Remove stroke from all rectangles of the current gene
                    svg.selectAll("rect")
                        .filter(function (rectData) {
                            if (rectData !== undefined) {
                                return rectData.gene === d.gene;
                            }
                        })
                        .style("stroke", "none");

                    // Toggle the stroke of the selected rectangle
                    selectedElement.style("stroke", "red");

                    // If the rectangle is already stroked, remove the stroke and revert circle's fill color
                    if (isRectangleStroked) {
                        var initialCircleFill = correspondingCircle.attr("data-initial-fill"); // Retrieve the initial fill color
                        selectedElement.style("stroke", "none");
                        correspondingCircle.style("fill", initialCircleFill)
                            .classed("pulse1", false)
                        synchronizeAnimations(correspondingCircle.node(), true)
                    } else {
                        // If the rectangle is not stroked, toggle the stroke and set circle's fill color
                        currentCircleFill = correspondingCircle.attr("data-initial-fill");
                        console.log(correspondingCircle)
                        console.log(currentCircleFill)
                        correspondingCircle.attr("data-initial-fill", currentCircleFill); // Save the initial fill color
                        selectedElement.style("stroke", "red");
                        correspondingCircle.style("fill", myColor(d.value)).classed("pulse1", true);
                        console.log(correspondingCircle)
                        synchronizeAnimations(correspondingCircle.node(), false)
                    }
                });


            if (displayed_rows > 15) {
                // Highlight the corresponding heatmap squares
                square
                    .filter(function (heatmapData) {
                        console.log(heatmapData)

                        return selectedGeneData.includes(heatmapData.gene);
                    })
                    .style("opacity", 1) // Change opacity to highlight
                    .style("stroke", "yellow") // Change stroke color to highlight (optional)
                    .style("stroke-width", 2); // Increase stroke width (optional)

            }


            svg.append("g")
                .style("font-size", 15)
                .style("fill", "white")
                .call(d3.axisLeft(y).tickSize(0))
                .select(".domain").remove();

            // Select and style the tick text for the Y axis
            svg.selectAll(".tick text")
                .filter(function (d) { return myGroups.includes(d); }) // Ensure we only target Y-axis ticks
                .style("fill", "white") // Set the default color to white
                .classed("pulse", function (d) {
                    // Check if d (the current tick value) exists in selectedGeneData
                    return selectedGeneData.includes(d); // d should be the gene identifier
                })
                .style("cursor", "pointer") // Change cursor to pointer on hover
                .style("font-size", function () {
                    // Dynamically set font size based on displayed_rows
                    if (displayed_rows > 20) {
                        return Math.max(6, 15 - (displayed_rows - 20) * 0.4) + "px"; // Reduce font size as displayed_rows increases
                    }
                    return "15px"; // Default font size
                })
                .on("mouseover", function (d) {
                    if (displayed_rows > 15) {
                        // Lower the opacity of all other text elements
                        svg.selectAll(".tick text")
                            .filter(function (d) { return myGroups.includes(d); }) // Ensure we only target Y-axis ticks
                            .style("opacity", 0.2);

                        // Zoom in and bring the hovered element to the front
                        const hoveredText = d3.select(this)
                            .style("font-size", "20px") // Increase font size
                            .style("font-weight", "bold") // Make it bold
                            .style("opacity", 1) // Ensure the hovered element remains fully visible
                            .attr("dx", "10px") // Slightly shift right
                            .attr("dy", "0px"); // Keep it aligned

                        // Re-append the element to bring it to the front
                        hoveredText.node().parentNode.appendChild(hoveredText.node());

                        // Highlight the corresponding heatmap squares
                        square
                            .filter(function (heatmapData) {
                                console.log(heatmapData)
                                console.log(d)

                                return heatmapData.gene === d; // Match the hovered tick text with the heatmap gene
                            })
                            .style("opacity", 1) // Change opacity to highlight
                            .style("stroke", "yellow") // Change stroke color to highlight (optional)
                            .style("stroke-width", 2); // Increase stroke width (optional)

                    } else {
                        d3.select(this)
                            .filter(function (d) { return myGroups.includes(d); }) // Ensure we only target Y-axis ticks
                            .style("opacity", 0.7); // Simple opacity change when fewer than 15 rows

                    }
                    synchronizeAnimations(this, true)

                })
                .on("mouseout", function (d) {
                    if (displayed_rows > 15) {
                        // Reset the opacity of all text elements to 1
                        svg.selectAll(".tick text")
                            .filter(function (d) { return myGroups.includes(d); }) // Ensure we only target Y-axis ticks
                            .style("opacity", 1)
                            .style("font-size", function () {
                                // Dynamically set font size based on displayed_rows
                                if (displayed_rows > 20) {
                                    return Math.max(6, 15 - (displayed_rows - 20) * 0.4) + "px"; // Reduce font size as displayed_rows increases
                                }
                                return "15px"; // Default font size
                            })

                        // Reset the style of the hovered element
                        d3.select(this)
                            .style("font-size", function () {
                                // Dynamically set font size based on displayed_rows
                                if (displayed_rows > 20) {
                                    return Math.max(6, 15 - (displayed_rows - 20) * 0.4) + "px"; // Reduce font size as displayed_rows increases
                                }
                                return "15px"; // Default font size
                            }) // Revert font size
                            .style("font-weight", "normal") // Revert to normal weight
                            .style("opacity", 1) // Full opacity for all text elements
                            .attr("dx", "0px"); // Revert to original position

                        square
                            .style("opacity", 1) // Reset opacity
                            .style("stroke", "none"); // Reset stroke (optional)

                        // Highlight the corresponding heatmap squares
                        square
                            .filter(function (heatmapData) {
                                console.log(heatmapData)
                                console.log(selectedGeneData)

                                return selectedGeneData.includes(heatmapData.gene); // Match the hovered tick text with the heatmap gene
                            })
                            .style("opacity", 1) // Change opacity to highlight
                            .style("stroke", "yellow") // Change stroke color to highlight (optional)
                            .style("stroke-width", 2); // Increase stroke width (optional)


                    } else {
                        d3.select(this)
                            .filter(function (d) { return myGroups.includes(d); }) // Ensure we only target Y-axis ticks
                            .style("opacity", 1) // Reset opacity for fewer than 15 rows
                    }
                    synchronizeAnimations(this, true)

                })
                .on("click", function (d) {
                    // Toggle gene in selectedGeneData
                    const index = selectedGeneData.indexOf(d);
                    // Get the select element
                    var select = document.getElementById("selectButton");

                    if (index > -1) {
                        // Gene is already selected, remove it
                        selectedGeneData.splice(index, 1);
                        d3.select(this).classed("pulse", false)
                        var select = document.getElementById("selectButton");
                        var options = select.options;

                        for (var i = 0; i < options.length; i++) {
                            if (!selectedGeneData.includes(options[i].value)) {
                                select.removeChild(options[i]);
                                break; // Exit the loop once the option is removed
                            }
                        }
                    } else {
                        // Gene is not selected, add it
                        selectedGeneData.push(d);
                        d3.select(this).classed("pulse", true)
                        // Add new options for the genes in selectedGeneData that are not already in the select element
                        selectedGeneData.forEach(function (gene) {
                            if (!Array.from(select.options).some(option => option.value === gene)) {
                                var option = document.createElement("option");
                                option.value = gene;
                                option.text = gene;
                                select.appendChild(option);
                            }
                        });

                    }
                    console.log("Updated selectedGeneData:", selectedGeneData);

                    synchronizeAnimations(this, true)

                    dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims);
                    updateBoxPlot(last_box, parsedLogFC, dataN_copy, dataC_copy);
                    if (currentPlot === 'volcano') {
                        updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj);
                    } else {
                        updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj);
                    }

                    // Optionally, you can trigger an update or refresh of your visualization
                    // updateVisualization();
                });

            function synchronizeAnimations(targetElement, banana) {

                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];
                let targetAnimation
                if (banana) {
                    targetAnimation = findAnimByName(targetElement, 'pulseAnimation');
                }
                else {
                    targetAnimation = findAnimByName(targetElement, 'pulseAnimation1');
                }
                // Retrieve the Animation object of the target element

                if (!targetAnimation) {
                    return
                }

                console.log("sono passato")

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }


            // Define the color scale for the legend
            var legendScale = d3.scaleLinear()
                .domain([d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v])),
                d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v]))])
                .range([0, 150]); // Adjust the range according to the height of the heatmap

            // Specify the tick values based on desired intervals
            var tickValues = [
                d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v])), // Minimum value
                (d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) - d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v]))) / 4, // 1/4 of maximum
                (d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) - d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v]))) / 2, // 2/4 of maximum
                (d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) - d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v]))) * 3 / 4, // 3/4 of maximum
                d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) // Maximum value
            ];

            // Create a separate SVG element for the legend
            var legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (450) + "," + 10 + ")");

            // Create color gradient for legend
            var defs = legend.append("defs");
            var linearGradient = defs.append("linearGradient")
                .attr("id", "linear-gradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%");

            // Add color stops based on the heatmap color scale
            myColor.ticks(10).forEach(function (t, i, n) {
                linearGradient.append("stop")
                    .attr("offset", (100 * i / n.length) + "%")
                    .attr("stop-color", myColor(t));
            });

            // Draw rectangle to display the legend
            legend.append("rect")
                .attr("width", 10)
                .attr("height", 150)
                .style("fill", "url(#linear-gradient)");

            legendAxis = d3.axisRight(legendScale)
                .tickValues(tickValues)
                .tickFormat(function (d) { return (d).toFixed(2) + "%"; }); // Format tick values with three digits after the comma and add a percentage symbol
            var axis = legend.append("g")
                .attr("class", "legend-axis")
                .attr("transform", "translate(20,0)")
                .call(legendAxis);

            // Apply style to axis ticks to make them white
            axis.selectAll("text").style("fill", "white").style("font-size", "13px")
            axis.selectAll("line").style("stroke", "white");


            // Remove the domain path
            axis.select(".domain").remove();

            document.getElementById("loadingOverlay").style.display = "none";
        }

        function calculateAverageExpressions(dataArray) {
            // Create an object to store the sum and count for each gene
            var geneSumCount = {};

            // Iterate through each gene object in the array
            dataArray.forEach(function (geneData) {
                var gene = geneData.gene;

                // Iterate through each property (sample) in the gene object
                for (var sample in geneData) {
                    if (sample !== 'gene') {
                        // If the gene is not in the sumCount object, initialize it
                        if (!geneSumCount[gene]) {
                            geneSumCount[gene] = { sum: 0, count: 0 };
                        }

                        // Add the expression value to the sum and increment the count
                        geneSumCount[gene].sum += parseFloat(geneData[sample]);
                        geneSumCount[gene].count++;
                    }
                }
            });

            // Calculate the average for each gene
            var averageExpressions = {};
            for (var gene in geneSumCount) {
                averageExpressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
            }

            return averageExpressions;
        }

        function calculateAverageLog10Expressions(dataArray) {
            // Create an object to store the sum and count for each gene
            var geneSumCount = {};

            // Iterate through each gene object in the array
            dataArray.forEach(function (geneData) {
                var gene = geneData.gene;

                // Iterate through each property (sample) in the gene object
                for (var sample in geneData) {
                    if (sample !== 'gene') {
                        // If the gene is not in the sumCount object, initialize it
                        if (!geneSumCount[gene]) {
                            geneSumCount[gene] = { sum: 0, count: 0 };
                        }

                        // Apply Math.log10 to the expression value before summing
                        var log10Expression = Math.log10(parseFloat(geneData[sample]) + 1);

                        // Add the log10 expression value to the sum and increment the count
                        geneSumCount[gene].sum += log10Expression;
                        geneSumCount[gene].count++;
                    }
                }
            });

            // Calculate the average log10 expression for each gene
            var averageLog10Expressions = {};
            for (var gene in geneSumCount) {
                averageLog10Expressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
            }

            return averageLog10Expressions;
        }

        // Function to handle checkbox change event
        function handleCheckboxChange() {
            var checkbox = document.getElementById("vehicle1");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Age at Diagnosis');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Age at Diagnosis');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeGender() {
            var checkbox = document.getElementById("vehicle3");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Gender');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Gender');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeCigarettes() {
            var checkbox = document.getElementById("vehicle2");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Smoking Status');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Smoking Status');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeStage() {
            var checkbox = document.getElementById("vehicle4");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Stage');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Stage');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeType() {
            var checkbox = document.getElementById("vehicle5");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('type');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('type');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Attach event listener to the checkbox
        document.getElementById("vehicle1").addEventListener("change", handleCheckboxChange);
        document.getElementById("vehicle3").addEventListener("change", handleCheckboxChangeGender);
        document.getElementById("vehicle2").addEventListener("change", handleCheckboxChangeCigarettes);
        document.getElementById("vehicle4").addEventListener("change", handleCheckboxChangeStage);
        document.getElementById("vehicle5").addEventListener("change", handleCheckboxChangeType);

        var radioContainer = document.getElementById("radiobox");

        radioContainer.addEventListener("click", function (event) {
            var selectedRadio = event.target;
            var radioInput = selectedRadio.querySelector('input[type="radio"]');

            //console.log("value = ", radioInput.value)
            if (radioInput && radioInput.type === "radio") {
                console.log(radioInput.value);

                selectedVariable = radioInput.value;

                console.log("Geneselected order in radio:", selectedGeneData);
                console.log("Metadata order in radio:", first_dims);
                console.log("Total order in radio:", ordering);

                updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
            }
        });

        function updateStatisticalMethod(method) {
            document.getElementById('currentMethod').innerHTML = `Method<br>${method}`;
        }

        function updateChosenAnalysis() {
            document.getElementById('currentAnalysis').innerHTML = `${chosen_meta1}<br>vs.<br>${chosen_meta2}`;
            document.getElementById('currentAnalysis').style.lineHeight = '1'; // Reduce line height to decrease vertical spacing
        }

        function updateUpandDown() {
            const regulationElement = document.getElementById("geneRegulationInfo");
            // Initialize counters
            let upregulatedCount = 0;
            let downregulatedCount = 0;

            // Create a map for quick lookup of logFC based on gene names
            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                map[gene.Gene] = gene.logFC;
                return map;
            }, {});

            // Sort old_p_adj by pval_adj (lowest first)
            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

            // Prepare data for DataTables
            const geneData = sortedOldPAdj.map(gene => {
                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : ""; // Handle cases where logFC is missing
                return {
                    Gene: gene.Gene,
                    AdjPVal: gene.pval_adj,
                    LogFC: logFC
                };
            });

            // Count upregulated and downregulated genes
            geneData.forEach(gene => {
                if (gene.AdjPVal < threshold) {
                    if (gene.LogFC >= 0) {
                        upregulatedCount++;
                    } else if (gene.LogFC <= 0) {
                        downregulatedCount++;
                    }
                }
            });

            // Update the element with line breaks for separate rows
            regulationElement.innerHTML = `Upregulated: ${upregulatedCount}<br>Downregulated: ${downregulatedCount}`;
        }


        function updateCounter() {
            // Select the counter div
            var counterDiv = d3.select("#counter");
            var counterDiv1 = d3.select("#counter1");
            console.log(data_copy.length)
            console.log(data_copy_pval.length)
            if (data_copy_pval.length > data_copy.length) {
                // Update the content of the counter and apply margin-left to text
                counterDiv.html(
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Total number of genes:</span>" +
                    "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_original.length + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by IQR:</span>" +
                    "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy1.length + " (" + ((data_copy1.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by FC:</span>" +
                    "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold;margin-left: 15px;'>" + data_copy.length + " (" + ((data_copy.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by p-val:</span>" +
                    "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold;margin-left: 15px;'>" + data_copy.length + " (" + ((data_copy.length / data_original.length) * 100).toFixed(1) + "%)" + "</span>"
                );
            }
            else {

                counterDiv.html(
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Total number of genes:</span>" +
                    "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_original.length + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by IQR:</span>" +
                    "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy1.length + " (" + ((data_copy1.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by FC:</span>" +
                    "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy.length + " (" + ((data_copy.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by p-val:</span>" +
                    "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy_pval.length + " (" + ((data_copy_pval.length / data_original.length) * 100).toFixed(1) + "%)" + "</span>"
                );

            }

            // Update the content of the counter and apply margin-left to text
            counterDiv.html(
                "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Total number of genes:</span>" +
                "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_original.length + "</span><br>" +
                "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by IQR:</span>" +
                "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy1.length + " (" + ((data_copy1.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by FC:</span>" +
                "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy.length + " (" + ((data_copy.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by p-val:</span>" +
                "<span style='display: inline-block; width: 110px; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy_pval.length + " (" + ((data_copy_pval.length / data_original.length) * 100).toFixed(1) + "%)" + "</span>"
            );

            if (chosen_statistic != "deseq2") {
                counterDiv1.html(
                    "<span style='display: inline-block; width: 175px; margin-left: 10px; font-weight: bold;'>Parameters:</span>" +
                    "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'> </span><br>" +
                    "<span style='display: inline-block; width: 175px; margin-left: 10px; font-weight: bold;'>IQR threshold:</span>" +
                    "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'>" + thr_prc.toFixed(3) + "</span><br>" +
                    "<span style='display: inline-block; width: 175px; margin-left: 10px; font-weight: bold;'>Log FC threshold:</span>" +
                    "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'>" + log_thr_fc.toFixed(3) + "</span><br>" +
                    "<span style='display: inline-block; width: 175px; margin-left: 10px; font-weight: bold;'>Significance level:</span>" +
                    "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'>" + threshold + "</span>"
                );
            } else {
                counterDiv1.html(
                    "<span style='display: inline-block; width: 175px; margin-left: 10px; font-weight: bold;'>Parameters:</span>" +
                    "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'> </span><br>" +
                    "<span style='display: inline-block; width: 175px; margin-left: 10px; font-weight: bold;'>Log FC threshold:</span>" +
                    "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'>" + log_thr_fc.toFixed(3) + "</span><br>" +
                    "<span style='display: inline-block; width: 175px; margin-left: 10px; font-weight: bold;'>Significance level:</span>" +
                    "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'>" + threshold + "</span>"
                );

            }

        }

        document.getElementById("exportGenesButton").addEventListener("click", exportGenes);
        let diffExpressedTable; // Declare the DataTable reference globally
        let selectedGenesTable; // Declare the DataTable reference globally
        let selectedGSMTable;
        function exportGenes() {
            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                map[gene.Gene] = gene.logFC;
                return map;
            }, {});

            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

            // Prepare data for Differential Expressed Genes
            const geneData = sortedOldPAdj.map(gene => {
                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                return {
                    Gene: gene.Gene,
                    AdjPVal: gene.pval_adj,
                    LogFC: logFC
                };
            });

            // Initialize the DataTable for Differential Expressed Genes
            initializeDiffExpressedTable(geneData);

            // Add checkbox event listener
            document.getElementById("includePCA").addEventListener("change", function () {
                diffExpressedTable.clear().destroy();
                $('#diffExpressedTable' + " tbody").empty();
                $('#diffExpressedTable' + " thead").empty();

                const includePCA = this.checked;
                updateDiffExpressedTable(includePCA, geneData);
            });

            // Function to initialize the DataTable
            function initializeDiffExpressedTable(data) {
                diffExpressedTable = $('#diffExpressedTable').DataTable({
                    data: data,
                    columns: [
                        { title: "Gene", data: "Gene" },
                        { title: "AdjPVal", data: "AdjPVal" },
                        { title: "LogFC", data: "LogFC" }
                    ],
                    destroy: true,
                    paging: true,
                    pageLength: 5,
                    ordering: true,
                    searching: false,
                    lengthChange: false
                });
            }

            // Function to update the Differential Expressed Genes table
            function updateDiffExpressedTable(includePCA, data) {
                // Prepare data for Differential Expressed Genes
                var updatedData = data.map(gene => {
                    const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                    const pc1Contribution = includePCA ? getPC1Contribution(gene.Gene) : ""; // Get PC1 Contribution if checkbox is checked

                    const entry = {
                        Gene: gene.Gene,
                        AdjPVal: gene.AdjPVal,
                        LogFC: logFC
                    };

                    // Add PC1 Contribution only if PCA is included
                    if (includePCA) {
                        entry.PC1_Contribution = pc1Contribution;
                    }

                    return entry;
                });

                // Destroy the existing DataTable if it exists
                if ($.fn.DataTable.isDataTable('#diffExpressedTable')) {
                    $('#diffExpressedTable').DataTable().clear().destroy();
                    $('#diffExpressedTable' + " tbody").empty();
                    $('#diffExpressedTable' + " thead").empty();
                }

                // Define columns based on whether PCA is included
                const columns = [
                    { title: "Gene", data: "Gene" },
                    { title: "AdjPVal", data: "AdjPVal" },
                    { title: "LogFC", data: "LogFC" }
                ];

                if (includePCA) {
                    columns.push({ title: "PC1 Contribution", data: "PC1_Contribution" }); // Add column for PC1 Contribution
                }

                console.log(updatedData)
                // $('#tblRemittanceList tbody').empty();
                // Initialize the DataTable with the updated data and columns
                diffExpressedTable = $('#diffExpressedTable').DataTable({
                    data: updatedData,
                    columns: columns,
                    paging: true,
                    pageLength: 5,
                    ordering: true,
                    searching: false,
                    lengthChange: false
                });
            }

            // Function to get PC1 Contribution for a given gene
            function getPC1Contribution(gene) {
                const geneDataEntry = heatmap_data.find(entry => entry.gene === gene);
                return geneDataEntry ? geneDataEntry.pc1 : ""; // Return PC1 value or empty string if not found
            }

            // Prepare data for Selected Genes
            const selectedGenesData = geneData.filter(gene => selectedGeneData.includes(gene.Gene)).map(gene => {
                return {
                    Gene: gene.Gene,
                    AdjPVal: gene.AdjPVal,
                    LogFC: gene.LogFC
                };
            });

            // Add checkbox event listener for Selected Genes
            document.getElementById("includePCA2").addEventListener("change", function () {
                selectedGenesTable.clear().destroy();
                $('#selectedGenesTable' + " tbody").empty();
                $('#selectedGenesTable' + " thead").empty();

                const includePCA = this.checked;
                updateSelectedGenesTable(includePCA, geneData); // Call update for selected genes
            });


            // Initialize DataTable for Selected Genes
            initializeSelectedGenesTable(selectedGenesData);


            // Function to initialize the DataTable for Selected Genes
            function initializeSelectedGenesTable(data) {
                selectedGenesTable = $('#selectedGenesTable').DataTable({
                    data: data,
                    columns: [
                        { title: "Gene", data: "Gene" },
                        { title: "AdjPVal", data: "AdjPVal" },
                        { title: "LogFC", data: "LogFC" }
                    ],
                    destroy: true,
                    paging: true,
                    pageLength: 5,
                    ordering: true,
                    searching: false,
                    lengthChange: false
                });
            }

            // Function to update the Selected Genes table
            function updateSelectedGenesTable(includePCA, data) {
                // Prepare data for Selected Genes
                const updatedData = data.filter(gene => selectedGeneData.includes(gene.Gene)).map(gene => {
                    const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                    const pc1Contribution = includePCA ? getPC1Contribution(gene.Gene) : ""; // Get PC1 Contribution if checkbox is checked

                    return {
                        Gene: gene.Gene,
                        AdjPVal: gene.AdjPVal,
                        LogFC: logFC,
                        PC1_Contribution: pc1Contribution // Include PC1 Contribution if checkbox is checked
                    };
                });

                // Destroy the existing DataTable if it exists
                if ($.fn.DataTable.isDataTable('#selectedGenesTable')) {
                    $('#selectedGenesTable').DataTable().clear().destroy();
                    $('#selectedGenesTable' + " tbody").empty();
                    $('#selectedGenesTable' + " thead").empty();
                }

                // Define columns for Selected Genes based on whether PCA is included
                const columns = [
                    { title: "Gene", data: "Gene" },
                    { title: "AdjPVal", data: "AdjPVal" },
                    { title: "LogFC", data: "LogFC" }
                ];

                if (includePCA) {
                    columns.push({ title: "PC1 Contribution", data: "PC1_Contribution" }); // Add column for PC1 Contribution
                }

                // Initialize the DataTable with the updated data and columns
                selectedGenesTable = $('#selectedGenesTable').DataTable({
                    data: updatedData,
                    columns: columns,
                    paging: true,
                    pageLength: 5,
                    ordering: true,
                    searching: false,
                    lengthChange: false
                });
            }
            console.log(data_original)
            console.log(gsmList)

            // Prepare data for Selected GSM Genes from original data
            const selectedGSMData = {};

            // Collect GSM values for each gene in gsmList
            data_original.forEach(entry => {
                // Check if the gene is in the selectedGeneData
                if (selectedGeneData.includes(entry.gene)) {
                    // Initialize the gene entry if it doesn't exist
                    if (!selectedGSMData[entry.gene]) {
                        selectedGSMData[entry.gene] = {};
                    }

                    // Iterate over the keys of entry to collect GSM values
                    for (const gsm in entry) {
                        if (gsmList.includes(gsm)) {
                            // If the GSM is in gsmList, store the GSM key with its corresponding value
                            selectedGSMData[entry.gene][gsm] = entry[gsm]; // Use the GSM key and its value from entry
                        }
                    }
                }
            });
            console.log(selectedGSMData)

            // Format data for the selectedGSMTable
            const selectedGSMTableData = Object.entries(selectedGSMData).map(([gene, gsms]) => {
                const geneObject = { Gene: gene };

                // Assign the GSM values to keys based on the actual GSM values in gsmList
                gsmList.forEach((gsm) => {
                    // Check if the current GSM is in the list for the gene
                    geneObject[gsm] = gsms[gsm] !== undefined ? gsms[gsm] : ""; // If the GSM is included, use the value; otherwise, leave it blank
                });

                return geneObject;
            });

            console.log(selectedGSMTableData)
            $('#selectedGSMTable').html(''); // Set message
            $('#selectedGSMTable').DataTable().destroy(); // Destroy any existing instance
            let ok_gsm = false
            // Check if gsmList is empty
            if (gsmList.length === 0) {
                ok_gsm = false
                // Display message instead of table
                $('#selectedGSMTable').html('<tr><td colspan="100%" style="text-align: center;">No sample selected</td></tr>'); // Set message
            } else {
                // Initialize DataTable for Selected GSM Genes
                ok_gsm = true
                selectedGSMTable = $('#selectedGSMTable').DataTable({
                    data: selectedGSMTableData,
                    columns: [
                        { title: "Gene", data: "Gene" },
                        ...gsmList.map(gsm => ({ title: gsm, data: gsm })) // Use the actual GSM values as column titles and data keys
                    ],
                    paging: true,
                    pageLength: 5,
                    ordering: true,
                    searching: false,
                    lengthChange: false
                });
            }


            // Show the overlay
            document.getElementById("geneOverlay").style.display = "block";

            // Show the download button
            document.getElementById("confirmDownloadButton").style.display = "block";

            // Set up the download button action
            document.getElementById("confirmDownloadButton").onclick = function () {
                const activeTab = document.querySelector('.tabcontent[style*="display: block"]');
                const activeTable = activeTab.id === "diffExpressedGenes" ? diffExpressedTable :
                    (activeTab.id === "selectedGenes" ? selectedGenesTable : selectedGSMTable);

                downloadCSV(activeTable);
            };




            // Close button functionality
            document.getElementById("closeOverlayButton").onclick = function () {
                $('#selectedGSMTable').DataTable().destroy(); // Destroy any existing instance
                $('#selectedGSMTable' + " tbody").empty();
                $('#selectedGSMTable' + " thead").empty();

                $('#selectedGenesTable').DataTable().destroy(); // Destroy any existing instance
                $('#selectedGenesTable' + " tbody").empty();
                $('#selectedGenesTable' + " thead").empty();

                $('#diffExpressedTable').DataTable().destroy(); // Destroy any existing instance
                $('#diffExpressedTable' + " tbody").empty();
                $('#diffExpressedTable' + " thead").empty();

                document.getElementById("includePCA").checked = false;
                document.getElementById("includePCA2").checked = false;

                document.getElementById("geneOverlay").style.display = "none";
            };

            // Handle tab switching
            document.getElementById("diffExpressedTab").addEventListener("click", function () {
                switchTab("diffExpressedGenes", "selectedGenes", "selectedGSM");
            });

            document.getElementById("selectedGenesTab").addEventListener("click", function () {
                switchTab("selectedGenes", "diffExpressedGenes", "selectedGSM");
            });

            document.getElementById("selectedGSMTab").addEventListener("click", function () {
                switchTab("selectedGSM", "diffExpressedGenes", "selectedGenes");
            });

            function switchTab(showId, hideId1, hideId2) {
                document.getElementById(showId).style.display = "block";
                document.getElementById(hideId1).style.display = "none";
                document.getElementById(hideId2).style.display = "none";
                document.querySelectorAll('.tablinks').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`${showId === 'diffExpressedGenes' ? 'diffExpressedTab' : (showId === 'selectedGenes' ? 'selectedGenesTab' : 'selectedGSMTab')}`).classList.add('active');
                const activeTab = document.querySelector('.tabcontent[style*="display: block"]');
                const activeTable = activeTab.id === "diffExpressedGenes" ? diffExpressedTable :
                    (activeTab.id === "selectedGenes" ? selectedGenesTable : selectedGSMTable);

                console.log(activeTab.id)
                if (!ok_gsm && activeTable === selectedGSMTable) {
                    document.getElementById("confirmDownloadButton").style.cursor = "not-allowed"
                    document.getElementById("confirmDownloadButton").style.opacity = 0.6
                    document.getElementById("confirmDownloadButton").disabled = true
                }
                else {
                    document.getElementById("confirmDownloadButton").style.cursor = "pointer"
                    document.getElementById("confirmDownloadButton").style.opacity = 1
                    document.getElementById("confirmDownloadButton").disabled = false
                }

            }
        }

        function downloadCSV(geneTable) {
            // Get data from the DataTable in the current order
            const data = geneTable.rows({ order: 'current' }).data().toArray();

            // Initialize the headers for CSV
            let headers = ["Gene", "AdjPVal", "LogFC"]; // Base headers

            // Check if the checkbox for PCA is checked
            if (document.getElementById("includePCA").checked || document.getElementById("includePCA2").checked) {
                headers.push("PC1_Contribution"); // Add header for PC1_Contribution
            }

            // Collect GSM columns dynamically
            const gsmColumns = Object.keys(data[0]).filter(key => key !== "Gene" && key !== "AdjPVal" && key !== "LogFC" && key !== "PC1_Contribution");
            if (gsmColumns.length >= 1) headers = ["Gene"].concat(gsmColumns); // Add GSM columns to the headers

            // Create CSV content with the specified headers
            const csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n" +
                data.map(gene => {
                    // Start building the row with the basic fields
                    let row = [
                        gene.Gene,
                        gene.AdjPVal,
                        gene.LogFC
                    ];

                    if (gsmColumns.length >= 1) {
                        row = [gene.Gene]
                    }

                    // Include PC1_Contribution if applicable
                    if (document.getElementById("includePCA").checked || document.getElementById("includePCA2").checked) {
                        row.push(gene.PC1_Contribution !== undefined ? gene.PC1_Contribution : ""); // Add PC1_Contribution
                    }

                    // Append GSM values dynamically
                    gsmColumns.forEach(gsm => {
                        row.push(gene[gsm] !== undefined ? gene[gsm] : ""); // Add GSM values or empty string if undefined
                    });

                    return row.join(","); // Join the row values with commas
                }).join("\n");

            // Create a link element for downloading the CSV
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "genes.csv");

            // Append the link to the document body and click it programmatically to initiate download
            document.body.appendChild(link);
            link.click();

            // Clean up by removing the link from the document
            document.body.removeChild(link);

            // Close the overlay after download
            document.getElementById("geneOverlay").style.display = "none";
            $('#selectedGSMTable').DataTable().destroy(); // Destroy any existing instance
            $('#selectedGSMTable' + " tbody").empty();
            $('#selectedGSMTable' + " thead").empty();

            $('#selectedGenesTable').DataTable().destroy(); // Destroy any existing instance
            $('#selectedGenesTable' + " tbody").empty();
            $('#selectedGenesTable' + " thead").empty();

            $('#diffExpressedTable').DataTable().destroy(); // Destroy any existing instance
            $('#diffExpressedTable' + " tbody").empty();
            $('#diffExpressedTable' + " thead").empty();

        }


        document.getElementById("importDatasetButton").addEventListener("click", showLoadCsvOverlayMod);

        // Function to show the CSV file loading overlay
        function showLoadCsvOverlayMod() {
            event.stopPropagation();
            second_time = true
            document.getElementById("loadDatasetOverlay").style.display = "block";

            document.getElementById("backBtn").addEventListener("click", function (event) {
                hideLoadCsvOverlay();
                event.stopPropagation();

            })

            // Add event listener to detect clicks outside of the overlay
            document.body.addEventListener("click", hideLoadCsvOverlayOnClickOutside);
        }

        // Function to hide the CSV file loading overlay
        function hideLoadCsvOverlay() {
            document.getElementById("loadDatasetOverlay").style.display = "none";
            document.getElementById("overlay").style.display = "none";

            // Remove the click event listener from the body
            document.body.removeEventListener("click", hideLoadCsvOverlayOnClickOutside);
        }

        // Function to hide the overlay when clicking outside of it
        function hideLoadCsvOverlayOnClickOutside(event) {
            var loadDatasetOverlay = document.getElementById("containeDatasetOverlay");
            // Check if the click target is outside of the overlay
            if (!loadDatasetOverlay.contains(event.target)) {
                hideLoadCsvOverlay();
            }
        }

        // Function to filter and display search results
        function filterAndDisplayResults() {
            const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
            const searchResults = document.getElementById('searchResults');

            // Clear existing results before updating
            searchResults.innerHTML = '';

            if (searchTerm.length === 0) {
                searchResults.style.display = 'none';
                return;
            }

            console.log(data_copy_pval)
            console.log(old_p_adj)
            const matches = old_p_adj.filter(item => {
                // Filter logic based on your data structure
                // Assuming data_copy_pval is an array of objects with 'gene' property
                return item.Gene.toLowerCase().includes(searchTerm) && item.pval_adj < threshold;
            });

            // Display the matches in the results container
            for (let i = 0; i < matches.length && i < 5; i++) {
                const resultElement = document.createElement('a');
                resultElement.id = `result${i + 1}`;
                resultElement.classList.add('result-item');
                resultElement.textContent = matches[i].Gene;

                // Handle click on result to select it
                resultElement.addEventListener('click', (function (gene) {
                    return function (event) {
                        event.stopPropagation(); // Stop propagation to prevent other results from triggering

                        document.getElementById('searchInput').value = gene;

                        // Check if the gene is already in selectedGeneData
                        if (!selectedGeneData.includes(gene)) {
                            selectedGeneData.push(gene);

                            // Add selected Gene to boxplot dropdown menu 
                            // Get the select element
                            var select = document.getElementById("selectButton");

                            // Add new options for the genes in selectedGeneData that are not already in the select element
                            selectedGeneData.forEach(function (gene) {
                                if (!Array.from(select.options).some(option => option.value === gene)) {
                                    var option = document.createElement("option");
                                    option.value = gene;
                                    option.text = gene;
                                    select.appendChild(option);
                                }
                            });

                            dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims);
                            updateBoxPlot(last_box, parsedLogFC, dataN_copy, dataC_copy);
                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj);
                            } else {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj);
                            }
                        }
                        searchResults.style.display = 'none'; // Hide results after selection
                    };
                })(matches[i].Gene)); // Immediately invoked function to capture current gene value

                searchResults.appendChild(resultElement); // Append each result to the results container
            }

            // Show the results container if there are matches
            if (matches.length > 0) {
                searchResults.style.display = 'block';
            } else {
                searchResults.style.display = 'none';
            }
        }

        // Handle input in search input
        document.getElementById('searchInput').addEventListener('input', function () {
            filterAndDisplayResults();
        });

        // Handle focus on search input to show results
        document.getElementById('searchInput').addEventListener('focus', function () {
            filterAndDisplayResults();
        });

        // Handle blur on search input to hide results
        document.getElementById('searchInput').addEventListener('blur', function () {
            const searchResults = document.getElementById('searchResults');
            const relatedTarget = document.activeElement;

            if (!searchResults.contains(relatedTarget)) {
                searchResults.style.display = 'none';
            }
        });

        // Handle click inside search results container to prevent hiding
        document.getElementById('searchResults').addEventListener('mousedown', function (event) {
            event.preventDefault(); // Prevents focus change which would trigger blur
        });


    </script>

    <div id="tooltip"
        style="position: absolute; opacity: 0; background-color: white; border: 1px solid #ddd; padding: 5px;">
    </div>
    <div id="tTestResults"></div>

</body>

</html>