<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GEVIS - Gene Expression VIS</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <script src="d3.v7.8.5.min.js"></script>
    <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
    <script src="//cdn.opencpu.org/opencpu-0.4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/7.0.0/simple-statistics.min.js"></script>
    <script src='https://cdn.jsdelivr.net/gh/kdpsingh/rjs@master/r.js'></script>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js"
        integrity="sha512-5mCB0Kvv97yTzqo0174qxPjMisck/WlK51+mw/RV7UfYbtHI8LuLR82BzZuxHUKSfbh75u9cZHgUcqrZDaBJuA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js"
        integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
        crossorigin="anonymous"></script>

    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <script src="css/bootstrap.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-color/3.0.0/d3-color.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-interpolate/1.5.0/d3-interpolate.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-scale/3.2.2/d3-scale.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-scale-chromatic/1.6.0/d3-scale-chromatic.min.js"></script>
    <link rel="stylesheet" href="https://cdn.datatables.net/2.0.7/css/dataTables.dataTables.css" />
    <script src="https://cdn.datatables.net/2.0.7/js/dataTables.js"></script>

    <style>
        /*------ Style 1 ------*/
        #style1 {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 50px;
            height: 30px;
            background-color: transparent;
            border: none;
            cursor: pointer;
        }

        #style1::-webkit-color-swatch {
            border-radius: 5px;
            border: none;
        }

        #style1::-moz-color-swatch {
            border-radius: 5px;
            border: none;
        }

        /* Additional styles to adjust layout */
        .color-input-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
        }

        .input-wrapper {
            margin-left: 10px;
            /* Adjust the margin to fine-tune the distance */
        }

        .value-span {
            flex: 1;
            text-align: center;
            /* Center the text */
        }

        .color-input-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0px 24px;
            gap: 0px;
            /* Adjust gap to bring elements closer */
        }

        .input-wrapper {
            display: inline-block;
            margin-right: 70px;
        }

        .value-span {
            margin-right: 10px;
            /* Optional: Adjust right margin to bring it closer to the input */
        }

        .category-container {
            margin-bottom: 10px;
            /* Add some space between category containers */
        }

        .value-span {
            display: inline-block;
            text-align: left;
            /* Center the unique value */
            margin-left: 40px;
            /* Add some space between the value and the color input */
        }

        .highlight {
            background-color: rgba(var(--dt-row-hover), 0.052) !important;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            /* Change to fixed for better centering */
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            position: absolute;
            /* Change to absolute */
            left: 50%;
            /* Move content to the horizontal center */
            top: 50%;
            /* Move content to the vertical center */
            transform: translate(-50%, -50%);
            /* Adjust to center the content */
            background-color: #0e0d0d;
            padding: 20px;
            border: 1px solid #888;
            width: auto;
            /* Adjust width based on content */
            height: auto;
        }


        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            width: 28px;

        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .axis-label {
            cursor: pointer;
            /* Cursor style when hovering over the axis label */
        }

        .dragging {
            cursor: move;
            /* Cursor style during dragging */
        }


        #thresholdSlider {
            width: 5%;
        }

        .flex {
            display: flex;
            flex-direction: row;
            max-width: space-between;
            height: 100%;
            width: 100%
        }

        .flex1 {
            display: flex;
            flex-direction: row;
            max-width: space-between;
            height: auto;
            width: 50%;

        }

        .flex-container {
            display: flex;
            flex-direction: column;
            max-width: fit-content;

        }

        .flex-container>div {
            margin-right: 3.2px;
            /* Add spacing between items */
        }


        body {
            background-color: black;
            margin: 0;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }

        #style_scatter {
            border: 2px solid #ddd;
            /* Border color */
            /* Border radius for rounded corners */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            /* Shadow effect */
            background-color: rgb(33, 33, 33);
        }


        input.range1 {
            --c: grey;
            /* active color */
            --l: 8px;
            /* line thickness */
            --h: 30px;
            /* thumb height */
            --w: 10px;
            /* thumb width */

            width: 400px;
            height: var(--h);
            /* needed for Firefox */
            --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
            cursor: pointer;
            overflow: hidden;
        }

        input.range1:focus-visible,
        input.range1:hover {
            --p: 25%;
        }

        /* chromium */
        input.range1[type="range" i]::-webkit-slider-thumb {
            height: var(--h);
            width: var(--w);
            background: var(--_c);
            border-image: linear-gradient(90deg, var(--_c) 50%, orange 0) 0 1/calc(50% - var(--l)/2) 100vw/0 100vw;
            -webkit-appearance: none;
            appearance: none;
            transition: .3s;
        }

        /* Second range slider with a different color scheme */
        input.range2 {
            --c: grey;
            /* active color */
            --l: 8px;
            /* line thickness */
            --h: 30px;
            /* thumb height */
            --w: 10px;
            /* thumb width */

            width: 400px;
            height: var(--h);
            /* needed for Firefox */
            --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
            cursor: pointer;
            overflow: hidden;
        }

        input.range2:focus-visible,
        input.range2:hover {
            --p: 25%;
        }

        /* chromium */
        input.range2[type="range" i]::-webkit-slider-thumb {
            height: var(--h);
            width: var(--w);
            background: var(--_c);
            border-image: linear-gradient(90deg, var(--_c) 50%, darkgreen 0) 0 1/calc(50% - var(--l)/2) 100vw/0 100vw;
            -webkit-appearance: none;
            appearance: none;
            transition: .3s;
        }

        @supports not (color: color-mix(in srgb, red, red)) {
            input {
                --_c: var(--c);
            }
        }

        @keyframes pulseAnimation {
            0% {
                fill: green;
                r: 2;
            }

            50% {
                fill: lime;
                /* Color during the pulse */
                r: 4
            }

            100% {
                fill: green;
                r: 2
            }
        }

        .pulse {
            animation: pulseAnimation 1s infinite;
            /* You can adjust the duration as needed */
        }

        @keyframes pulseAnimation1 {
            0% {

                r: 2;
            }

            50% {

                r: 4
            }

            100% {

                r: 2
            }
        }

        .pulse1 {
            animation: pulseAnimation1 1s infinite;
            /* You can adjust the duration as needed */
        }

        @keyframes pulseRedAnimation {
            0% {
                stroke: aqua;
                /* Initial color */
                stroke-width: 2;
                /* Initial stroke width */
            }

            50% {
                stroke: rgb(198, 255, 255);
                /* Color during the pulse */
                stroke-width: 3;
                /* Increased stroke width during the pulse */
            }

            100% {
                stroke: aqua;
                /* Back to initial color */
                stroke-width: 2;
                /* Back to initial stroke width */
            }
        }

        .pulse-red {
            animation: pulseRedAnimation 1s infinite;
            /* Adjust duration as needed */
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            /* Semi-transparent black background */
            z-index: 9999;
            /* Ensure the overlay appears above other elements */
            display: block;
            /* Initially hidden */
        }

        /* You can customize the loading indicator style here */
        #loadingIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            /* Add more styles as needed */
        }

        #radioBoxContainer::-webkit-scrollbar-track {
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            background-color: #F5F5F5;
        }

        #radioBoxContainer::-webkit-scrollbar {
            width: 8px;
            background-color: #F5F5F5;
        }

        #radioBoxContainer::-webkit-scrollbar-thumb {
            border-radius: 10px;
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            background-color: #6c757d;
        }

        #checkboxContainer::-webkit-scrollbar-track {
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            background-color: #F5F5F5;
        }

        #checkboxContainer::-webkit-scrollbar {
            width: 8px;
            background-color: #F5F5F5;
        }

        #checkboxContainer::-webkit-scrollbar-thumb {
            border-radius: 10px;
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            background-color: #6c757d;
        }

        .category-label-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0px 24px;
            /* Adjust padding to control spacing */
            gap: 0px;
            position: relative;
            /* Ensure relative positioning for absolute button placement */
        }

        .resort-button {
            margin-right: 16px;
            /* Move the button 16px to the left */
        }

        .dropdown-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            /* Space between each category block */
        }

        .radio-label {
            flex-shrink: 0;
            margin-right: 20px;
            /* Space between the label and the dropdowns */
        }

        .dropdowns-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }

        .dropdowns-container select {
            margin: 0 5px;
        }

        .vs-text {
            margin: 0 10px;
        }

        /* Additional styles for dropdowns if needed */
        select[name="dropdown1"],
        select[name="dropdown2"] {
            min-width: 150px;
            /* Ensure dropdowns have a minimum width */
        }

        #controlPanel {
            display: flex;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        .search-container {
            display: flex;
            align-items: center;
            margin-left: 10px;
            position: relative;
        }

        #searchInput {
            width: 150px;
        }

        #searchButton {
            margin-left: 10px;
        }

        #searchResultsDropdown {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ccc;
            max-height: 200px;
            display: none;

            overflow-y: auto;
            z-index: 2;
        }

        .result-item {
            cursor: pointer;
            /* Change cursor to pointer */
            background-color: white;
            transition: background-color 0.3s ease;
            /* Smooth transition effect */
            /* padding: 5px; Optional: Add padding for better appearance */
            display: block;
            /* Ensures the element behaves like a block-level element */
            text-decoration: none;
            /* Remove underline for links if any */
            color: black;
            /* Set text color */
            margin-bottom: 5px;
            /* Add margin for spacing between items */
        }

        .result-item:hover {
            background-color: grey;
            /* Change background color on hover */
        }
    </style>
</head>

<body>
    <div id="overlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; display: none;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 5px;">
            <h2>Do you want to load your dataset or try example?</h2>
            <button id="loadDatasetBtn">Load Dataset</button>
            <button id="tryExampleBtn">Try Example</button>
        </div>
    </div>
    <div id="loadDatasetOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1001; display: none;">
        <div id="containeDatasetOverlay"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 5px;">
            <h2>Load raw RNA-Seq CSV files
                <br>
                File 1: Expression Data, File 2: Metadata
            </h2>
            <input type="file" id="fileInput1">
            <input type="file" id="fileInput2">
            <button id="loadCsvBtn">Load Dataset</button>
        </div>
    </div>

    <div id="displayCsvOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1002; display: none;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 5px;">
            <h2>CSV Data (First 5 columns)</h2>
            <div style="display: flex;">
                <table id="csvTableData1" class="display" style="flex: 1; margin-right: 20px;"></table>
                <table id="csvTableData2" class="display" style="flex: 1;"></table>
            </div>
            <div style="clear: both;"></div> <!-- Clear float -->
            <p>Total Columns File 1: <span id="totalColumns1"></span></p>
            <p>Total Columns File 2: <span id="totalColumns2"></span></p>
            <button id="selectMetadataBtn">Select Metadata Rows</button>
        </div>
    </div>


    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="#" style="color:white">GEVis - GeneExpressionVIS</a>
        <button class="btn btn-secondary" id="openModalBtn">Get Enrichment</button>
        <span style="margin-left: 10px;"></span> <!-- Adjust the margin as needed -->
        <button class="btn btn-secondary" id="exportGenesButton">Export DEGs</button>
        <span style="margin-left: 10px;"></span> <!-- Adjust the margin as needed -->
        <button class="btn btn-secondary" id="importDatasetButton">Import Dataset</button>
        <button class="btn btn-secondary" id="openModalBtn1" style="margin-left: 10px;">Survival Plot</button>


    </nav>
    <div id="loadingOverlay" style="display: flex; justify-content: center; align-items: center;">
        <div style="display: flex; justify-content: center; align-items: center; width: 100%; height: 100%;">

            <svg version="1.1" id="L1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                x="0px" y="0px" viewBox="0 0 50 50" enable-background="new 0 0 100 100" xml:space="preserve"
                style="width: 50px; height: 50px;">
                <circle fill="none" stroke="#98AFC7" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="10,10"
                    cx="25" cy="25" r="21">
                    <animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="2s"
                        from="0 25 25" to="360 25 25" repeatCount="indefinite" />
                </circle>
                <circle fill="none" stroke="#98AFC7" stroke-width="1" stroke-miterlimit="10" stroke-dasharray="10,10"
                    cx="25" cy="25" r="18">
                    <animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="2s"
                        from="0 25 25" to="-360 25 25" repeatCount="indefinite" />
                </circle>
                <g fill="#98AFC7">
                    <rect x="15" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.1" />
                    </rect>
                    <rect x="20" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.2" />
                    </rect>
                    <rect x="25" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.3" />
                    </rect>
                    <rect x="30" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.4" />
                    </rect>
                    <rect x="35" y="20" width="3" height="15">
                        <animateTransform attributeName="transform" dur="0.5s" type="translate" values="0 2 ; 0 -2; 0 2"
                            repeatCount="indefinite" begin="0.5" />
                    </rect>
                </g>
            </svg>
        </div>
    </div>

    <div class="flex"> <!-- div(1) che mette in colonna-->

        <div class="flex-container" style="margin-top : 6px; margin-left : 6px"><!--div(2) che mette in riga iqr e FC-->
            <div id="style_scatter">

                <div id="IQR" style="width: 100%"></div><!--div(4) IQR-->
                <div> <!--div(3) bottoni IQR-->
                    <input type="range" id="thresholdSlider" class="range2" min="0.1" max="0.99" step="0.01" value="0.2"
                        style="width: 200px;">
                    <span id="thresholdValue" style="color: white;">0.1</span>
                </div><!-- div(3)-->
                <div id="logFCHistogram"></div> <!-- div(5) FC-->

                <div><!-- div(6) bottoni FC-->

                    <input type="range" id="log_thresholdSlider" class="range1" min="1.1" max="10" step="0.01"
                        value="1.1" style="width: 200px;">
                    <span id="log_thresholdSliderValue" style="color: white;">1.1</span>
                    <div id="boxPlot"></div>
                    <!-- Initialize a select button -->
                    <select id="selectButton" class="btn btn-secondary dropdown-toggle">
                        <option value="SPP1" selected>MostUp</option>
                        <option value="AGER">MostdDown</option>
                    </select>

                </div><!--div(6)-->


            </div>
        </div><!--div(2)-->

        <div>
            <div class="flex-container" style="margin-top : 6px;">
                <div id="style_scatter">
                    <div id="scatterPlot" style="position: relative">
                    </div>
                    <div id="controlPanel">
                        <button id="resetButton" class="btn btn-secondary">Reset Zoom</button>
                        <button id="switchButton" class="btn btn-secondary">Switch Plot</button>
                        <label for="thresholdSelect">
                            <p style="color: #ddd;">Select Threshold:</p>
                        </label>
                        <select id="thresholdSelect" class="btn btn-secondary dropdown-toggle">
                            <option value="0.05" selected>0.05</option>
                            <option value="0.01">0.01</option>
                        </select>
                        <div class="search-container">
                            <div id="searchInputContainer" style="position: relative;">
                                <input type="text" id="searchInput" class="form-control" placeholder="Search">
                                <div id="searchResults" class="dropdown-content"
                                    style="display: none; position: absolute; top: 100%; left: 0; right: 0; z-index: 1000000; background-color: white;">
                                </div>
                            </div>
                            <!-- <button id="searchButton" class="btn btn-primary">Search</button> -->
                        </div>
                    </div>
                </div>
                <div id="style_scatter">
                    <div class="flex">
                        <div id="checkboxContainer"
                            style="overflow-y:scroll; max-height: 70px; color: white; width: 450px;margin-left: 0%; visibility: hidden;">
                            <!-- Checkboxes will be dynamically added here -->
                        </div>

                        <div id="checkbox" class="btn-group btn-group-toggle" data-toggle="buttons"
                            style="visibility: hidden; display: none;">
                            <label for="vehicle1" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle1" name="vehicle1" value="Age" checked
                                    onchange="handleCheckboxChange()">
                                Age</label>

                            <label for="vehicle2" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle2" name="vehicle2" value="Smoker"
                                    onchange="handleCheckboxChangeCigarettes()">
                                Smoker class</label>

                            <label for="vehicle3" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle3" name="vehicle3" value="Gender"
                                    onchange="handleCheckboxChangeGender()">
                                Gender</label>

                            <label for="vehicle4" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle4" name="vehicle4" value="Stage"
                                    onchange="handleCheckboxChangeStage()">
                                Stage</label>

                            <label for="vehicle5" style="color: #ddd; margin-right: 5px;">
                                <input type="checkbox" id="vehicle5" name="vehicle5" value="type"
                                    onchange="handleCheckboxChangeType()">
                                Type</label>
                        </div>
                        <div id="radioBoxContainer"
                            style="overflow-y:scroll; max-height: 70px; color: white; width: 450px;margin-left: 10%; visibility: hidden;">
                            <!-- Checkboxes will be dynamically added here -->
                        </div>

                        <div id="radiobox" class="btn-group btn-group-toggle" data-toggle="buttons"
                            style="visibility: hidden; margin-left: 10%; display: none;">

                            <label for="variable1" class="btn btn-secondary active"
                                style="color: #ddd;  margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable1" name="variable" autocomplete="off" value="case"
                                    checked>
                                Case/Normal</label>


                            <label for="variable2" class="btn btn-secondary"
                                style="color: #ddd; margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable2" name="variable" autocomplete="off" value="Smoker">
                                Smoker class</label>


                            <label for="variable3" class="btn btn-secondary"
                                style="color: #ddd; margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable3" name="variable" autocomplete="off" value="Gender">
                                Gender</label>


                            <label for="variable4" class="btn btn-secondary"
                                style="color: #ddd; margin-right: 5px; border-radius: 50px;">
                                <input type="radio" id="variable4" name="variable" autocomplete="off" value="Stage">
                                Stage</label>
                        </div>
                        <!-- Add this div for the legend -->
                    </div>
                    <div id="parallelLegend" style="margin-top: 2px; color: #ddd;"></div>
                    <div id="parallelcoordinates" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <div class="flex-container" style="margin-top : 6px;">

            <div id="style_scatter">
                <div>
                    <div id="pca"></div>
                </div>
                <div id="heatmap"></div>

            </div>

            <div id="style_scatter"
                style="display: flex; justify-content: center; align-items: center; height: 100%; width: 99.5%;">
                <div class="flex"
                    style="display: flex; justify-content: center; align-items: center; height: 100%; width: 100%;">
                    <div id="counter"
                        style="color: white; border: 0.01px solid #ddd; border-bottom: none; border-right: none; border-left: none; width: 50%; height: 100%; box-sizing: border-box; text-align: left; justify-content: space-evenly;">
                    </div>
                    <div id="counter1"
                        style="color: white; border: 0.01px solid #ddd; border-bottom: none; border-right: none; width: 50%; height: 100%; box-sizing: border-box; text-align: left; justify-content: space-evenly;">
                    </div>
                </div>
            </div>

        </div>

    </div> <!-- div(1)-->

    <!-- Modal -->
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div class="flex1">

                <div>
                    <div id="dotplot"></div>
                    <div id="slider_dot_polot"></div>
                    <div id="select_dot"></div>
                </div>

                <div>
                    <div id="dotplot1"></div>
                    <div id="slider_dot_polot1"></div>
                    <div id="select_dot1"></div>

                </div>


            </div>


        </div>
    </div>
    <div id="myModal1" class="modal">
        <div class="modal-content">
            <span class="close1">&times;</span>
            <div class="flex1">

                <div>

                    <h4 style="color: white; width: 100%;">Select clinical data for the survival analysis</h4>
                    <form id="dropdownForm">
                    </form>
                    <form id="dropdownForm1">
                    </form>
                    <button id="submission" type="button" class="btn btn-secondary" disabled>Submit</button>

                </div>

                <div>
                    <div id="survival"></div>
                </div>

            </div>


        </div>
    </div>


    </div>
    <script>

        try {
            ocpu.seturl("//localhost:8004/ocpu/lib/GEVIS/R");
        } catch (error) {
            // If an error occurs (e.g., ocpu is not defined), reload the page
            window.location.reload();
        }

        let chosen_statistic = ''

        let table1;
        let table2;

        let chosen_meta1
        let chosen_meta2
        let selectedRowName

        // This is for storing COLORS CHOSEN BY USER
        let colorScaleValues = {};

        let case_number
        let normal_number
        let genes
        let variation_data;
        let variation_data_copy;
        let initial_num_genes;
        let data_upd
        let prc_IQR = 0.2;
        let thr_prc;
        let filteredData;
        let matrix;
        let data_original = [];
        let dataC_original = [];
        let dataN_original = [];
        let data_copy = [];
        let dataC_copy = [];
        let dataN_copy = [];
        let data_copy1 = [];
        let dataC_copy1 = [];
        let dataN_copy1 = [];
        let thr_fc = 1.1;
        let logFC_data;
        let log_thr_fc = Math.log2(thr_fc);
        let parsedLogFC;
        let parsedLogFC_origin;
        let parsedLogFC_origin1;
        let newdataJSON
        let newdataCJSON
        let first_filter_number_genes;
        let p_val_adj;
        let threshold = 0.05;
        let averageExpressions10C;
        let averageExpressions10N;
        let averageExpressionsC;
        let averageExpressionsN;
        let selectedGeneData = [];
        let greencircles = []
        let old_p_adj
        let transposedData = [];
        let ordering
        let metadata;
        let combinedData = []
        let combinedData1 = []
        let gsmList = []

        var json = []
        //info box plot
        let sumstat1
        var scatter;
        let sumstat
        var geneNameUP
        var geneNameDown
        let first_box = true
        /////////
        var currentCircleFill
        var first_dims = ['Age at Diagnosis']

        // Remove entries corresponding to ind from dataN
        var dataC_copy_pval

        // Remove entries corresponding to ind from dataN
        let dataN_copy_pval


        var data_copy_pval

        // Remove entries corresponding to ind from logFC
        var parsedLogFC_pval
        var color_by = 'case'
        let pca_data = []
        let heatmap_data = []
        let square;

        let selectedVariable = "case"
        // Flag to track the current plot
        let currentPlot = 'volcano';

        showOverlay()


        // Get the modal element
        var modal = document.getElementById("myModal");

        // Get the button that opens the modal
        var btn = document.getElementById("openModalBtn");

        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];

        // Function to display loading message inside the modal
        function showLoadingMessage() {
            var dotplotContainer = document.getElementById("dotplot");
            var dotplotContainer1 = document.getElementById("dotplot1");
            var slider = document.getElementById("slider_dot_polot");
            var selector = document.getElementById("select_dot");

            var slider1 = document.getElementById("slider_dot_polot1");
            var selector1 = document.getElementById("select_dot1");
            selector.innerHTML = "";
            slider.innerHTML = "";
            selector1.innerHTML = "";
            slider1.innerHTML = "";
            dotplotContainer1.innerHTML = "";
            dotplotContainer.innerHTML = "<h3 style='color: white'>Loading data from EnrichR.. </h3>";
        }

        // Function to create the dot plot inside the modal
        function createDotPlotInsideModal() {
            // Display loading message inside the modal
            showLoadingMessage();

            // Call your function to create the dot plot here
            DEG(data_copy_pval, parsedLogFC_pval, old_p_adj);
        }


        document.getElementById("openModalBtn").addEventListener("click", function () {
            const data = { data_copy_pval, parsedLogFC_pval, old_p_adj }; // Assuming you have these arrays defined elsewhere

            // Send data to server using fetch
            fetch('/enrichment', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ data: data })
            })
                .then(response => response.json())
                .then(response => {
                    // Redirect to /enrichment with unique identifier (sessionId)
                    window.open(`/enrichment?sessionId=${response.sessionId}`, '_blank');
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Failed to store enrichment data');
                });
        });


        // When the user clicks the button, open the modal and create the dot plot inside it
        // btn.onclick = function () {
        //     modal.style.display = "block";
        //     // Display loading message inside the modal
        //     showLoadingMessage();
        //     // Call function to create dot plot inside modal
        //     createDotPlotInsideModal();
        // }

        // When the user clicks on <span> (x), close the modal
        span.onclick = function () {
            modal.style.display = "none";
            // Clear the content of the modal when it is closed
            var dotplotContainer = document.getElementById("dotplot");
            var dotplotContainer1 = document.getElementById("dotplot1");
            dotplotContainer.innerHTML = "";
            dotplotContainer1.innerHTML = "";
        }

        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function (event) {
            if (event.target == modal) {
                modal.style.display = "none";
                // Clear the content of the modal when it is closed
                var dotplotContainer = document.getElementById("dotplot");
                var dotplotContainer1 = document.getElementById("dotplot1");
                dotplotContainer.innerHTML = "";
                dotplotContainer1.innerHTML = "";
            }
        }


        ///////////////////////////////////////////////////////////////////////////////////////////

        // Get the modal element
        var modal1 = document.getElementById("myModal1");

        // Get the button that opens the modal
        var btn1 = document.getElementById("openModalBtn1");

        // Get the button that opens the modal
        var btn2 = document.getElementById("submission");

        // Get the <span> element that closes the modal
        var span1 = document.getElementsByClassName("close1")[0];

        // Function to display loading message inside the modal
        function showLoadingMessageSurv() {
            var survivalContainer = document.getElementById("survival");
            console.log(selectedGeneData)
            // Create initial radio buttons
            //createRadioButtons(selectedGeneData);


            // survivalContainer.innerHTML = "<h3 style='color: white; margin-left: 50px; width:100%'>Select a gene </h3>";
            // // Form submission handler
            // document.getElementById('submission').onclick = function(event) {
            //         event.preventDefault(); // Prevent default form submission

            //         // Get selected radio input value
            //     const selectedGene = document.querySelector('input[name="gene"]:checked');

            //     if (selectedGene) {
            //         survivalContainer.innerHTML = "<h3 style='color: white; margin-left: 50px'>Computing the plot... </h3>";
            //         // Call your function to create the dot plot here
            //         btn2.disabled = true;
            //         survival(metadata,dataC_copy_pval,selectedGene.value)

            //         // You can handle the selected gene value as needed
            //     } else {
            //         alert('No gene selected!');
            //     }

            // };

        }

        // Function to create the dot plot inside the modal
        function createSurvivalPlotInsideModal() {
            // Display loading message inside the modal
            showLoadingMessageSurv();

        }


        document.getElementById("openModalBtn1").addEventListener("click", function () {

            modal1.style.display = "block";

            console.log(metadata);

            // Clear previous form contents
            const form = document.getElementById("dropdownForm");
            const form1 = document.getElementById("dropdownForm1");
            form.innerHTML = '';
            form1.innerHTML = '';

            // First dropdown label and menu
            const label = document.createElement('label');
            label.textContent = "Select the Event:";
            label.style.color = 'white';
            label.setAttribute('for', 'metadataDropdown1');
            form.appendChild(label);

            const select = document.createElement('select');
            select.id = 'metadataDropdown1';
            select.name = 'metadataSelection1';

            metadata.forEach((item) => {
                const option = document.createElement('option');
                option.value = item.Sample_geo_accession;
                option.textContent = item.Sample_geo_accession;
                select.appendChild(option);
            });

            form.appendChild(select);

            // Second dropdown label and menu
            const label1 = document.createElement('label');
            label1.textContent = "Select Time to Follow Up:";
            label1.style.color = 'white';
            label1.setAttribute('for', 'metadataDropdown2');
            form1.appendChild(label1);  // Corrected from appending 'label' to 'label1'

            const select1 = document.createElement('select');
            select1.id = 'metadataDropdown2';
            select1.name = 'metadataSelection2';

            metadata.forEach((item) => {
                const option = document.createElement('option');
                option.value = item.Sample_geo_accession;
                option.textContent = item.Sample_geo_accession;
                select1.appendChild(option);
            });

            form1.appendChild(select1);

            btn2.addEventListener('click', filterMetadata)




        });

        function filterMetadata() {
            const selectedEvent = document.getElementById('metadataDropdown1').value;
            const selectedTime = document.getElementById('metadataDropdown2').value;

            // Filter the metadata based on the selections
            const filteredMetadata = metadata.filter(item =>
                item.Sample_geo_accession === selectedEvent ||
                item.Sample_geo_accession === selectedTime
            );

            console.log('Filtered Metadata:', filteredMetadata);


            const data = { filteredMetadata, dataC_copy_pval, selectedGeneData }; // Assuming you have these arrays defined elsewhere

            // Send data to server using fetch
            fetch('/survival', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ data: data })
            })
                .then(response => response.json())
                .then(response => {
                    // Redirect to /enrichment with unique identifier (sessionId)
                    window.open(`/survival?sessionId=${response.sessionId}`, '_blank');
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Failed to store survival data');
                });

            // You can further process or display the filteredMetadata here
        }

        //When the user clicks the button, open the modal and create the dot plot inside it
        btn1.onclick = function () {
            modal1.style.display = "block";
            // Display loading message inside the modal
            showLoadingMessageSurv();
            // Call function to create dot plot inside modal
            createSurvivalPlotInsideModal();
            btn2.disabled = false
        }

        // When the user clicks on <span> (x), close the modal
        span1.onclick = function () {
            modal1.style.display = "none";
            // Clear the content of the modal when it is closed
            var survivalContainer = document.getElementById("survival");
            survivalContainer.innerHTML = "";
        }

        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function (event) {
            if (event.target == modal1) {
                modal1.style.display = "none";
                // Clear the content of the modal when it is closed
                var survivalContainer = document.getElementById("survival");
                survivalContainer.innerHTML = "";
            }
        }








        ///////////////////////////////////////////////////////////////////////////////////////////




        function calculateLogFC(dataC, dataN) {
            const logFCData = [];

            // Iterate over each gene
            Object.keys(dataC).forEach(gene => {
                // Get the values for the current gene from dataC and dataN
                let valuesC = Object.values(dataC[gene]);
                let valuesN = Object.values(dataN[gene]);

                // Pop the last value if it's a gene string
                let geneValueC;
                if (isNaN(valuesC[valuesC.length - 1])) {
                    geneValueC = valuesC.pop(); // Remove and store the last value as the gene for dataC
                }
                let geneValueN;
                if (isNaN(valuesN[valuesN.length - 1])) {
                    geneValueN = valuesN.pop(); // Remove and store the last value as the gene for dataN
                }

                // Calculate the row mean for dataC and dataN
                const rowMeanC = valuesC.reduce((acc, val) => acc + val, 0) / valuesC.length;
                const rowMeanN = valuesN.reduce((acc, val) => acc + val, 0) / valuesN.length;

                // Calculate the log fold change
                const logFC = rowMeanC - rowMeanN;

                // Push the gene and its logFC to logFCData
                logFCData.push({ "Gene": geneValueC, "logFC": logFC });
            });

            return logFCData

        }


        function fetchJSON(url) {
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    // Rename the key '_row' to 'Gene' in each object of the JSON array
                    return data.map(obj => {
                        const newObj = { ...obj };
                        newObj['gene'] = newObj['_row'];
                        delete newObj['_row']; // Delete the old key
                        return newObj;
                    });
                })
                .catch(error => {
                    console.error('Error fetching JSON:', error);
                });
        }

        function fetchMeta(url) {
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('Error fetching JSON:', error);
                });
        }

        // Define a function to fetch data from a file with no header
        function fetchData(filename) {
            return fetch(filename)
                .then(response => response.text())
                .then(text => {
                    // Parse the data
                    const rows = text.trim().split('\n');

                    // Extract sample GSM identifiers from the first row (excluding the first element)
                    const sampleGSMs = rows[0].trim().split('\t').slice(1);

                    // Map each row to an object representing gene expression for each sample
                    matrix = rows.slice(1).map(row => {
                        const [gene, ...expressions] = row.trim().split('\t');

                        // Create an object with gene code as the key and an object with sample GSMs and expressions as the value
                        return {
                            gene: gene,
                            expressions: expressions.map(parseFloat)
                        };
                    });

                    // Create a matrix with GSMs as headers
                    const matrixWithHeaders = matrix.reduce((result, entry) => {
                        const geneObj = {
                            Gene: entry.gene, // Optional: Change the key to "Gene" if needed
                            ...Object.fromEntries(sampleGSMs.map((gsm, index) => [gsm, entry.expressions[index]]))
                        };
                        result.push(geneObj);
                        return result;
                    }, []);
                    return matrixWithHeaders; // Return the matrix with headers
                });
        }

        var width = 100,
            height = 100,
            n = 18,
            r = 5,
            π = Math.PI,
            p = 1000;
        const margin = { top: 10, right: 20, bottom: 30, left: 130 };

        var svg = d3.select("#scatterPlot").append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("background", "none")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        var gScatter = svg.selectAll("g")
            .data(d3.range(0, 2 * π, 2 * π / n))
            .enter().append("g")
            .attr("transform", function (d) {
                var x = width * (0.35 * Math.cos(d) + 0.5),
                    y = height * (0.35 * Math.sin(d) + 0.5);
                return "translate(" + [x, y] + ")rotate(" + d * 180 / π + ")";
            });
        var moonsScatter = gScatter.append("path")
            .attr("fill", "#808080");
        d3.timer(function (t) {
            var θ = 2 * π * (t % p / p);
            moonsScatter.attr("d", function (d) { return moon((θ + d) % (2 * π)); });
        });

        const margin1 = { top: 10, right: 20, bottom: 30, left: 5 };
        var svg1 = d3.select("#boxPlot").append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("background", "none")
            .attr("transform", `translate(${margin1.left},${margin1.top})`);

        var gBoxPlot = svg1.selectAll("g")
            .data(d3.range(0, 2 * π, 2 * π / n))
            .enter().append("g")
            .attr("transform", function (d) {
                var x = width * (0.35 * Math.cos(d) + 0.5),
                    y = height * (0.35 * Math.sin(d) + 0.5);
                return "translate(" + [x, y] + ")rotate(" + d * 180 / π + ")";
            });
        var moonsBoxPlot = gBoxPlot.append("path")
            .attr("fill", "#808080");
        d3.timer(function (t) {
            var θ = 2 * π * (t % p / p);
            moonsBoxPlot.attr("d", function (d) { return moon((θ + d) % (2 * π)); });
        });

        function moon(θ) {
            var rx0 = θ < π ? r : -r,
                s0 = θ < π ? 0 : 1,
                rx1 = r * Math.cos(θ),
                s1 = θ < π / 2 || (π <= θ && θ < 3 * π / 2) ? 0 : 1;
            return "M" + [0, r] +
                "A" + [rx0, r, 0, 0, s0, 0, -r] +
                "A" + [rx1, r, 0, 0, s1, 0, r];
        }

        document.getElementById("loadingOverlay").style.display = "none";

        document.getElementById("loadDatasetBtn").addEventListener("click", function () {
            hideOverlay();
            // Add your code to load the dataset here
        });


        // Function to show the overlay and modal
        function showOverlay() {
            document.getElementById("overlay").style.display = "block";
        }

        // Function to hide the overlay and modal
        function hideOverlay() {
            document.getElementById("overlay").style.display = "none";
        }

        // Function to show the CSV file loading overlay
        function showLoadCsvOverlay() {
            document.getElementById("loadDatasetOverlay").style.display = "block";
        }

        // Function to hide the CSV file loading overlay
        function hideLoadCsvOverlay() {
            document.getElementById("loadDatasetOverlay").style.display = "none";
        }


        // File paths
        const filePath1 = 'example/matrix.csv';
        const filePath2 = 'example/metadata.csv';

        // Fetch file data and create File objects
        function preloadFile(filePath, inputElement) {
            fetch(filePath)
                .then(response => response.blob())
                .then(blob => {
                    // Create a File object from the blob
                    const file = new File([blob], filePath, { type: blob.type });

                    // Create a DataTransfer to hold the File object
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);

                    // Assign the File object to the file input
                    inputElement.files = dataTransfer.files;
                })
                .catch(error => console.error('Error preloading file:', error));
        }

        // Preload the files into the file inputs
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput1 = document.getElementById('fileInput1');
            const fileInput2 = document.getElementById('fileInput2');

            preloadFile(filePath1, fileInput1);
            preloadFile(filePath2, fileInput2);
        });


        document.getElementById("loadCsvBtn").addEventListener("click", function () {
            var fileInput1 = document.getElementById("fileInput1");
            var fileInput2 = document.getElementById("fileInput2");
            var file1 = fileInput1.files[0];
            var file2 = fileInput2.files[0];

            // Check if both files are selected
            if (!file1 && !file2) {
                alert("Please select at least one file");
                return;
            }

            if (file1 && !file2) {
                // If only the first file is selected, read and display it
                var reader1 = new FileReader();
                reader1.onload = function (e) {
                    var contents1 = e.target.result;
                    var data1 = parseCsv(contents1);
                    hideLoadCsvOverlay();
                    showDisplayCsvOverlay(data1);
                };
                reader1.readAsText(file1);
            } else {
                // If both files are selected, read and display both files
                var reader1 = new FileReader();
                var reader2 = new FileReader();
                var contents1; // Define contents1 in the outer scope

                reader1.onload = function (e) {
                    contents1 = e.target.result; // Assign contents1 in the onload function of reader1
                    reader2.readAsText(file2); // Read the second file once the first is loaded
                };

                reader2.onload = function (e) {
                    var contents2 = e.target.result;
                    var data1 = parseCsv(contents1); // Use contents1 here
                    var data2 = parseCsv(contents2);
                    hideLoadCsvOverlay();
                    showDisplayCsvOverlay(data1, data2);
                };

                reader1.readAsText(file1); // Read the first file
            }
        });

        function parseCsv(contents) {
            var lines = contents.split('\n');
            var data = [];

            // Function to detect the delimiter (assuming this is already defined)
            var delimiter = detectDelimiter(lines[0]);
            console.log("Detected delimiter:", delimiter);

            // Parse headers and apply transformations
            var headers = lines[0].split(delimiter).map(header => header.trim()); // Trim headers

            // Transform headers: Ensure each header starts with 'X' and replace '-' with '.'
            headers = headers.map(header => {
                // Replace '-' with '.'
                header = header.replace(/-/g, '.');
                // Add 'X' at the beginning if the header starts with a number
                if (/^\d/.test(header)) {
                    header = 'X' + header;
                }
                return header;
            });

            for (var i = 1; i < lines.length; i++) {
                var obj = {};
                var currentline = lines[i].split(delimiter);
                if (currentline.length !== headers.length) {
                    continue; // Skip this line if the number of columns doesn't match the number of headers
                }
                for (var j = 0; j < headers.length; j++) {
                    obj[headers[j]] = currentline[j].trim(); // Trim data values
                    obj[headers[j]] = obj[headers[j]].replace(/\r/g, ''); // Remove carriage return characters
                }
                data.push(obj);
            }
            return data;
        }
        // Function to detect the delimiter in the CSV data
        function detectDelimiter(line) {
            // Check if the line contains a comma or a semicolon
            if (line.includes(',')) {
                return ',';
            } else if (line.includes(';')) {
                return ';';
            } else {
                // Default to comma if neither comma nor semicolon is found
                return ',';
            }
        }

        // Event listener for the "Load Dataset" button
        document.getElementById("loadDatasetBtn").addEventListener("click", function () {
            hideOverlay();
            showLoadCsvOverlay();
        });

        document.getElementById("tryExampleBtn").addEventListener("click", function () {
            hideOverlay();
            showLoadCsvOverlay();
        })

        //**********************     INIZIO VECCHIA FUNZIONE INIZIALE LOADING DI TUTTI I VARI FILE  ******************************//
        /*
            document.getElementById("tryExampleBtn").addEventListener("click", function () {
                hideOverlay();
                document.getElementById("loadingOverlay").style.display = "block";
    
                Promise.all([fetchJSON('dataC_log.json'), fetchJSON('dataN_log.json'), fetchJSON('data_log.json'), fetchMeta('metadata.json')])
                    .then(([dataC, dataN, data, meta]) => {
                        dataC_original = dataC
                        dataN_original = dataN
                        data_original = data
                        console.log(data)
                        metadata = meta
                        fetch('variation_lung.txt')
                            .then(response => response.text())
                            .then(text => {
                                // Parse the data
                                const rows = text.split('\n');
                                variation_data = rows.slice(1).map(row => {
                                    const [gene, variation] = row.trim().split('\t');
                                    return parseFloat(variation);
                                });
                                console.log(variation_data)
                                const row_length = rows.length - 1
                                initial_num_genes = row_length
                                variation_data_copy = (variation_data);
                                console.log("numero di geni iniziali prima di qualsiasi filtro " + row_length)
    
                                thr_prc = ss.quantile(variation_data, prc_IQR);
                                updateHistogram(variation_data);
    
                                const ind = variation_data_copy.reduce((result, entry, index) => {
    
                                    if (entry < thr_prc) {
                                        result.push(index);
                                    }
                                    return result;
                                }, []);
    
                                if (ind.length > 0) {
    
                                    // Remove entries corresponding to ind from dataN
                                    data_copy1 = data_original.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from dataC
                                    dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from data
                                    dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from genes
                                    //genes = genes.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from logFC
                                    //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));
    
                                }
    
                                dataN_copy = dataN_copy1
                                dataC_copy = dataC_copy1
                                data_copy = data_copy1
                                console.log("geni tolti dal primo filtering del IQR", ind.length)
    
                                // Update the gene count display
                                // const geneCountDiv = document.getElementById('geneCount');
                                // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;
    
                                first_filter_number_genes = data_copy.length
                                console.log(dataC_original)
                                parsedLogFC_origin1 = calculateLogFC(dataC_original, dataN_original)
                                parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
                                parsedLogFC = parsedLogFC_origin
    
                                //  console.log("first parsed origin after",parsedLogFC_origin.length)
                                //  console.log("first data orign afterN ",dataN_copy.length)
                                //  console.log("first data orign afterC ",dataC_copy.length)
    
                                averageExpressions10C = calculateAverageLog10Expressions(dataC_copy);
                                averageExpressions10N = calculateAverageLog10Expressions(dataN_copy);
    
    
                                fetch('genes_and_pval_adj.json')
                                    .then(response => response.json())
                                    .then(data => {
                                        p_val_adj = data
    
                                        // Calculate the quantile
                                        log_thr_fc = Math.log2(1.1);
                                        //console.log(log_thr_fc)
                                        const ind = parsedLogFC_origin.reduce((result, entry, index) => {
    
                                            if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                                result.push(index);
    
                                            }
                                            return result;
                                        }, []);
                                        console.log("geni tolti dal primo filtering del LOGFC", ind.length)
    
                                        // console.log("parsed log before ",parsedLogFC.length)
                                        // console.log("data copy beforeC ",dataC_copy.length)
                                        // console.log("data copy beforeN ",dataN_copy.length)
    
                                        // console.log("parsed log origin ",parsedLogFC_origin.length)
                                        /////////////////////// 
    
                                        //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE
    
                                        //////////////////////
                                        // console.log(parsedLogFC_origin)
                                        // console.log(data_copy)
                                        if (ind.length > 0) {
    
                                            // Remove entries corresponding to ind from dataN
                                            dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));
    
                                            // Remove entries corresponding to ind from dataN
                                            dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));
    
                                            data_copy = data_copy1.filter((entry, index) => !ind.includes(index));
    
                                            parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
                                        }
    
                                        //////// DATI FILTRATI DAL PRIMO FOLD-CHANGE//////////////////
                                        // console.log(parsedLogFC)
                                        // console.log(data_copy)
    
                                        updateLogFCHistogram(parsedLogFC_origin)
    
                                        var req = ocpu.call("hello", {
                                            data: data_copy
                                        }, function (session) {
                                            var filteredDataURL = session.loc + "/R/.val/json";
                                            //console.log(session);
                                            // Fetch the filtered data from the URL
                                            fetch(filteredDataURL)
                                                .then(response => response.json())
                                                .then(data => {
                                                    old_p_adj = data
                                                    const ind = old_p_adj.reduce((result, entry, index) => {
    
                                                        if (entry.pval_adj > threshold) {
                                                            result.push(index);
                                                        }
                                                        return result;
                                                    }, []);
    
    
                                                    console.log("geni tolti dal primo filtering del pval", ind.length)
    
                                                    if (ind.length > 0) {
    
                                                        //console.log(parsedLogFC.length)
    
                                                        // Remove entries corresponding to ind from dataN
    
                                                        // Remove entries corresponding to ind from dataN
                                                        dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));
    
                                                        // Remove entries corresponding to ind from dataN
                                                        dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));
    
    
                                                        data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));
    
                                                        console.log("geni rimamenti dal primo filtering", data_copy.length)
                                                        // Remove entries corresponding to ind from logFC
                                                        parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));
    
                                                        parsedLogFC_pval = parsedLogFC
                                                        updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
    
                                                        console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)
    
                                                        var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);
    
                                                        var mostUpregulatedGene = sortedLogFC[0];
                                                        var secondMostUpregulatedGene = sortedLogFC[1];
    
                                                        var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                        var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];
    
                                                        var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                                                        //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                                                        var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                                                        //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene
    
    
                                                        genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
    
                                                        selectedGeneData.push(mostUpregulatedGeneName)
                                                        selectedGeneData.push(mostDownregulatedGeneName)
    
    
    
                                                        updateParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)
    
                                                        updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
    
                                                        updateCounter()
    
                                                        scatter.selectAll("circle")
                                                            .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
                                                            .style("fill", d => {
                                                                // Check if logFC is greater than or equal to the threshold
                                                                return "green";
    
                                                            })
                                                            .classed('pulse', true);
    
    
                                                        document.getElementById("checkbox").style.visibility = "visible";
                                                        document.getElementById("radiobox").style.visibility = "visible";
    
    
                                                    }
                                                    console.log(dataN_copy.length)
                                                    var pc1Values = [];
                                                    var pc2Values = [];
                                                    var groupValues = [];
                                                    var req = ocpu.call("pca", {
                                                        data: data_copy_pval,
                                                        dataN: dataN_copy_pval,
                                                        dataC: dataC_copy_pval
                                                    }, function (session) {
                                                        var filteredDataURL = session.loc + "/R/.val/json";
                                                        //console.log(session);
                                                        // Fetch the filtered data from the URL
                                                        fetch(filteredDataURL)
                                                            .then(response => response.json())
                                                            .then(data => {
                                                                json = data
                                                                console.log(filteredDataURL)
                                                                console.log(json)
    
                                                                var pc1Key = "PC1";
                                                                var pc2Key = "PC2";
                                                                var groupKey = "Group";
    
                                                                // Arrays to store PC1 and PC2 values
    
    
                                                                // Iterate over each object in the JSON array
                                                                json.scores_df.forEach(function (obj) {
                                                                    // Push PC1, PC2, and Group values to the arrays
                                                                    pc1Values.push(obj[pc1Key]);
                                                                    pc2Values.push(obj[pc2Key]);
                                                                    groupValues.push(obj[groupKey]);
                                                                });
                                                                // console.log(pc1Values)
    
                                                                pca_data = [];
    
                                                                // Iterate over each object in the JSON array
                                                                json.scores_df.forEach(function (obj) {
                                                                    // Retrieve additional data from metadata based on _row
                                                                    var gsm = obj._row;
                                                                    var group = obj.Group;
    
                                                                    // Retrieve smokerclass, stage, pc1, and pc2 from metadata
                                                                    var smokerclass = metadata['Cigarette Smoking Status:ch1'][metadata.geo_accession.indexOf(gsm)];
                                                                    var stage = metadata['Stage:ch1'][metadata.geo_accession.indexOf(gsm)];
                                                                    var pc1 = obj.PC1;
                                                                    var pc2 = obj.PC2;
    
                                                                    // Create an object with the required fields
                                                                    var newObj = {
                                                                        GSM: gsm,
                                                                        group: group,
                                                                        smokerclass: smokerclass,
                                                                        stage: stage,
                                                                        pc1: pc1,
                                                                        pc2: pc2
                                                                    };
    
                                                                    // Push the new object to the newData array
                                                                    pca_data.push(newObj);
    
    
                                                                });
                                                                heatmap_data = []
                                                                json.scores_var.forEach(function (obj) {
                                                                    // Push PC1, PC2, and Group values to the arrays
                                                                    var gene = obj._row
                                                                    var pc1 = obj.PC1
                                                                    var pc2 = obj.PC2
                                                                    var pc3 = obj.PC3
                                                                    var pc4 = obj.PC4
                                                                    var pc5 = obj.PC5
                                                                    var pc6 = obj.PC6
    
                                                                    var newObj = {
                                                                        gene: gene,
                                                                        pc1: pc1,
                                                                        pc2: pc2,
                                                                        pc3: pc3,
                                                                        pc4: pc4,
                                                                        pc5: pc5,
                                                                        pc6: pc6
                                                                    };
                                                                    heatmap_data.push(newObj);
                                                                })
                                                                // Display the newData array
                                                                console.log("PCA first computing", pca_data);
    
    
                                                                pca(pca_data);
                                                                heatmap(heatmap_data);
    
                                                            })
    
    
    
    
    
                                                    })
                                                    // DEG(data_copy_pval,parsedLogFC,old_p_adj)
                                                    // var req = ocpu.call("enrichment", {
                                                    //     data: data_copy
                                                    //     }, function (session) {
    
                                                    // })
                                                });
    
    
                                        })
                                        ///// DATI FILTRATI DAL PRIMO PVALUE, GIA' FILTRATI DAL PRIMO LOGFC, CHE ERANO GIA FILTRATI DA PRIMO IQR IN dataC_copy dataN_copy data_copy parsedLogFC ///////
    
    
                                        // Calculate the quantile
                                        log_thr_fc = Math.log2(thr_fc);
    
                                    })
                                const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
    
                                    if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                        result.push(index);
                                    }
                                    return result;
                                }, []);
    
                                // const geneCountDiv2 = document.getElementById('geneCount2');
                                // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;
    
    
                            })
                            .catch(error => console.error('Error reading file:', error));
    
                    });
            });*/

        //**********************     FINE VECCHIA FUNZIONE INIZIALE LOADING DI TUTTI I VARI FILE  ******************************//
        function isInteger(value) {
            return Number.isInteger(parseFloat(value));
        }


        async function showDisplayCsvOverlay(data1, data2) {
            console.log(data1)
            // Create the all_int variable
            let all_int = data1.every(item => {
                // Exclude the first field, typically 'ID_REF'
                return Object.values(item).slice(1).every(isInteger);
            });

            console.log(all_int); // This will be true if all values (excluding the first) are integers

            document.getElementById("displayCsvOverlay").style.display = "block";

            // Display the first 10 columns of each CSV data in a table side by side
            var tableData1 = "<thead><tr>";
            var tableData2 = "<thead><tr>";

            // Determine the headers and data to display based on the presence of data1 and data2
            var headersData1 = [];
            var headersData2 = [];

            if (data1) {
                headersData1 = Object.keys(data1[0]).slice(0, 5);
                document.getElementById("totalColumns1").textContent = Object.keys(data1[0]).length;
            }

            if (data2) {
                headersData2 = Object.keys(data2[0]).slice(0, 5);
                document.getElementById("totalColumns2").textContent = Object.keys(data2[0]).length;
            }

            // Function to truncate headers longer than 8 characters
            function truncateHeader(header) {
                return header.length > 8 ? header.slice(0, 8) + "..." : header;
            }

            // Display headers for data1
            headersData1.forEach(function (key) {
                tableData1 += "<th>" + truncateHeader(key) + "</th>";
            });
            tableData1 += "</tr></thead><tbody>";

            // Display headers for data2
            headersData2.forEach(function (key) {
                tableData2 += "<th>" + truncateHeader(key) + "</th>";
            });
            tableData2 += "</tr></thead><tbody>";

            // Display data rows for data1
            for (var i = 0; i < data1.length; i++) {
                tableData1 += "<tr>";
                headersData1.forEach(function (key) {
                    tableData1 += "<td>" + (data1[i][key] || '') + "</td>";
                });
                tableData1 += "</tr>";
            }
            tableData1 += "</tbody>";

            // Display data rows for data2
            for (var i = 0; i < data2.length; i++) {
                tableData2 += "<tr>";
                headersData2.forEach(function (key) {
                    tableData2 += "<td>" + (data2[i][key] || '') + "</td>";
                });
                tableData2 += "</tr>";
            }
            tableData2 += "</tbody>";

            document.getElementById("csvTableData1").innerHTML = tableData1;
            document.getElementById("csvTableData2").innerHTML = tableData2;

            if (table1) {
                table1.destroy();
                table2.destroy();
            }

            table1 = $('#csvTableData1').DataTable({
                "paging": true, // Enable pagination
                "pageLength": 10, // Number of rows per page
                ordering: false,
                searching: false,
                "lengthChange": false
                // "scrollY": "200px", // Height of the scrolling container
                // "scrollCollapse": true // Collapse the table height to fit the scrolling container
            });

            // Initialize DataTable for the second table with virtual scrolling
            table2 = $('#csvTableData2').DataTable({
                "paging": true, // Enable pagination
                "pageLength": 10, // Number of rows per page
                ordering: false,
                searching: false,
                "lengthChange": false

                // "scrollY": "200px", // Height of the scrolling container
                // "scrollCollapse": true // Collapse the table height to fit the scrolling container
            });

            $('#csvTableData1_wrapper').css('margin-right', '40px');

            document.getElementById("selectMetadataBtn").addEventListener("click", function () {

                // Hide the current overlay
                document.getElementById("displayCsvOverlay").style.display = "none";

                // Create a new overlay for selecting metadata rows
                var selectMetadataOverlay = document.createElement("div");
                selectMetadataOverlay.setAttribute("id", "selectMetadataOverlay");
                selectMetadataOverlay.setAttribute("style", "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; display: flex; justify-content: center; align-items: center;");
                document.body.appendChild(selectMetadataOverlay);


                // Here you can add the logic to display the rows of metadata from the second file
                // For now, let's just display a message
                var selectMetadataContent = document.createElement("div");
                selectMetadataContent.setAttribute("style", "background-color: white; padding: 20px; border-radius: 5px; width: 600px;");
                selectMetadataContent.innerHTML = "<h2>Select Metadata Category</h2><p>Please choose the category within the metadata that contains binary classifications (e.g., case vs. normal, male vs. female) for conducting the Differential Expression Gene (DEG) analysis:</p>";

                // Create an array to keep track of all dropdown pairs
                var dropdownPairs = [];

                // Variables to store the selected values from the dropdowns
                var selectedValue1 = "";
                var selectedValue2 = "";


                // Create dropdown menus for each row in data2
                data2.forEach(function (row, index) {
                    var dropdownContainer = document.createElement("div");
                    dropdownContainer.classList.add("dropdown-container");

                    // Create radio button label
                    var radioLabel = document.createElement("label");
                    var radioButton = document.createElement("input");
                    radioButton.setAttribute("type", "radio");
                    radioButton.setAttribute("name", "metadataRow"); // Set the same name for all radio buttons to make them mutually exclusive
                    radioButton.setAttribute("value", index); // Use the index as the value for identifying the selected row
                    if (index === 0) {
                        radioButton.setAttribute("checked", "checked"); // Check the first radio button by default
                    }
                    radioLabel.appendChild(radioButton);
                    radioLabel.appendChild(document.createTextNode(row[Object.keys(row)[0]])); // Display the value of the first column
                    dropdownContainer.appendChild(radioLabel);
                    selectMetadataContent.appendChild(dropdownContainer);
                    selectMetadataContent.appendChild(document.createElement("br")); // Add line break

                    // Get the values of the selected row
                    var rowData = Object.values(data2[index]);
                    var values = rowData.slice(1); // Exclude the first value (name of the row)
                    var uniqueValues = Array.from(new Set(values)); // Convert Set to array for easier manipulation

                    // Create the first dropdown menu (dropdown1)
                    var dropdown1 = document.createElement("select");
                    dropdown1.setAttribute("name", "dropdown1");
                    dropdown1.setAttribute("style", "margin-left:20px"); // Example styling
                    dropdown1.setAttribute("style", "width:150px"); // Example styling

                    // Create options for dropdown1
                    uniqueValues.forEach(function (value) {
                        var option = document.createElement("option");
                        option.textContent = value;
                        option.setAttribute("value", value);
                        dropdown1.appendChild(option);
                    });

                    // Set the first value as selected in dropdown1
                    dropdown1.selectedIndex = 0;
                    if (index === 0) {
                        selectedValue1 = dropdown1.options[0].value
                    }

                    // Create the second dropdown menu (dropdown2)
                    var dropdown2 = document.createElement("select");
                    dropdown2.setAttribute("name", "dropdown2");
                    dropdown2.setAttribute("style", "width:150px"); // Example styling

                    // Create options for dropdown2 (same options as dropdown1)
                    uniqueValues.forEach(function (value) {
                        var option = document.createElement("option");
                        option.textContent = value;
                        option.setAttribute("value", value);
                        dropdown2.appendChild(option);
                    });

                    // Set the second value as selected in dropdown2
                    dropdown2.selectedIndex = 1;

                    if (index === 0) {
                        selectedValue2 = dropdown2.options[1].value

                    }

                    // Disable dropdowns initially (except for the first pair)
                    if (index !== 0) {
                        dropdown1.disabled = true;
                        dropdown2.disabled = true;
                    }

                    // Add event listeners to synchronize dropdown values
                    dropdown1.addEventListener("change", function () {
                        selectedValue1 = dropdown1.value;
                        synchronizeDropdowns(dropdown1, dropdown2);
                    });

                    dropdown2.addEventListener("change", function () {
                        selectedValue2 = dropdown2.value;

                        synchronizeDropdowns(dropdown2, dropdown1);
                    });

                    // Function to synchronize dropdown values
                    function synchronizeDropdowns(dropdown1n, dropdown2n) {
                        var selectedValue = dropdown1n.value;
                        var selectedValuesec = dropdown2n.value;
                        if (selectedValuesec === selectedValue) {
                            console.log(selectedValuesec, selectedValue)
                            dropdown2n.selectedIndex = (dropdown2n.selectedIndex + 1) % dropdown2n.options.length;
                            selectedValue2 = dropdown2n.value;
                        }
                    }


                    // Add event listener to radio button to enable/disable dropdowns
                    radioButton.addEventListener("change", function () {
                        if (radioButton.checked) {
                            enableDropdowns(index);
                        }
                    });

                    // Function to enable/disable dropdowns based on radio button selection
                    // Function to enable/disable dropdowns based on radio button selection
                    function enableDropdowns(selectedIndex) {
                        dropdownPairs.forEach(function (pair, i) {
                            var isSelected = (i === selectedIndex);
                            pair.dropdown1.disabled = !isSelected;
                            pair.dropdown2.disabled = !isSelected;
                            if (isSelected) {
                                // Update the selected values
                                selectedValue1 = pair.dropdown1.value;
                                selectedValue2 = pair.dropdown2.value;
                                console.log("Selected Value 1:", selectedValue1);
                                console.log("Selected Value 2:", selectedValue2);
                            }
                        });
                    }

                    // Create a span for the "vs" text
                    var vsText = document.createElement("span");
                    vsText.textContent = " vs ";
                    vsText.style.marginLeft = "5px";
                    vsText.style.marginRight = "5px";
                    // Add some padding between the label and the dropdowns
                    radioLabel.style.paddingRight = "10px";

                    dropdownContainer.appendChild(dropdown1);
                    dropdownContainer.appendChild(vsText); // Add "vs" text between dropdowns
                    dropdownContainer.appendChild(dropdown2);

                    dropdownPairs.push({ dropdown1: dropdown1, dropdown2: dropdown2 });

                    selectMetadataContent.appendChild(document.createElement("br")); // Add line break
                });
                console.log(selectedValue1)
                console.log(selectedValue2)

                var selectRowBtn = document.createElement("button");
                selectRowBtn.textContent = "Perform DEG with t-test \n(This may take a while. Don't panic if it seems stuck)";
                selectRowBtn.style.marginLeft = "10px"; // Adjust the value to move it more to the left
                selectRowBtn.style.width = "300px"; // Set an appropriate width to fit the text content
                selectRowBtn.disabled = true; // Disable the button initially

                var selectRowBtn2 = document.createElement("button");
                selectRowBtn2.textContent = "Perform DEG with limma \n(This may take a while. Don't panic if it seems stuck)";
                selectRowBtn2.style.marginLeft = "10px"; // Adjust the value to move it more to the left
                selectRowBtn2.style.width = "300px"; // Set an appropriate width to fit the text content
                selectRowBtn2.disabled = true; // Disable the button initially

                var selectRowBtn3 = document.createElement("button");
                selectRowBtn3.textContent = "Perform DEG with deseq2 \n(This may take a while. Don't panic if it seems stuck)";
                selectRowBtn3.style.marginLeft = "10px"; // Adjust the value to move it more to the left
                selectRowBtn3.style.width = "300px"; // Set an appropriate width to fit the text content
                selectRowBtn3.disabled = true; // Disable the button initially

                var selectColors = document.createElement("button");
                selectColors.textContent = "Select color";
                selectMetadataContent.appendChild(selectColors)

                selectColors.addEventListener("click", function () {
                    // Create a new overlay for selecting colors
                    var selectColorOverlay = document.createElement("div");
                    selectColorOverlay.setAttribute("id", "selectColorOverlay");
                    selectColorOverlay.setAttribute("style", "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1003; display: flex; justify-content: center; align-items: center;");

                    var selectColorContent = document.createElement("div");
                    selectColorContent.setAttribute("style", "background-color: white; padding: 20px; border-radius: 5px;");

                    // Here you can add the logic to display the rows of metadata from the second file
                    // For now, let's just display a message
                    selectColorContent.innerHTML = "<h2>Select Colors</h2><p>Select a color for each unique value in the metadata categories:</p>";
                    console.log(data2)

                    data2.forEach(function (category, i) {
                        var rowData = Object.values(data2[i]); // Get the values of the selected row
                        var rowName = rowData[0];
                        var values = rowData.slice(1); // Exclude the first value (name of the row)
                        // Create an object to store the colors for this category
                        var categoryColors = {};

                        // Create a container for each category
                        var categoryContainer = document.createElement("div");
                        categoryContainer.classList.add("category-container");

                        // Create a label for the category
                        var categoryLabelContainer = document.createElement("div");
                        categoryLabelContainer.classList.add("category-label-container");

                        var categoryLabel = document.createElement("label");
                        categoryLabel.textContent = rowName + ": ";
                        categoryLabel.classList.add("category-label");
                        categoryLabelContainer.appendChild(categoryLabel);

                        // Create a "Resort Scale" button
                        var resortButton = document.createElement("button");
                        resortButton.textContent = "Resort Scale";
                        resortButton.classList.add("resort-button");
                        resortButton.addEventListener('click', function () {
                            // Resort the colors based on the current order
                            var colorInputs = categoryContainer.querySelectorAll('.color-input-container');
                            colorInputs.forEach(function (colorInputContainer, index) {
                                var value = colorInputContainer.querySelector('.value-span').textContent;
                                var colorInput = colorInputContainer.querySelector('.color-input');

                                // Reapply colors based on the order
                                if (uniqueValues.size >= 4) {
                                    var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                    colorInput.value = colorScale(index);
                                } else {
                                    colorInput.value = d3.schemeSet1[index % d3.schemeSet1.length];
                                }

                                // Update colorScaleValues
                                categoryColors[value] = colorInput.value;
                            });

                            // Update colorScaleValues object
                            colorScaleValues[rowName] = categoryColors;
                        });

                        resortButton.addEventListener('dblclick', function () {
                            // Reverse the colors based on the current order
                            var colorInputs = Array.from(categoryContainer.querySelectorAll('.color-input-container')).reverse();
                            colorInputs.forEach(function (colorInputContainer, index) {
                                var value = colorInputContainer.querySelector('.value-span').textContent;
                                var colorInput = colorInputContainer.querySelector('.color-input');

                                // Reapply colors based on the order
                                if (uniqueValues.size >= 4) {
                                    var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                    colorInput.value = colorScale(index);
                                } else {
                                    colorInput.value = d3.schemeSet1[index % d3.schemeSet1.length];
                                }

                                // Update colorScaleValues
                                categoryColors[value] = colorInput.value;
                            });

                            // Update colorScaleValues object
                            colorScaleValues[rowName] = categoryColors;
                        });

                        categoryLabelContainer.appendChild(resortButton);
                        categoryContainer.appendChild(categoryLabelContainer);

                        // Filter values that contain 'I' or 'IA'
                        var filteredValues = values.filter(value => {
                            return value === 'I' || value === 'IA' || value === 'II' || value === 'IB';
                        });

                        if (filteredValues.length > 0) {
                            values.sort();
                            values.reverse();
                        }

                        // Get unique values for the current category
                        var uniqueValues = new Set(values);

                        // Check if there are fewer than 9 unique values
                        if (uniqueValues.size < 9) {
                            // Create a Sortable instance for this group of unique values
                            var sortable = new Sortable(categoryContainer, {
                                draggable: '.color-input-container',
                                animation: 150,
                                onEnd: function (evt) {
                                    updateColorScaleValues();
                                }
                            });
                            // Create color inputs for each unique value
                            let colorIndex = 0;
                            uniqueValues.forEach(function (value) {
                                var colorInputContainer = document.createElement("div");
                                colorInputContainer.classList.add("color-input-container");

                                // Create a span to hold the unique value (centered)
                                var valueSpan = document.createElement("span");
                                valueSpan.textContent = value;
                                valueSpan.classList.add("value-span");
                                colorInputContainer.appendChild(valueSpan);

                                // Create a wrapper div for the color input
                                var inputWrapper = document.createElement("div");
                                inputWrapper.classList.add("input-wrapper");

                                // Create a color input (aligned to the right)
                                var colorInput = document.createElement("input");
                                colorInput.type = "color";
                                colorInput.id = "style1"; // Apply the style by setting the id
                                colorInput.name = category + "_" + value; // Use a unique name for each color input

                                // Assign specific colors for "female" and "male"
                                if (value === selectedValue1) {
                                    colorInput.value = d3.schemeSet1[0]
                                } else if (value === selectedValue2) {
                                    colorInput.value = d3.schemeSet1[2]
                                } else if (value.toLowerCase().includes("female")) {
                                    colorInput.value = d3.schemeSet1[7]; // Eighth color of the schemeSet1 for "female"
                                } else if (value.toLowerCase().includes("male")) {
                                    colorInput.value = d3.schemeSet1[1]; // Second color of the schemeSet1 for "male"
                                } else if (uniqueValues.size >= 4) {
                                    var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                    colorInput.value = colorScale(colorIndex);
                                    colorIndex++;
                                } else {
                                    colorInput.value = d3.schemeSet1[colorIndex % d3.schemeSet1.length]; // Default to cycling through the schemeSet1 colors
                                    colorIndex++;
                                }

                                colorInput.classList.add("color-input");
                                inputWrapper.appendChild(colorInput);

                                // Add an event listener to update colorScaleValues on color change
                                colorInput.addEventListener('input', updateColorScaleValues);

                                // Add the wrapper div to the color input container
                                colorInputContainer.appendChild(inputWrapper);

                                // Add the color input container to the category container
                                categoryContainer.appendChild(colorInputContainer);

                                // Store the category information in the colorScaleValues object
                                categoryColors[value] = colorInput.value;
                            });

                            // Add the category container to the selectColorContent element
                            selectColorContent.appendChild(categoryContainer);

                            // Store the initial colors for the category
                            colorScaleValues[rowName] = categoryColors;
                        }
                    });



                    // Function to update the color scale values
                    function updateColorScaleValues() {
                        // Clear the colorScaleValues object
                        colorScaleValues = {};

                        // Iterate over each category container
                        var categoryContainers = document.querySelectorAll('.category-container');
                        categoryContainers.forEach(function (container) {
                            // Get the category name
                            var categoryName = container.querySelector('.category-label').textContent.replace(':', '').trim();

                            // Create an object to store the colors for this category
                            var categoryColors = {};

                            // Iterate over each color input container in the category container
                            var colorInputContainers = container.querySelectorAll('.color-input-container');
                            colorInputContainers.forEach(function (colorInputContainer) {
                                // Get the value and color of the color input
                                var value = colorInputContainer.querySelector('.value-span').textContent;
                                var colorInput = colorInputContainer.querySelector('.color-input');
                                var color = colorInput.value;

                                // Store the value and color in the categoryColors object
                                categoryColors[value] = color;
                            });

                            // Store the categoryColors object in the colorScaleValues object
                            colorScaleValues[categoryName] = categoryColors;
                        });
                    }

                    // Add the overlay to the body
                    document.body.appendChild(selectColorOverlay);
                    selectColorOverlay.appendChild(selectColorContent);

                    console.log(colorScaleValues);
                    // Add a back button to go back to the previous step
                    var backBtn = document.createElement("button");
                    backBtn.textContent = "Save";
                    backBtn.addEventListener("click", function () {
                        selectColorOverlay.remove();
                        selectRowBtn.disabled = false; // Enable the button once colors are confirmed
                        selectRowBtn2.disabled = false; // Enable the button once colors are confirmed
                        if (all_int) selectRowBtn3.disabled = false; // Enable the button once colors are confirmed
                        document.body.appendChild(selectMetadataOverlay); // Assuming selectMetadataOverlay is defined earlier
                    });

                    selectColorContent.appendChild(backBtn);

                    selectColorOverlay.appendChild(selectColorContent);
                    document.body.appendChild(selectColorOverlay);
                });

                // console.log(data2)
                // console.log(data1)

                selectRowBtn2.addEventListener("click", async function () {
                    chosen_statistic = 'limma'
                    event.stopPropagation(); // Prevent event bubbling
                    var selectedRowIndex = document.querySelector('input[name="metadataRow"]:checked').value;
                    var rowData = Object.values(data2[selectedRowIndex]); // Get the values of the selected row
                    selectedRowName = rowData[0]
                    selectedVariable = selectedRowName
                    // console.log(selectedRowName)
                    first_dims = [selectedRowName]
                    var values = rowData.slice(1); // Exclude the first value (name of the row)

                    console.log("Two groups of values found:\SelectedValue 1: " + selectedValue1 + "\SelectedValue 2: " + selectedValue2);

                    // Hide the overlay
                    var selectMetadataOverlay = document.getElementById("selectMetadataOverlay");
                    if (selectMetadataOverlay) {
                        selectMetadataOverlay.style.display = "none";
                        selectMetadataOverlay.style.visibility = "hidden"; // Optional, if necessary
                        // Alternatively: $("selectMetadataOverlay").hide(); if using jQuery
                    }

                    // Show the loading overlay
                    document.getElementById("loadingOverlay").style.display = "block";

                    console.log("REMOVED")

                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulating async operation

                    var selectedValue = selectedValue1; // or group2[0] depending on which group represents the selected value
                    chosen_meta1 = selectedValue1
                    chosen_meta2 = selectedValue2


                    // Show the loading // Assuming you have already obtained the selected row index and values from data2
                    var dataC = [];
                    var dataN = [];


                    // console.log(data1, data2, selectedRowIndex, selectedValue)

                    // Convert function to string to create the worker
                    const workerCode = `
                        // Function to perform data transformations
                        function performDataTransformations(data1, data2, selectedRowIndex, selectedValue) {
                            var dataC = [];
                            var dataN = [];

                            // console.log(data1, data2, selectedRowIndex, selectedValue)

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the gene name from the first property of the object

                                // Create new objects for dataC and dataN
                                var newObjC = { "gene": gene };
                                var newObjN = { "gene": gene };

                                // Loop through the keys in the object and add values to newObjC and newObjN accordingly
                                for (var key in obj) {
                                    if (key !== Object.keys(obj)[0]) {
                                        // Check if the value in data2 matches the selected value
                                        if (data2[selectedRowIndex][key] === selectedValue) {
                                            newObjC[key] = obj[key]; // Add value to newObjC
                                        } else {
                                            newObjN[key] = obj[key]; // Add value to newObjN
                                        }
                                    }
                                }

                                // Push the new objects to dataC and dataN
                                dataC.push(newObjC);
                                dataN.push(newObjN);
                            }

                            // Create a new array to hold the reordered data
                            var reorderedData = [];

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the first value of the object

                                // Find the corresponding row in dataC and dataN
                                var rowDataN = dataN.find(row => row.gene === gene);
                                var rowDataC = dataC.find(row => row.gene === gene);

                                // Construct the new object with the desired structure
                                var reorderedObj = { "gene": gene };

                                // Add GSM values from dataN to reorderedObj
                                for (var key in rowDataN) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataN[key];
                                    }
                                }

                                // Add GSM values from dataC to reorderedObj
                                for (var key in rowDataC) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataC[key];
                                    }
                                }

                                // Push the new object to the reorderedData array
                                reorderedData.push(reorderedObj);
                            }

                            // Now, reorderedData contains the desired structure

                            data1 = reorderedData

                            case_number = Object.keys(dataC[0]).length - 1
                            normal_number = Object.keys(dataN[0]).length - 1

                            // console.log(case_number, normal_number)

                            // console.log(Object.keys(dataC[0]).length - 1)
                            // console.log(Object.keys(dataN[0]).length - 1)

                            // Assuming you have obtained genes from data1
                            var genes = data1.map(obj => obj[Object.keys(obj)[0]]);


                            // Calculate overall mean for data1
                            var overall_mean = data1.map(obj => {
                                var values = Object.values(obj).slice(1).map(parseFloat);
                                return values.reduce((acc, val) => acc + val, 0) / values.length;
                            });

                            // Filter out rows with overall mean equal to 0
                            var ind = overall_mean.reduce((acc, val, index) => {
                                if (val === 0) {
                                    // console.log("VALUE 0");
                                    acc.push(index);
                                }
                                return acc;
                            }, []);

                            // Filter dataC, dataN, data1, and genes based on ind
                            if (ind.length > 0) {
                                dataN = dataN.filter((_, index) => !ind.includes(index));
                                dataC = dataC.filter((_, index) => !ind.includes(index));
                                data1 = data1.filter((_, index) => !ind.includes(index));
                                genes = genes.filter((_, index) => !ind.includes(index));
                            }

                            // Logarithmic transformation for dataN, dataC, and data1
                            dataN = dataN.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            dataC = dataC.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            data1 = data1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            console.log("CIAO")

                            // Return the processed data
                            return {
                                dataC: dataC,
                                dataN: dataN,
                                data1: data1,
                                genes: genes, // Assuming genes are extracted from data1
                                case_number: case_number,
                                normal_number: normal_number
                            };
                        }

                        // Listen for messages from the main thread
                        self.addEventListener('message', function(e) {
                            // Retrieve data from the message
                            var { data1, data2, selectedRowIndex, selectedValue } = e.data;

                            // Perform data transformations
                            var result = performDataTransformations(data1, data2, selectedRowIndex, selectedValue);

                            // Send the result back to the main thread
                            postMessage(result);
                        }, false);
                    `;

                    // Create a Blob object from the worker code string
                    const blob = new Blob([workerCode], { type: 'application/javascript' });

                    // Create a URL for the blob object
                    const blobURL = URL.createObjectURL(blob);

                    // Create a new web worker from the blob URL
                    const worker = new Worker(blobURL);

                    // Promisify the web worker
                    function runWorker(worker, message) {
                        return new Promise((resolve, reject) => {
                            worker.onmessage = resolve;
                            worker.onerror = reject;
                            worker.postMessage(message);
                        });
                    }

                    // Start the data transformation process in the worker
                    runWorker(worker, {
                        data1: data1,
                        data2: data2,
                        selectedRowIndex: selectedRowIndex,
                        selectedValue: selectedValue1 // Change this to selectedValue2 if needed
                    }).then(result => {
                        console.log(result)
                        // Process the returned data
                        dataC = result.data.dataC;
                        dataN = result.data.dataN;
                        data1 = result.data.data1;
                        case_number = result.data.case_number;
                        normal_number = result.data.normal_number;
                        genes = result.data.genes;
                        // dataC, dataN, data1, genes, case_number, normal_number = result.data;

                        // Update your UI or further process the data as needed
                        console.log(dataC);
                        console.log(dataN);
                        console.log(data1);
                        console.log(genes);
                        console.log(case_number);
                        console.log(normal_number);

                        // Hide the loading overlay after all operations are complete
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();

                        // Start the next step
                        start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic);

                    }).catch(error => {
                        console.error('Error in web worker:', error);

                        // Hide the loading overlay on error
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();
                    });

                })

                selectRowBtn3.addEventListener("click", async function () {
                    chosen_statistic = 'deseq2'
                    event.stopPropagation(); // Prevent event bubbling
                    var selectedRowIndex = document.querySelector('input[name="metadataRow"]:checked').value;
                    var rowData = Object.values(data2[selectedRowIndex]); // Get the values of the selected row
                    selectedRowName = rowData[0]
                    selectedVariable = selectedRowName
                    // console.log(selectedRowName)
                    first_dims = [selectedRowName]
                    var values = rowData.slice(1); // Exclude the first value (name of the row)

                    console.log("Two groups of values found:\SelectedValue 1: " + selectedValue1 + "\SelectedValue 2: " + selectedValue2);

                    // Hide the overlay
                    var selectMetadataOverlay = document.getElementById("selectMetadataOverlay");
                    if (selectMetadataOverlay) {
                        selectMetadataOverlay.style.display = "none";
                        selectMetadataOverlay.style.visibility = "hidden"; // Optional, if necessary
                        // Alternatively: $("selectMetadataOverlay").hide(); if using jQuery
                    }

                    // Show the loading overlay
                    document.getElementById("loadingOverlay").style.display = "block";

                    console.log("REMOVED")

                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulating async operation

                    var selectedValue = selectedValue1; // or group2[0] depending on which group represents the selected value
                    chosen_meta1 = selectedValue1
                    chosen_meta2 = selectedValue2


                    // Show the loading // Assuming you have already obtained the selected row index and values from data2
                    var dataC = [];
                    var dataN = [];


                    // console.log(data1, data2, selectedRowIndex, selectedValue)

                    // Convert function to string to create the worker
                    const workerCode = `
                        // Function to perform data transformations
                        function performDataTransformations(data1, data2, selectedRowIndex, selectedValue) {
                            var dataC = [];
                            var dataN = [];

                            // console.log(data1, data2, selectedRowIndex, selectedValue)

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the gene name from the first property of the object

                                // Create new objects for dataC and dataN
                                var newObjC = { "gene": gene };
                                var newObjN = { "gene": gene };

                                // Loop through the keys in the object and add values to newObjC and newObjN accordingly
                                for (var key in obj) {
                                    if (key !== Object.keys(obj)[0]) {
                                        // Check if the value in data2 matches the selected value
                                        if (data2[selectedRowIndex][key] === selectedValue) {
                                            newObjC[key] = obj[key]; // Add value to newObjC
                                        } else {
                                            newObjN[key] = obj[key]; // Add value to newObjN
                                        }
                                    }
                                }

                                // Push the new objects to dataC and dataN
                                dataC.push(newObjC);
                                dataN.push(newObjN);
                            }

                            // Create a new array to hold the reordered data
                            var reorderedData = [];

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the first value of the object

                                // Find the corresponding row in dataC and dataN
                                var rowDataN = dataN.find(row => row.gene === gene);
                                var rowDataC = dataC.find(row => row.gene === gene);

                                // Construct the new object with the desired structure
                                var reorderedObj = { "gene": gene };

                                // Add GSM values from dataN to reorderedObj
                                for (var key in rowDataN) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataN[key];
                                    }
                                }

                                // Add GSM values from dataC to reorderedObj
                                for (var key in rowDataC) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataC[key];
                                    }
                                }

                                // Push the new object to the reorderedData array
                                reorderedData.push(reorderedObj);
                            }

                            // Now, reorderedData contains the desired structure

                            data1 = reorderedData

                            case_number = Object.keys(dataC[0]).length - 1
                            normal_number = Object.keys(dataN[0]).length - 1

                            // console.log(case_number, normal_number)

                            // console.log(Object.keys(dataC[0]).length - 1)
                            // console.log(Object.keys(dataN[0]).length - 1)

                            // Assuming you have obtained genes from data1
                            var genes = data1.map(obj => obj[Object.keys(obj)[0]]);

                            
                            // Calculate overall mean for data1
                            var overall_mean = data1.map(obj => {
                                var values = Object.values(obj).slice(1).map(parseFloat);
                                return values.reduce((acc, val) => acc + val, 0) / values.length;
                            });

                            // Filter out rows with overall mean equal to 0
                            var ind = overall_mean.reduce((acc, val, index) => {
                                if (val === 0) {
                                    // console.log("VALUE 0");
                                    acc.push(index);
                                }
                                return acc;
                            }, []);

                            // Filter dataC, dataN, data1, and genes based on ind
                            if (ind.length > 0) {
                                dataN = dataN.filter((_, index) => !ind.includes(index));
                                dataC = dataC.filter((_, index) => !ind.includes(index));
                                data1 = data1.filter((_, index) => !ind.includes(index));
                                genes = genes.filter((_, index) => !ind.includes(index));
                            }

                            // Logarithmic transformation for dataN, dataC, and data1
                            dataN = dataN.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            dataC = dataC.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            data1 = data1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            // Return the processed data
                            return {
                                dataC: dataC,
                                dataN: dataN,
                                data1: data1,
                                genes: genes, // Assuming genes are extracted from data1
                                case_number: case_number,
                                normal_number: normal_number
                            };
                        }

                        // Listen for messages from the main thread
                        self.addEventListener('message', function(e) {
                            // Retrieve data from the message
                            var { data1, data2, selectedRowIndex, selectedValue } = e.data;

                            // Perform data transformations
                            var result = performDataTransformations(data1, data2, selectedRowIndex, selectedValue);

                            // Send the result back to the main thread
                            postMessage(result);
                        }, false);
                    `;

                    // Create a Blob object from the worker code string
                    const blob = new Blob([workerCode], { type: 'application/javascript' });

                    // Create a URL for the blob object
                    const blobURL = URL.createObjectURL(blob);

                    // Create a new web worker from the blob URL
                    const worker = new Worker(blobURL);

                    // Promisify the web worker
                    function runWorker(worker, message) {
                        return new Promise((resolve, reject) => {
                            worker.onmessage = resolve;
                            worker.onerror = reject;
                            worker.postMessage(message);
                        });
                    }

                    // Start the data transformation process in the worker
                    runWorker(worker, {
                        data1: data1,
                        data2: data2,
                        selectedRowIndex: selectedRowIndex,
                        selectedValue: selectedValue1 // Change this to selectedValue2 if needed
                    }).then(result => {
                        console.log(result)
                        // Process the returned data
                        dataC = result.data.dataC;
                        dataN = result.data.dataN;
                        data1 = result.data.data1;
                        case_number = result.data.case_number;
                        normal_number = result.data.normal_number;
                        genes = result.data.genes;
                        // dataC, dataN, data1, genes, case_number, normal_number = result.data;

                        // Update your UI or further process the data as needed
                        console.log(dataC);
                        console.log(dataN);
                        console.log(data1);
                        console.log(genes);
                        console.log(case_number);
                        console.log(normal_number);

                        // Hide the loading overlay after all operations are complete
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();

                        // Start the next step
                        start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic);

                    }).catch(error => {
                        console.error('Error in web worker:', error);

                        // Hide the loading overlay on error
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();
                    });

                })


                selectRowBtn.addEventListener("click", async function () {

                    chosen_statistic = 't-test'
                    event.stopPropagation(); // Prevent event bubbling
                    var selectedRowIndex = document.querySelector('input[name="metadataRow"]:checked').value;
                    var rowData = Object.values(data2[selectedRowIndex]); // Get the values of the selected row
                    selectedRowName = rowData[0]
                    selectedVariable = selectedRowName
                    // console.log(selectedRowName)
                    first_dims = [selectedRowName]
                    var values = rowData.slice(1); // Exclude the first value (name of the row)

                    console.log("Two groups of values found:\SelectedValue 1: " + selectedValue1 + "\SelectedValue 2: " + selectedValue2);

                    // Hide the overlay
                    var selectMetadataOverlay = document.getElementById("selectMetadataOverlay");
                    if (selectMetadataOverlay) {
                        selectMetadataOverlay.style.display = "none";
                        selectMetadataOverlay.style.visibility = "hidden"; // Optional, if necessary
                        // Alternatively: $("selectMetadataOverlay").hide(); if using jQuery
                    }

                    // Show the loading overlay
                    document.getElementById("loadingOverlay").style.display = "block";

                    console.log("REMOVED")

                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulating async operation

                    var selectedValue = selectedValue1; // or group2[0] depending on which group represents the selected value
                    chosen_meta1 = selectedValue1
                    chosen_meta2 = selectedValue2


                    // Show the loading // Assuming you have already obtained the selected row index and values from data2
                    var dataC = [];
                    var dataN = [];

                    // Convert function to string to create the worker
                    const workerCode = `
                        // Function to perform data transformations
                        function performDataTransformations(data1, data2, selectedRowIndex, selectedValue) {
                            var dataC = [];
                            var dataN = [];

                            // console.log(data1, data2, selectedRowIndex, selectedValue)

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the gene name from the first property of the object

                                // Create new objects for dataC and dataN
                                var newObjC = { "gene": gene };
                                var newObjN = { "gene": gene };

                                // Loop through the keys in the object and add values to newObjC and newObjN accordingly
                                for (var key in obj) {
                                    if (key !== Object.keys(obj)[0]) {
                                        // Check if the value in data2 matches the selected value
                                        if (data2[selectedRowIndex][key] === selectedValue) {
                                            newObjC[key] = obj[key]; // Add value to newObjC
                                        } else {
                                            newObjN[key] = obj[key]; // Add value to newObjN
                                        }
                                    }
                                }

                                // Push the new objects to dataC and dataN
                                dataC.push(newObjC);
                                dataN.push(newObjN);
                            }

                            // Create a new array to hold the reordered data
                            var reorderedData = [];

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the first value of the object

                                // Find the corresponding row in dataC and dataN
                                var rowDataN = dataN.find(row => row.gene === gene);
                                var rowDataC = dataC.find(row => row.gene === gene);

                                // Construct the new object with the desired structure
                                var reorderedObj = { "gene": gene };

                                // Add GSM values from dataN to reorderedObj
                                for (var key in rowDataN) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataN[key];
                                    }
                                }

                                // Add GSM values from dataC to reorderedObj
                                for (var key in rowDataC) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataC[key];
                                    }
                                }

                                // Push the new object to the reorderedData array
                                reorderedData.push(reorderedObj);
                            }

                            // Now, reorderedData contains the desired structure

                            data1 = reorderedData

                            case_number = Object.keys(dataC[0]).length - 1
                            normal_number = Object.keys(dataN[0]).length - 1

                            // console.log(case_number, normal_number)

                            // console.log(Object.keys(dataC[0]).length - 1)
                            // console.log(Object.keys(dataN[0]).length - 1)

                            // Assuming you have obtained genes from data1
                            var genes = data1.map(obj => obj[Object.keys(obj)[0]]);


                            // Calculate overall mean for data1
                            var overall_mean = data1.map(obj => {
                                var values = Object.values(obj).slice(1).map(parseFloat);
                                return values.reduce((acc, val) => acc + val, 0) / values.length;
                            });

                            // Filter out rows with overall mean equal to 0
                            var ind = overall_mean.reduce((acc, val, index) => {
                                if (val === 0) {
                                    // console.log("VALUE 0");
                                    acc.push(index);
                                }
                                return acc;
                            }, []);

                            // Filter dataC, dataN, data1, and genes based on ind
                            if (ind.length > 0) {
                                dataN = dataN.filter((_, index) => !ind.includes(index));
                                dataC = dataC.filter((_, index) => !ind.includes(index));
                                data1 = data1.filter((_, index) => !ind.includes(index));
                                genes = genes.filter((_, index) => !ind.includes(index));
                            }

                            // Logarithmic transformation for dataN, dataC, and data1
                            dataN = dataN.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            dataC = dataC.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            data1 = data1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            console.log("CIAO")

                            // Return the processed data
                            return {
                                dataC: dataC,
                                dataN: dataN,
                                data1: data1,
                                genes: genes, // Assuming genes are extracted from data1
                                case_number: case_number,
                                normal_number: normal_number
                            };
                        }

                        // Listen for messages from the main thread
                        self.addEventListener('message', function(e) {
                            // Retrieve data from the message
                            var { data1, data2, selectedRowIndex, selectedValue } = e.data;

                            // Perform data transformations
                            var result = performDataTransformations(data1, data2, selectedRowIndex, selectedValue);

                            // Send the result back to the main thread
                            postMessage(result);
                        }, false);
                    `;

                    // Create a Blob object from the worker code string
                    const blob = new Blob([workerCode], { type: 'application/javascript' });

                    // Create a URL for the blob object
                    const blobURL = URL.createObjectURL(blob);

                    // Create a new web worker from the blob URL
                    const worker = new Worker(blobURL);

                    // Promisify the web worker
                    function runWorker(worker, message) {
                        return new Promise((resolve, reject) => {
                            worker.onmessage = resolve;
                            worker.onerror = reject;
                            worker.postMessage(message);
                        });
                    }

                    // Start the data transformation process in the worker
                    runWorker(worker, {
                        data1: data1,
                        data2: data2,
                        selectedRowIndex: selectedRowIndex,
                        selectedValue: selectedValue1 // Change this to selectedValue2 if needed
                    }).then(result => {
                        console.log(result)
                        // Process the returned data
                        dataC = result.data.dataC;
                        dataN = result.data.dataN;
                        data1 = result.data.data1;
                        case_number = result.data.case_number;
                        normal_number = result.data.normal_number;
                        genes = result.data.genes;
                        // dataC, dataN, data1, genes, case_number, normal_number = result.data;

                        // Update your UI or further process the data as needed
                        console.log(dataC);
                        console.log(dataN);
                        console.log(data1);
                        console.log(genes);
                        console.log(case_number);
                        console.log(normal_number);

                        // Hide the loading overlay after all operations are complete
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();

                        // Start the next step
                        start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic);

                    }).catch(error => {
                        console.error('Error in web worker:', error);

                        // Hide the loading overlay on error
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();
                    });


                });
                selectMetadataContent.appendChild(selectColors);

                selectMetadataContent.appendChild(selectRowBtn);
                selectMetadataContent.appendChild(selectRowBtn2);
                selectMetadataContent.appendChild(selectRowBtn3);

                selectMetadataOverlay.appendChild(selectMetadataContent);

            });
        }


        function start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic) {

            dataC_original = dataC
            dataN_original = dataN
            data_original = data1
            metadata = data2






            var req = ocpu.call("variation", {
                rawdata: data1,
            }, function (session) {
                var filteredDataURL = session.loc + "/R/.val/json";
                console.log(session);
                // Fetch the filtered data from the URL
                fetch(filteredDataURL)
                    .then(response => response.json())
                    .then(data => {
                        document.getElementById("loadingOverlay").style.display = "none";

                        const innerData = JSON.parse(data[0]);
                        console.log(data1)

                        // Extract variation values from the inner JSON array
                        variation_data = innerData.map(obj => obj.Variation);

                        // Now you have an array of variation values, you can use it as needed
                        console.log(variation_data);
                        row_length = variation_data.length
                        initial_num_genes = row_length

                        console.log("numero di geni iniziali prima di qualsiasi filtro " + row_length)

                        thr_prc = ss.quantile(variation_data, prc_IQR);
                        updateHistogram(variation_data);
                        variation_data_copy = (variation_data);

                        const ind = variation_data_copy.reduce((result, entry, index) => {

                            if (entry < thr_prc) {
                                result.push(index);
                            }
                            return result;
                        }, []);

                        console.log(ind)

                        if (ind.length > 0) {

                            // Remove entries corresponding to ind from dataN
                            data_copy1 = data_original.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from dataC
                            dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from data
                            dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));

                            data_original_cpy = data_copy1

                            dataC_original_cpy = dataC_copy1

                            dataN_original_cpy = dataN_copy1

                            // Remove entries corresponding to ind from genes
                            //genes = genes.filter((entry, index) => !ind.includes(index));

                            // Remove entries corresponding to ind from logFC
                            //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                        }

                        dataN_copy = dataN_copy1
                        dataC_copy = dataC_copy1
                        data_copy = data_copy1
                        console.log("geni tolti dal primo filtering del IQR", ind.length)

                        // Update the gene count display
                        // const geneCountDiv = document.getElementById('geneCount');
                        // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;

                        first_filter_number_genes = data_copy.length
                        console.log(dataC_original)


                        parsedLogFC_origin1 = calculateLogFC(dataC_original, dataN_original)
                        parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
                        parsedLogFC = parsedLogFC_origin
                        console.log(parsedLogFC)

                        //  console.log("first parsed origin after",parsedLogFC_origin.length)
                        //  console.log("first data orign afterN ",dataN_copy.length)
                        //  console.log("first data orign afterC ",dataC_copy.length)

                        averageExpressions10C = calculateAverageLog10Expressions(dataC_copy);
                        averageExpressions10N = calculateAverageLog10Expressions(dataN_copy);

                        if (parsedLogFC) {

                            // Calculate the quantile
                            log_thr_fc = Math.log2(1.1);
                            //console.log(log_thr_fc)
                            const ind = parsedLogFC_origin.reduce((result, entry, index) => {

                                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                    result.push(index);

                                }
                                return result;
                            }, []);
                            console.log("geni tolti dal primo filtering del LOGFC", ind.length)

                            // console.log("parsed log before ",parsedLogFC.length)
                            // console.log("data copy beforeC ",dataC_copy.length)
                            // console.log("data copy beforeN ",dataN_copy.length)

                            // console.log("parsed log origin ",parsedLogFC_origin.length)
                            /////////////////////// 

                            //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE

                            //////////////////////
                            // console.log(parsedLogFC_origin)
                            // console.log(data_copy)
                            if (ind.length > 0) {

                                // Remove entries corresponding to ind from dataN
                                dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from dataN
                                dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));

                                data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

                                parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
                            }

                            //////// DATI FILTRATI DAL PRIMO FOLD-CHANGE//////////////////
                            // console.log(parsedLogFC)
                            // console.log(data_copy)

                            updateLogFCHistogram(parsedLogFC_origin)

                            if (chosen_statistic == 't-test') {
                                var req = ocpu.call("pval", {
                                    data: data_copy,
                                    N: normal_number,
                                    M: case_number
                                }, function (session) {
                                    var filteredDataURL = session.loc + "/R/.val/json";
                                    //console.log(session);
                                    // Fetch the filtered data from the URL
                                    fetch(filteredDataURL)
                                        .then(response => response.json())
                                        .then(data => {
                                            console.log(session);
                                            // Convert pval_adj values back to numbers if needed
                                            data.forEach(entry => {
                                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                                            });

                                            old_p_adj = data
                                            const ind = old_p_adj.reduce((result, entry, index) => {

                                                if (entry.pval_adj > threshold) {
                                                    result.push(index);
                                                }
                                                return result;
                                            }, []);

                                            console.log(old_p_adj)
                                            console.log(ind)


                                            console.log("geni tolti dal primo filtering del pval", ind.length)

                                            if (ind.length > 0) {

                                                //console.log(parsedLogFC.length)

                                                // Remove entries corresponding to ind from dataN

                                                // Remove entries corresponding to ind from dataN
                                                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                                // Remove entries corresponding to ind from dataN
                                                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                                                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                                console.log("geni rimamenti dal primo filtering", data_copy.length)
                                                // Remove entries corresponding to ind from logFC
                                                parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                                parsedLogFC_pval = parsedLogFC
                                                console.log(log_thr_fc)
                                                console.log(parsedLogFC_origin1)
                                                console.log(old_p_adj)

                                                if (parsedLogFC.length == 0) {
                                                    alert("No deg found!")
                                                }

                                                console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                                var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                                console.log(sortedLogFC)

                                                var mostUpregulatedGene = sortedLogFC[0];
                                                var secondMostUpregulatedGene = sortedLogFC[1];

                                                var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                                console.log(mostUpregulatedGene)

                                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                                                //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                                                //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                                                selectedGeneData.push(mostUpregulatedGeneName)
                                                selectedGeneData.push(mostDownregulatedGeneName)

                                                // Find the select element
                                                var selectElement = document.getElementById("selectButton");

                                                // Clear existing options
                                                selectElement.innerHTML = "";

                                                // Add the new options dynamically
                                                var option1 = document.createElement("option");
                                                option1.value = mostUpregulatedGene.Gene;
                                                option1.text = `Most Upregulated (${mostUpregulatedGene.Gene})`;
                                                option1.selected = true;
                                                selectElement.appendChild(option1);

                                                var option2 = document.createElement("option");
                                                option2.value = mostDownregulatedGene.Gene;
                                                option2.text = `Most Downregulated (${mostDownregulatedGene.Gene})`;
                                                selectElement.appendChild(option2);


                                                // updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)

                                                dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)

                                                updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                                                updateCounter()

                                                scatter.selectAll("circle")
                                                    .filter(circleData => circleData.Gene === mostUpregulatedGeneName || circleData.Gene === mostDownregulatedGeneName)
                                                    .style("fill", d => {
                                                        // Check if logFC is greater than or equal to the threshold
                                                        return "green";

                                                    })
                                                    .classed('pulse', true);

                                                // Function to handle checkbox change event
                                                function handleCheckboxChange(event) {
                                                    var isChecked = event.target.checked;
                                                    var category = event.target.value;

                                                    if (isChecked) {
                                                        // Add category to first_dims array
                                                        first_dims.unshift(category);
                                                    } else {
                                                        // Remove category from first_dims array
                                                        var index = first_dims.indexOf(category);
                                                        if (index !== -1) {
                                                            first_dims.splice(index, 1);
                                                        }
                                                    }

                                                    // Log the updated first_dims array
                                                    console.log("Updated first_dims:", first_dims);

                                                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                                }


                                                var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);

                                                // Get the container element
                                                var checkboxContainer = document.getElementById("checkboxContainer");

                                                // Initialize a variable to count the number of checkboxes added to the current row
                                                var checkboxesInRow = 0;

                                                // Iterate through metadataCategories to create checkboxes
                                                metadataCategories.forEach(function (category) {
                                                    // Create a checkbox element
                                                    var checkbox = document.createElement("input");
                                                    checkbox.type = "checkbox";
                                                    checkbox.value = category;
                                                    checkbox.id = "checkbox_" + category; // Set a unique ID for each checkbox

                                                    // Set the checked attribute based on condition
                                                    if (category === selectedRowName) {
                                                        checkbox.checked = true;
                                                    }

                                                    // Create a label for the checkbox
                                                    var label = document.createElement("label");
                                                    label.htmlFor = checkbox.id;
                                                    label.appendChild(document.createTextNode(category));

                                                    // Add event listener to the checkbox to handle change event
                                                    checkbox.addEventListener("change", handleCheckboxChange);

                                                    // Append the checkbox and label to the container element
                                                    checkboxContainer.appendChild(checkbox);
                                                    checkboxContainer.appendChild(label);

                                                    // Increment the count of checkboxes in the row
                                                    checkboxesInRow++;

                                                    // Add a line break after every two checkboxes
                                                    if (checkboxesInRow % 2 === 0) {
                                                        checkboxContainer.appendChild(document.createElement("br"));
                                                    }
                                                });

                                                // Initialize a variable to count the number of radio buttons added to the current row
                                                var radioButtonsInRow = 0;
                                                // Get the container element
                                                var radioBoxContainer = document.getElementById("radioBoxContainer");

                                                // Function to handle radio button change event
                                                function handleRadioButtonChange(event) {
                                                    // Update selectedVariable with the value of the selected radio button
                                                    selectedVariable = event.target.value;

                                                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                                                }


                                                // Iterate through metadataCategories to create radio buttons
                                                // Count the unique values in the metadata category
                                                function countUniqueValues(cat, j) {
                                                    var uniqueValues = new Set(); // Use a Set to store unique values
                                                    // Iterate through metadata categories to create y scales
                                                    metadataCategories.forEach((category, i) => {
                                                        if (j === i) {
                                                            var values = Object.values(metadata[i]); // Extract values for the current category
                                                            values.shift(); // Remove the first value (Sample_source_name_ch1)
                                                            var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                                            console.log("Values for", category, ":", uniqueValues);
                                                            return uniqueValues.length; // Return the size of the Set, which is the count of unique values
                                                        }
                                                    });
                                                }

                                                // Iterate through metadataCategories to create radio buttons
                                                metadataCategories.forEach(function (category, i) {
                                                    // Check if the category has more than 9 unique values
                                                    var values = Object.values(metadata[i]); // Extract values for the current category
                                                    values.shift(); // Remove the first value (Sample_source_name_ch1)
                                                    var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                                    console.log("Values for", category, ":", uniqueValues);
                                                    console.log(uniqueValues.length);
                                                    if (uniqueValues.length >= 9) return

                                                    // Create a radio button element
                                                    var radioButton = document.createElement("input");
                                                    radioButton.type = "radio";
                                                    radioButton.name = "radioButtonGroup"; // Set the same name for all radio buttons in the group
                                                    radioButton.value = category;
                                                    radioButton.id = "radioButton_" + category; // Set a unique ID for each radio button

                                                    // Set the checked attribute based on condition
                                                    if (category === selectedRowName) {
                                                        radioButton.checked = true;
                                                    }

                                                    // Create a label for the radio button
                                                    var label = document.createElement("label");
                                                    label.htmlFor = radioButton.id;
                                                    label.appendChild(document.createTextNode(category));

                                                    // Add event listener to the radio button to handle change event
                                                    radioButton.addEventListener("change", handleRadioButtonChange);

                                                    // Append the radio button and label to the container element
                                                    radioBoxContainer.appendChild(radioButton);
                                                    radioBoxContainer.appendChild(label);

                                                    // Increment the count of radio buttons in the row
                                                    radioButtonsInRow++;

                                                    // Add a line break after every two radio buttons
                                                    if (radioButtonsInRow % 2 === 0) {
                                                        radioBoxContainer.appendChild(document.createElement("br"));
                                                    }
                                                });

                                                document.getElementById("checkboxContainer").style.visibility = "visible";
                                                document.getElementById("radioBoxContainer").style.visibility = "visible";


                                            }
                                            console.log(dataN_copy.length)
                                            var pc1Values = [];
                                            var pc2Values = [];
                                            var groupValues = [];
                                            var req = ocpu.call("pca", {
                                                data: data_copy_pval,
                                                dataN: dataN_copy_pval,
                                                dataC: dataC_copy_pval
                                            }, function (session) {
                                                var filteredDataURL = session.loc + "/R/.val/json";
                                                //console.log(session);
                                                // Fetch the filtered data from the URL
                                                fetch(filteredDataURL)
                                                    .then(response => response.json())
                                                    .then(data => {
                                                        json = data
                                                        console.log(filteredDataURL)
                                                        console.log(json)

                                                        var pc1Key = "PC1";
                                                        var pc2Key = "PC2";
                                                        var groupKey = "Group";

                                                        // Arrays to store PC1 and PC2 values


                                                        // Iterate over each object in the JSON array
                                                        json.scores_df.forEach(function (obj) {
                                                            // Push PC1, PC2, and Group values to the arrays
                                                            pc1Values.push(obj[pc1Key]);
                                                            pc2Values.push(obj[pc2Key]);
                                                            groupValues.push(obj[groupKey]);
                                                        });
                                                        // console.log(pc1Values)

                                                        // Extract metadata categories from the values of the first column
                                                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                                        console.log("Metadata categories:", metadataCategories);

                                                        // Initialize pca_data array
                                                        pca_data = [];

                                                        // Iterate over each object in the JSON array
                                                        json.scores_df.forEach(function (obj) {
                                                            // Retrieve additional data from metadata based on _row
                                                            var gsm = obj._row;
                                                            var group = obj.Group;
                                                            var pc1 = obj.PC1;
                                                            var pc2 = obj.PC2;

                                                            // Create an object with the required fields
                                                            var newObj = {
                                                                GSM: gsm,
                                                                group: group,
                                                                pc1: pc1,
                                                                pc2: pc2
                                                            };

                                                            // Add metadata values for each category to the newObj
                                                            metadataCategories.forEach((category, index) => {
                                                                newObj[category] = metadata[index][gsm];
                                                            });

                                                            // Push the new object to the pca_data array
                                                            pca_data.push(newObj);
                                                        });

                                                        heatmap_data = []
                                                        json.scores_var.forEach(function (obj) {
                                                            // Push PC1, PC2, and Group values to the arrays
                                                            var gene = obj._row
                                                            var pc1 = obj.PC1
                                                            var pc2 = obj.PC2
                                                            var pc3 = obj.PC3
                                                            var pc4 = obj.PC4
                                                            var pc5 = obj.PC5
                                                            var pc6 = obj.PC6

                                                            var newObj = {
                                                                gene: gene,
                                                                pc1: pc1,
                                                                pc2: pc2,
                                                                pc3: pc3,
                                                                pc4: pc4,
                                                                pc5: pc5,
                                                                pc6: pc6
                                                            };
                                                            heatmap_data.push(newObj);
                                                        })
                                                        // Display the newData array
                                                        console.log("PCA, first try ", pca_data);
                                                        pca(pca_data);
                                                        heatmap(heatmap_data);

                                                    })





                                            })
                                            // DEG(data_copy_pval,parsedLogFC,old_p_adj)
                                            // var req = ocpu.call("enrichment", {
                                            //     data: data_copy
                                            //     }, function (session) {

                                            // })
                                        });


                                })
                            } else if (chosen_statistic == 'limma') {

                                console.log(dataC_copy)
                                console.log(dataN_copy)

                                var req = ocpu.call("limmaDE", {
                                    dataC: dataC_copy,  // Pass your processed case data
                                    dataN: dataN_copy   // Pass your processed normal data
                                }, function (session) {
                                    var filteredDataURL = session.loc + "/R/.val/json";
                                    //console.log(session);
                                    // Fetch the filtered data from the URL
                                    fetch(filteredDataURL)
                                        .then(response => response.json())
                                        .then(data => {
                                            console.log(session);
                                            // Convert pval_adj values back to numbers if needed
                                            data.forEach(entry => {
                                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                                            });

                                            // Rename '_row' to 'Gene'
                                            data.forEach(entry => {
                                                if (entry.hasOwnProperty('_row')) {
                                                    entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                                    delete entry._row; // Remove '_row' property
                                                }
                                            });

                                            old_p_adj = data
                                            old_p_adj.sort((a, b) => {
                                                if (a.Gene < b.Gene) {
                                                    return -1;
                                                }
                                                if (a.Gene > b.Gene) {
                                                    return 1;
                                                }
                                                return 0;
                                            });

                                            const ind = old_p_adj.reduce((result, entry, index) => {

                                                if (entry.pval_adj > threshold) {
                                                    result.push(index);
                                                }
                                                return result;
                                            }, []);

                                            console.log(old_p_adj)
                                            console.log(ind)

                                            console.log("geni tolti dal primo filtering del pval", ind.length)

                                            if (ind.length > 0) {

                                                //console.log(parsedLogFC.length)

                                                // Remove entries corresponding to ind from dataN

                                                // Remove entries corresponding to ind from dataN
                                                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                                // Remove entries corresponding to ind from dataN
                                                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                                                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                                console.log("geni rimamenti dal primo filtering", data_copy.length)

                                                // Remove entries corresponding to ind from logFC
                                                parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                                parsedLogFC_pval = parsedLogFC
                                                console.log(log_thr_fc)
                                                console.log(parsedLogFC_origin1)
                                                console.log(old_p_adj)

                                                if (parsedLogFC.length == 0) {
                                                    alert("No deg found!")
                                                }

                                                console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                                var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                                console.log(sortedLogFC)

                                                var mostUpregulatedGene = sortedLogFC[0];

                                                var secondMostUpregulatedGene = sortedLogFC[1];

                                                var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                                console.log(mostUpregulatedGene)

                                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                                                //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                                                //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                                                selectedGeneData.push(mostUpregulatedGeneName)
                                                selectedGeneData.push(mostDownregulatedGeneName)

                                                // Find the select element
                                                var selectElement = document.getElementById("selectButton");

                                                // Clear existing options
                                                selectElement.innerHTML = "";

                                                // Add the new options dynamically
                                                var option1 = document.createElement("option");
                                                option1.value = mostUpregulatedGene.Gene;
                                                option1.text = `Most Upregulated (${mostUpregulatedGene.Gene})`;
                                                option1.selected = true;
                                                selectElement.appendChild(option1);

                                                var option2 = document.createElement("option");
                                                option2.value = mostDownregulatedGene.Gene;
                                                option2.text = `Most Downregulated (${mostDownregulatedGene.Gene})`;
                                                selectElement.appendChild(option2);


                                                // updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)

                                                dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)
                                                console.log(dataN_copy_pval[0])

                                                updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                                                updateCounter()

                                                scatter.selectAll("circle")
                                                    .filter(circleData => circleData.Gene === mostUpregulatedGeneName || circleData.Gene === mostDownregulatedGeneName)
                                                    .style("fill", d => {
                                                        // Check if logFC is greater than or equal to the threshold
                                                        return "green";

                                                    })
                                                    .classed('pulse', true);

                                                // Function to handle checkbox change event
                                                function handleCheckboxChange(event) {
                                                    var isChecked = event.target.checked;
                                                    var category = event.target.value;

                                                    if (isChecked) {
                                                        // Add category to first_dims array
                                                        first_dims.unshift(category);
                                                    } else {
                                                        // Remove category from first_dims array
                                                        var index = first_dims.indexOf(category);
                                                        if (index !== -1) {
                                                            first_dims.splice(index, 1);
                                                        }
                                                    }

                                                    // Log the updated first_dims array
                                                    console.log("Updated first_dims:", first_dims);

                                                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                                }


                                                var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);

                                                // Get the container element
                                                var checkboxContainer = document.getElementById("checkboxContainer");

                                                // Initialize a variable to count the number of checkboxes added to the current row
                                                var checkboxesInRow = 0;

                                                // Iterate through metadataCategories to create checkboxes
                                                metadataCategories.forEach(function (category) {
                                                    // Create a checkbox element
                                                    var checkbox = document.createElement("input");
                                                    checkbox.type = "checkbox";
                                                    checkbox.value = category;
                                                    checkbox.id = "checkbox_" + category; // Set a unique ID for each checkbox

                                                    // Set the checked attribute based on condition
                                                    if (category === selectedRowName) {
                                                        checkbox.checked = true;
                                                    }

                                                    // Create a label for the checkbox
                                                    var label = document.createElement("label");
                                                    label.htmlFor = checkbox.id;
                                                    label.appendChild(document.createTextNode(category));

                                                    // Add event listener to the checkbox to handle change event
                                                    checkbox.addEventListener("change", handleCheckboxChange);

                                                    // Append the checkbox and label to the container element
                                                    checkboxContainer.appendChild(checkbox);
                                                    checkboxContainer.appendChild(label);

                                                    // Increment the count of checkboxes in the row
                                                    checkboxesInRow++;

                                                    // Add a line break after every two checkboxes
                                                    if (checkboxesInRow % 2 === 0) {
                                                        checkboxContainer.appendChild(document.createElement("br"));
                                                    }
                                                });

                                                // Initialize a variable to count the number of radio buttons added to the current row
                                                var radioButtonsInRow = 0;
                                                // Get the container element
                                                var radioBoxContainer = document.getElementById("radioBoxContainer");

                                                // Function to handle radio button change event
                                                function handleRadioButtonChange(event) {
                                                    // Update selectedVariable with the value of the selected radio button
                                                    selectedVariable = event.target.value;

                                                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                                                }


                                                // Iterate through metadataCategories to create radio buttons
                                                // Count the unique values in the metadata category
                                                function countUniqueValues(cat, j) {
                                                    var uniqueValues = new Set(); // Use a Set to store unique values
                                                    // Iterate through metadata categories to create y scales
                                                    metadataCategories.forEach((category, i) => {
                                                        if (j === i) {
                                                            var values = Object.values(metadata[i]); // Extract values for the current category
                                                            values.shift(); // Remove the first value (Sample_source_name_ch1)
                                                            var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                                            console.log("Values for", category, ":", uniqueValues);
                                                            return uniqueValues.length; // Return the size of the Set, which is the count of unique values
                                                        }
                                                    });
                                                }

                                                // Iterate through metadataCategories to create radio buttons
                                                metadataCategories.forEach(function (category, i) {
                                                    // Check if the category has more than 9 unique values
                                                    var values = Object.values(metadata[i]); // Extract values for the current category
                                                    values.shift(); // Remove the first value (Sample_source_name_ch1)
                                                    var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                                    console.log("Values for", category, ":", uniqueValues);
                                                    console.log(uniqueValues.length);
                                                    if (uniqueValues.length >= 9) return

                                                    // Create a radio button element
                                                    var radioButton = document.createElement("input");
                                                    radioButton.type = "radio";
                                                    radioButton.name = "radioButtonGroup"; // Set the same name for all radio buttons in the group
                                                    radioButton.value = category;
                                                    radioButton.id = "radioButton_" + category; // Set a unique ID for each radio button

                                                    // Set the checked attribute based on condition
                                                    if (category === selectedRowName) {
                                                        radioButton.checked = true;
                                                    }

                                                    // Create a label for the radio button
                                                    var label = document.createElement("label");
                                                    label.htmlFor = radioButton.id;
                                                    label.appendChild(document.createTextNode(category));

                                                    // Add event listener to the radio button to handle change event
                                                    radioButton.addEventListener("change", handleRadioButtonChange);

                                                    // Append the radio button and label to the container element
                                                    radioBoxContainer.appendChild(radioButton);
                                                    radioBoxContainer.appendChild(label);

                                                    // Increment the count of radio buttons in the row
                                                    radioButtonsInRow++;

                                                    // Add a line break after every two radio buttons
                                                    if (radioButtonsInRow % 2 === 0) {
                                                        radioBoxContainer.appendChild(document.createElement("br"));
                                                    }
                                                });

                                                document.getElementById("checkboxContainer").style.visibility = "visible";
                                                document.getElementById("radioBoxContainer").style.visibility = "visible";


                                            }
                                            console.log(dataN_copy.length)
                                            var pc1Values = [];
                                            var pc2Values = [];
                                            var groupValues = [];
                                            console.log(data_copy_pval)
                                            var req = ocpu.call("pca", {
                                                data: data_copy_pval,
                                                dataN: dataN_copy_pval,
                                                dataC: dataC_copy_pval
                                            }, function (session) {
                                                var filteredDataURL = session.loc + "/R/.val/json";
                                                //console.log(session);
                                                // Fetch the filtered data from the URL
                                                fetch(filteredDataURL)
                                                    .then(response => response.json())
                                                    .then(data => {
                                                        json = data
                                                        console.log(filteredDataURL)
                                                        console.log(json)

                                                        var pc1Key = "PC1";
                                                        var pc2Key = "PC2";
                                                        var groupKey = "Group";

                                                        // Arrays to store PC1 and PC2 values


                                                        // Iterate over each object in the JSON array
                                                        json.scores_df.forEach(function (obj) {
                                                            // Push PC1, PC2, and Group values to the arrays
                                                            pc1Values.push(obj[pc1Key]);
                                                            pc2Values.push(obj[pc2Key]);
                                                            groupValues.push(obj[groupKey]);
                                                        });
                                                        // console.log(pc1Values)

                                                        // Extract metadata categories from the values of the first column
                                                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                                        console.log("Metadata categories:", metadataCategories);

                                                        // Initialize pca_data array
                                                        pca_data = [];

                                                        // Iterate over each object in the JSON array
                                                        json.scores_df.forEach(function (obj) {
                                                            // Retrieve additional data from metadata based on _row
                                                            var gsm = obj._row;
                                                            var group = obj.Group;
                                                            var pc1 = obj.PC1;
                                                            var pc2 = obj.PC2;

                                                            // Create an object with the required fields
                                                            var newObj = {
                                                                GSM: gsm,
                                                                group: group,
                                                                pc1: pc1,
                                                                pc2: pc2
                                                            };

                                                            // Add metadata values for each category to the newObj
                                                            metadataCategories.forEach((category, index) => {
                                                                newObj[category] = metadata[index][gsm];
                                                            });

                                                            // Push the new object to the pca_data array
                                                            pca_data.push(newObj);
                                                        });

                                                        heatmap_data = []
                                                        json.scores_var.forEach(function (obj) {
                                                            // Push PC1, PC2, and Group values to the arrays
                                                            var gene = obj._row
                                                            var pc1 = obj.PC1
                                                            var pc2 = obj.PC2
                                                            var pc3 = obj.PC3
                                                            var pc4 = obj.PC4
                                                            var pc5 = obj.PC5
                                                            var pc6 = obj.PC6

                                                            var newObj = {
                                                                gene: gene,
                                                                pc1: pc1,
                                                                pc2: pc2,
                                                                pc3: pc3,
                                                                pc4: pc4,
                                                                pc5: pc5,
                                                                pc6: pc6
                                                            };
                                                            heatmap_data.push(newObj);
                                                        })
                                                        // Display the newData array
                                                        console.log("PCA, first try ", pca_data);


                                                        pca(pca_data);
                                                        heatmap(heatmap_data);

                                                    })





                                            })
                                            // DEG(data_copy_pval,parsedLogFC,old_p_adj)
                                            // var req = ocpu.call("enrichment", {
                                            //     data: data_copy
                                            //     }, function (session) {

                                            // })
                                        });


                                })
                            } else if (chosen_statistic == 'deseq2') {
                                console.log(dataC_copy)
                                console.log(dataN_copy)

                                // Logarithmic transformation for dataN, dataC, and data1
                                var dataN_or = dataN_original_cpy.map(obj => {
                                    var newObj = {};
                                    for (var key in obj) {
                                        if (key !== "gene") {
                                            newObj[key] = Math.pow((obj[key]), 2) + 1;
                                        }
                                    }
                                    newObj["gene"] = obj["gene"];
                                    return newObj;
                                });

                                var dataC_or = dataC_original_cpy.map(obj => {
                                    var newObj = {};
                                    for (var key in obj) {
                                        if (key !== "gene") {
                                            newObj[key] = Math.pow((obj[key]), 2) + 1;
                                        }
                                    }
                                    newObj["gene"] = obj["gene"];
                                    return newObj;
                                });

                                console.log(dataC_or)
                                console.log(dataN_or)

                                var req = ocpu.call("deseq2DE", {
                                    dataC: dataC_or,  // Pass your processed case data
                                    dataN: dataN_or   // Pass your processed normal data
                                }, function (session) {
                                    var filteredDataURL = session.loc + "/R/.val/json";
                                    //console.log(session);
                                    // Fetch the filtered data from the URL
                                    fetch(filteredDataURL)
                                        .then(response => response.json())
                                        .then(data => {
                                            console.log(session);
                                            // Convert pval_adj values back to numbers if needed
                                            data.forEach(entry => {
                                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                                            });

                                            // Rename '_row' to 'Gene'
                                            data.forEach(entry => {
                                                if (entry.hasOwnProperty('_row')) {
                                                    entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                                    delete entry._row; // Remove '_row' property
                                                }
                                            });

                                            old_p_adj = data
                                            old_p_adj.sort((a, b) => {
                                                if (a.Gene < b.Gene) {
                                                    return -1;
                                                }
                                                if (a.Gene > b.Gene) {
                                                    return 1;
                                                }
                                                return 0;
                                            });

                                            const ind = old_p_adj.reduce((result, entry, index) => {

                                                if (entry.pval_adj > threshold) {
                                                    result.push(index);
                                                }
                                                return result;
                                            }, []);

                                            console.log(old_p_adj)
                                            console.log(ind)

                                            console.log("geni tolti dal primo filtering del pval", ind.length)

                                            if (ind.length > 0) {

                                                //console.log(parsedLogFC.length)

                                                // Remove entries corresponding to ind from dataN

                                                // Remove entries corresponding to ind from dataN
                                                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                                // Remove entries corresponding to ind from dataN
                                                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));

                                                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                                console.log("geni rimamenti dal primo filtering", data_copy.length)

                                                // Remove entries corresponding to ind from logFC
                                                parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                                parsedLogFC_pval = parsedLogFC
                                                console.log(log_thr_fc)
                                                console.log(parsedLogFC_origin1)
                                                console.log(old_p_adj)

                                                if (parsedLogFC.length == 0) {
                                                    alert("No deg found!")
                                                }

                                                console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                                var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                                console.log(sortedLogFC)

                                                var mostUpregulatedGene = sortedLogFC[0];

                                                var secondMostUpregulatedGene = sortedLogFC[1];

                                                var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                                console.log(mostUpregulatedGene)

                                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                                                //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                                                //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                                                selectedGeneData.push(mostUpregulatedGeneName)
                                                selectedGeneData.push(mostDownregulatedGeneName)

                                                // Find the select element
                                                var selectElement = document.getElementById("selectButton");

                                                // Clear existing options
                                                selectElement.innerHTML = "";

                                                // Add the new options dynamically
                                                var option1 = document.createElement("option");
                                                option1.value = mostUpregulatedGene.Gene;
                                                option1.text = `Most Upregulated (${mostUpregulatedGene.Gene})`;
                                                option1.selected = true;
                                                selectElement.appendChild(option1);

                                                var option2 = document.createElement("option");
                                                option2.value = mostDownregulatedGene.Gene;
                                                option2.text = `Most Downregulated (${mostDownregulatedGene.Gene})`;
                                                selectElement.appendChild(option2);


                                                // updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)

                                                dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)

                                                console.log(dataN_copy_pval[0])

                                                updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                                                updateCounter()

                                                scatter.selectAll("circle")
                                                    .filter(circleData => circleData.Gene === mostUpregulatedGeneName || circleData.Gene === mostDownregulatedGeneName)
                                                    .style("fill", d => {
                                                        // Check if logFC is greater than or equal to the threshold
                                                        return "green";

                                                    })
                                                    .classed('pulse', true);

                                                // Function to handle checkbox change event
                                                function handleCheckboxChange(event) {
                                                    var isChecked = event.target.checked;
                                                    var category = event.target.value;

                                                    if (isChecked) {
                                                        // Add category to first_dims array
                                                        first_dims.unshift(category);
                                                    } else {
                                                        // Remove category from first_dims array
                                                        var index = first_dims.indexOf(category);
                                                        if (index !== -1) {
                                                            first_dims.splice(index, 1);
                                                        }
                                                    }

                                                    // Log the updated first_dims array
                                                    console.log("Updated first_dims:", first_dims);

                                                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                                }


                                                var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);

                                                // Get the container element
                                                var checkboxContainer = document.getElementById("checkboxContainer");

                                                // Initialize a variable to count the number of checkboxes added to the current row
                                                var checkboxesInRow = 0;

                                                // Iterate through metadataCategories to create checkboxes
                                                metadataCategories.forEach(function (category) {
                                                    // Create a checkbox element
                                                    var checkbox = document.createElement("input");
                                                    checkbox.type = "checkbox";
                                                    checkbox.value = category;
                                                    checkbox.id = "checkbox_" + category; // Set a unique ID for each checkbox

                                                    // Set the checked attribute based on condition
                                                    if (category === selectedRowName) {
                                                        checkbox.checked = true;
                                                    }

                                                    // Create a label for the checkbox
                                                    var label = document.createElement("label");
                                                    label.htmlFor = checkbox.id;
                                                    label.appendChild(document.createTextNode(category));

                                                    // Add event listener to the checkbox to handle change event
                                                    checkbox.addEventListener("change", handleCheckboxChange);

                                                    // Append the checkbox and label to the container element
                                                    checkboxContainer.appendChild(checkbox);
                                                    checkboxContainer.appendChild(label);

                                                    // Increment the count of checkboxes in the row
                                                    checkboxesInRow++;

                                                    // Add a line break after every two checkboxes
                                                    if (checkboxesInRow % 2 === 0) {
                                                        checkboxContainer.appendChild(document.createElement("br"));
                                                    }
                                                });

                                                // Initialize a variable to count the number of radio buttons added to the current row
                                                var radioButtonsInRow = 0;
                                                // Get the container element
                                                var radioBoxContainer = document.getElementById("radioBoxContainer");

                                                // Function to handle radio button change event
                                                function handleRadioButtonChange(event) {
                                                    // Update selectedVariable with the value of the selected radio button
                                                    selectedVariable = event.target.value;

                                                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                                                }


                                                // Iterate through metadataCategories to create radio buttons
                                                // Count the unique values in the metadata category
                                                function countUniqueValues(cat, j) {
                                                    var uniqueValues = new Set(); // Use a Set to store unique values
                                                    // Iterate through metadata categories to create y scales
                                                    metadataCategories.forEach((category, i) => {
                                                        if (j === i) {
                                                            var values = Object.values(metadata[i]); // Extract values for the current category
                                                            values.shift(); // Remove the first value (Sample_source_name_ch1)
                                                            var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                                            console.log("Values for", category, ":", uniqueValues);
                                                            return uniqueValues.length; // Return the size of the Set, which is the count of unique values
                                                        }
                                                    });
                                                }

                                                // Iterate through metadataCategories to create radio buttons
                                                metadataCategories.forEach(function (category, i) {
                                                    // Check if the category has more than 9 unique values
                                                    var values = Object.values(metadata[i]); // Extract values for the current category
                                                    values.shift(); // Remove the first value (Sample_source_name_ch1)
                                                    var uniqueValues = [...new Set(values)]; // Filter out duplicate
                                                    console.log("Values for", category, ":", uniqueValues);
                                                    console.log(uniqueValues.length);
                                                    if (uniqueValues.length >= 9) return

                                                    // Create a radio button element
                                                    var radioButton = document.createElement("input");
                                                    radioButton.type = "radio";
                                                    radioButton.name = "radioButtonGroup"; // Set the same name for all radio buttons in the group
                                                    radioButton.value = category;
                                                    radioButton.id = "radioButton_" + category; // Set a unique ID for each radio button

                                                    // Set the checked attribute based on condition
                                                    if (category === selectedRowName) {
                                                        radioButton.checked = true;
                                                    }

                                                    // Create a label for the radio button
                                                    var label = document.createElement("label");
                                                    label.htmlFor = radioButton.id;
                                                    label.appendChild(document.createTextNode(category));

                                                    // Add event listener to the radio button to handle change event
                                                    radioButton.addEventListener("change", handleRadioButtonChange);

                                                    // Append the radio button and label to the container element
                                                    radioBoxContainer.appendChild(radioButton);
                                                    radioBoxContainer.appendChild(label);

                                                    // Increment the count of radio buttons in the row
                                                    radioButtonsInRow++;

                                                    // Add a line break after every two radio buttons
                                                    if (radioButtonsInRow % 2 === 0) {
                                                        radioBoxContainer.appendChild(document.createElement("br"));
                                                    }
                                                });

                                                document.getElementById("checkboxContainer").style.visibility = "visible";
                                                document.getElementById("radioBoxContainer").style.visibility = "visible";


                                            }
                                            console.log(dataN_copy.length)
                                            var pc1Values = [];
                                            var pc2Values = [];
                                            var groupValues = [];
                                            console.log(data_copy_pval)
                                            var req = ocpu.call("pca", {
                                                data: data_copy_pval,
                                                dataN: dataN_copy_pval,
                                                dataC: dataC_copy_pval
                                            }, function (session) {
                                                var filteredDataURL = session.loc + "/R/.val/json";
                                                //console.log(session);
                                                // Fetch the filtered data from the URL
                                                fetch(filteredDataURL)
                                                    .then(response => response.json())
                                                    .then(data => {
                                                        json = data
                                                        console.log(filteredDataURL)
                                                        console.log(json)

                                                        var pc1Key = "PC1";
                                                        var pc2Key = "PC2";
                                                        var groupKey = "Group";

                                                        // Arrays to store PC1 and PC2 values


                                                        // Iterate over each object in the JSON array
                                                        json.scores_df.forEach(function (obj) {
                                                            // Push PC1, PC2, and Group values to the arrays
                                                            pc1Values.push(obj[pc1Key]);
                                                            pc2Values.push(obj[pc2Key]);
                                                            groupValues.push(obj[groupKey]);
                                                        });
                                                        // console.log(pc1Values)

                                                        // Extract metadata categories from the values of the first column
                                                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                                        console.log("Metadata categories:", metadataCategories);

                                                        // Initialize pca_data array
                                                        pca_data = [];

                                                        // Iterate over each object in the JSON array
                                                        json.scores_df.forEach(function (obj) {
                                                            // Retrieve additional data from metadata based on _row
                                                            var gsm = obj._row;
                                                            var group = obj.Group;
                                                            var pc1 = obj.PC1;
                                                            var pc2 = obj.PC2;

                                                            // Create an object with the required fields
                                                            var newObj = {
                                                                GSM: gsm,
                                                                group: group,
                                                                pc1: pc1,
                                                                pc2: pc2
                                                            };

                                                            // Add metadata values for each category to the newObj
                                                            metadataCategories.forEach((category, index) => {
                                                                newObj[category] = metadata[index][gsm];
                                                            });

                                                            // Push the new object to the pca_data array
                                                            pca_data.push(newObj);
                                                        });

                                                        heatmap_data = []
                                                        json.scores_var.forEach(function (obj) {
                                                            // Push PC1, PC2, and Group values to the arrays
                                                            var gene = obj._row
                                                            var pc1 = obj.PC1
                                                            var pc2 = obj.PC2
                                                            var pc3 = obj.PC3
                                                            var pc4 = obj.PC4
                                                            var pc5 = obj.PC5
                                                            var pc6 = obj.PC6

                                                            var newObj = {
                                                                gene: gene,
                                                                pc1: pc1,
                                                                pc2: pc2,
                                                                pc3: pc3,
                                                                pc4: pc4,
                                                                pc5: pc5,
                                                                pc6: pc6
                                                            };
                                                            heatmap_data.push(newObj);
                                                        })
                                                        // Display the newData array
                                                        console.log("PCA, first try ", pca_data);


                                                        pca(pca_data);
                                                        heatmap(heatmap_data);

                                                    })





                                            })
                                            // DEG(data_copy_pval,parsedLogFC,old_p_adj)
                                            // var req = ocpu.call("enrichment", {
                                            //     data: data_copy
                                            //     }, function (session) {

                                            // })
                                        });


                                })
                            }


                            ///// DATI FILTRATI DAL PRIMO PVALUE, GIA' FILTRATI DAL PRIMO LOGFC, CHE ERANO GIA FILTRATI DA PRIMO IQR IN dataC_copy dataN_copy data_copy parsedLogFC ///////


                            // Calculate the quantile
                            log_thr_fc = Math.log2(thr_fc);
                        }
                        const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {

                            if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                result.push(index);
                            }
                            return result;
                        }, []);

                        // const geneCountDiv2 = document.getElementById('geneCount2');
                        // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;


                    });

            })

        }



        function DEG(data, logFC, pval_adj) {

            // console.log("DEG da modificare",data)
            // console.log("parsed log", logFC)
            // console.log("pval adj", pval_adj)

            // Create an empty array to store the final structure
            var result = [];

            // Iterate over logFC data
            for (var i = 0; i < logFC.length; i++) {
                var geneData = {
                    gene: logFC[i].Gene,
                    pval_adj: null, // Placeholder for pval_adj
                    logFC: logFC[i].logFC,
                    direction: logFC[i].logFC >= 0 ? 'UP' : 'DOWN'
                };

                // Find corresponding pval_adj for the current gene
                for (var j = 0; j < pval_adj.length; j++) {
                    if (pval_adj[j].Gene === logFC[i].Gene) {
                        geneData.pval_adj = pval_adj[j].pval_adj;
                        break; // Exit loop once found
                    }
                }

                // Push the geneData to the result array
                result.push(geneData);
            }

            // Log the final structure
            console.log(result);

            enrichment(result)

        }

        function enrichment(list) {
            var req = ocpu.call("enrichment", {
                data: list,
                direction: 'UP'
            }, function (session) {
                // Once the OpenCPU call is successful
                console.log(session);

                // Extract the JSON data URL from the session object
                var filteredDataURL = session.loc + "/R/.val/json";
                console.log(filteredDataURL);

                // Load the JSON data directly using d3.json()
                d3.json(filteredDataURL, function (data) {
                    // Process the data and create the dot plot
                    createDotPlot(data);
                });
            }).fail(function () {
                // Handle errors here
                console.log("Error: OpenCPU call failed.");
                // Show error message to the user
                showError("EnrichR takes too much to respond. Please try again!!");
                modal.style.display = "none";
                // Clear the content of the modal when it is closed
                var dotplotContainer = document.getElementById("dotplot");
                dotplotContainer.innerHTML = "";
            });

            var req = ocpu.call("enrichment", {
                data: list,
                direction: 'DOWN'
            }, function (session) {
                // Once the OpenCPU call is successful
                console.log(session);

                // Extract the JSON data URL from the session object
                var filteredDataURL = session.loc + "/R/.val/json";
                console.log(filteredDataURL);

                // Load the JSON data directly using d3.json()
                d3.json(filteredDataURL, function (data) {
                    // Process the data and create the dot plot
                    createDotPlot1(data);
                });
            }).fail(function () {
                // Handle errors here
                console.log("Error: OpenCPU call failed.");
                // Show error message to the user
                showError("EnrichR takes too much to respond. Please try again!!");
                modal.style.display = "none";
                // Clear the content of the modal when it is closed
                var dotplotContainer = document.getElementById("dotplot");
                dotplotContainer.innerHTML = "";
            });

            function showError(message) {
                // Display error message to the user
                alert(message); // You can use other methods to display the message, such as showing it in a modal or updating a specific HTML element
            }
        }


        function createDotPlot(data) {
            data_disgen = data.annotation_top
            var minValue = d3.min(data_disgen, function (d) { return d['Adjusted.P.value']; });
            var maxValue = d3.max(data_disgen, function (d) { return d['Adjusted.P.value']; });
            data_disgen.sort((a, b) => b.Gene_count - a.Gene_count);

            // Define a linear color scale from red to blue based on the calculated domain
            var colorScale = d3.scaleLinear()
                .domain([minValue, maxValue])
                .range(["red", "blue"]);

            var options = ["DisGenNet", "Bio. Process", "Molecular function", "KEGG"]

            // Create the select element
            var selectDot = d3.select("#select_dot").append('select');

            // Bind the data to options and enter the new options
            selectDot.selectAll('myOptions') // Next 4 lines add 6 options = 6 colors
                .data(options)
                .enter()
                .append('option')
                .text(function (d) { return d; }) // text showed in the menu
                .attr("value", function (d) { return d; }) // corresponding value returned by the button

            // Define dimensions and margins
            var margin = { top: 20, right: 120, bottom: 50, left: 220 },
                width = 650 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // Append SVG to the dotplot div
            var svg = d3.select("#dotplot")
                .html("")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Define scales
            var x = d3.scaleLinear()
                .domain([0, d3.max(data_disgen, function (d) { return d.Gene_count; })])
                .range([0, width]);

            var y = d3.scaleBand()
                .domain(data_disgen.map(function (d) { return d.Term; }))
                .range([0, height])
                .padding(0.1);


            // Define axes
            var xAxis = svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x)
                    .tickSize(-height) // Add gridlines along the x-axis
                );

            var yAxis = svg.append("g")
                .attr("class", "y axis")
                .call(d3.axisLeft(y)
                    .tickSize(-width) // Add gridlines along the y-axis
                );

            // Add title
            var title = svg.append("text")
                .attr("x", width / 2)
                .attr("y", -3)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("UP Genes DisGenNet ")
                .style("fill", "white");


            // Add label for x-axis
            svg.append("text")
                .attr("class", "x-axis-label")
                .attr("transform", "translate(" + (width / 2) + " ," + (height + margin.top + 20) + ")")
                .style("text-anchor", "middle")
                .style("fill", "white") // Set text color to white
                .text("Gene Count");



            // Style axes and gridlines
            svg.selectAll(".axis line")
                .style("stroke", "white");

            svg.selectAll(".axis path")
                .style("stroke", "white");

            yAxis.selectAll(".tick line")
                .style("fill", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            xAxis.selectAll(".tick line")
                .style("fill", "white");

            xAxis.selectAll("text")
                .style("fill", "white");

            // Sort the data array based on gene count in descending order

            console.log(data)
            // Define a scaling factor that the user can adjust
            var scalingFactor = 20; // Default scaling factor

            // Add an input element for the user to adjust the scaling factor
            var scalingFactorInput = d3.select("#slider_dot_polot")
                .html("")
                .append("input")
                .attr("type", "range")
                .attr("min", 0) // Minimum scaling factor
                .attr("max", 100) // Maximum scaling factor
                .attr("value", scalingFactor) // Default scaling factor
                .on("input", function () {
                    scalingFactor = +this.value;
                    updateDots(); // Update the dots with the new scaling factor
                });

            // Function to update the dots with the new scaling factor
            function updateDots() {
                svg.selectAll(".dot")
                    .attr("r", function (d) { return d.Gene_ratio * scalingFactor; }); // Adjust radius based on scaling factor
            }

            // Add dots with tooltips
            var dot = svg.selectAll(".dot")
                .data(data_disgen)
                .enter().append("circle")
                .attr("class", "dot")
                .attr("cx", function (d) { return x(d.Gene_count); })
                .attr("cy", function (d) { return y(d.Term) + y.bandwidth() / 2; })
                .attr("r", function (d) { return d.Gene_ratio * scalingFactor; }) // Adjust radius as per Gene_ratio and scaling factor
                .style("fill", function (d) {
                    // Access the Adjusted.P.value property using bracket notation
                    adjustedPValue = d['Adjusted.P.value'];

                    // Interpolate color using the color scale
                    return colorScale(adjustedPValue);
                })
                .on("mouseover", function (d) {
                    // Show tooltip on mouseover
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html("Gene Ratio: " + d.Gene_ratio)
                        .style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 28) + "px")
                        .style("color", "white");

                    // Add black stroke on mouseover
                    d3.select(this).style("stroke", "black")
                        .style("stroke-width", "2px");
                })
                .on("mouseout", function (d) {
                    // Hide tooltip on mouseout
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);

                    // Remove black stroke on mouseout
                    d3.select(this).style("stroke", "none");
                });

            // Append tooltip to the body
            var tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);




            // Define the legend dimensions and margins
            var legendWidth = 20,
                legendHeight = 150,
                legendMargin = { top: 20, right: 10, bottom: 30, left: 10 };

            // Append the legend SVG
            var legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (width + legendMargin.left + legendMargin.right) + "," + legendMargin.top + ")");

            // Append a defs (for definition) element to your SVG
            var defs = legend.append("defs");

            // Append a linearGradient element to the defs and give it a unique id
            var linearGradient = defs.append("linearGradient")
                .attr("id", "linear-gradient1")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%");

            // Add color stops to the linear gradient
            linearGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", "blue");

            linearGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "red");

            // Draw the rectangle and fill with the linear gradient
            legend.append("rect")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .style("fill", "url(#linear-gradient1)");

            console.log(minValue, maxValue)
            // Define the scale for the legend axis
            var legendScale = d3.scaleLinear()
                .domain([minValue, maxValue])
                .range([legendHeight, 0]);

            // Define the scale for the legend axis
            var legendScale = d3.scaleLinear()
                .domain([minValue, maxValue])
                .range([legendHeight, 0]);

            // Generate tick values for the legend axis
            var tickValues = [minValue, maxValue];

            // Append and style the legend axis
            var legendAxis = d3.axisRight(legendScale)
                .tickValues(tickValues)
                .tickFormat(d3.format(".2e")); // Preserve scientific notation with two decimal places


            var axis = legend.append("g")
                .attr("class", "legend-axis")
                .attr("transform", "translate(" + (legendWidth + 2) + ",0)") // Adjust position as needed
                .call(legendAxis);



            // Apply style to axis ticks to make them white
            axis.selectAll("text").style("fill", "white").style("font-size", "13px")
            axis.selectAll("line").style("stroke", "white");

            // Remove the domain path
            axis.select(".domain").remove();



            function update(selectedGroup, data) {
                var minValue;
                var maxValue;
                // Adjust data based on selected group
                if (selectedGroup == 'DisGenNet') {
                    data = data.annotation_top;
                    data.sort((a, b) => b.Gene_count - a.Gene_count);
                    minValue = d3.min(data, function (d) { return d['Adjusted.P.value']; });
                    maxValue = d3.max(data, function (d) { return d['Adjusted.P.value']; });
                } else if (selectedGroup == 'Bio. Process') {
                    data = data.annotation_top1;
                    data.sort((a, b) => b.Gene_count - a.Gene_count);
                    minValue = d3.min(data, function (d) { return d['Adjusted.P.value']; });
                    maxValue = d3.max(data, function (d) { return d['Adjusted.P.value']; });
                } else if (selectedGroup == 'Molecular function') {
                    data = data.annotation_top2;
                    data.sort((a, b) => b.Gene_count - a.Gene_count);
                    minValue = d3.min(data, function (d) { return d['Adjusted.P.value']; });
                    maxValue = d3.max(data, function (d) { return d['Adjusted.P.value']; });
                }
                else if (selectedGroup == 'KEGG') {
                    data = data.annotation_top3;
                    data.sort((a, b) => b.Gene_count - a.Gene_count);
                    minValue = d3.min(data, function (d) { return d['Adjusted.P.value']; });
                    maxValue = d3.max(data, function (d) { return d['Adjusted.P.value']; });
                }
                title.text("UP Genes " + selectedGroup);



                // Define a scaling factor that the user can adjust
                var scalingFactor = 20; // Default scaling factor

                // Add an input element for the user to adjust the scaling factor
                var scalingFactorInput = d3.select("#slider_dot_polot")
                    .html("")
                    .append("input")
                    .attr("type", "range")
                    .attr("min", 0) // Minimum scaling factor
                    .attr("max", 100) // Maximum scaling factor
                    .attr("value", scalingFactor) // Default scaling factor
                    .on("input", function () {
                        scalingFactor = +this.value;
                        updateDots(); // Update the dots with the new scaling factor
                    });

                var colorScale = d3.scaleLinear()
                    .domain([minValue, maxValue])
                    .range(["red", "blue"]);

                // Update x scale
                var x = d3.scaleLinear()
                    .domain([0, d3.max(data, function (d) { return d.Gene_count; })])
                    .range([0, width]);

                // Update y scale
                var y = d3.scaleBand()
                    .domain(data.map(function (d) { return d.Term; }))
                    .range([0, height])
                    .padding(0.1);

                // Update x-axis
                xAxis.transition()
                    .duration(1000)
                    .call(d3.axisBottom(x)
                        .tickSize(-height) // Add gridlines along the x-axis
                    );

                // Update y-axis
                yAxis.transition()
                    .duration(1000)
                    .call(d3.axisLeft(y)
                        .tickSize(-width) // Add gridlines along the y-axis
                    );

                // Style axes and gridlines
                svg.selectAll(".axis line")
                    .style("stroke", "white");

                svg.selectAll(".axis path")
                    .style("stroke", "white");

                yAxis.selectAll(".tick line")
                    .style("fill", "white");

                yAxis.selectAll("text")
                    .style("fill", "white");

                xAxis.selectAll(".tick line")
                    .style("fill", "white");

                xAxis.selectAll("text")
                    .style("fill", "white");


                // Update dots
                var dots = svg.selectAll("circle")
                    .data(data);

                // Remove existing circles
                dots.exit().remove();

                // Append new circles for any new data points
                dots.enter().append("circle")
                    .transition()
                    .duration(1000)
                    .attr("cx", function (d) { return x(d.Gene_count); })
                    .attr("cy", function (d) { return y(d.Term) + y.bandwidth() / 2; })
                    .attr("r", function (d) { return d.Gene_ratio * scalingFactor; }) // Adjust radius as per Gene_ratio and scaling factor
                    .style("fill", function (d) {
                        // Access the Adjusted.P.value property using bracket notation
                        adjustedPValue = d['Adjusted.P.value'];

                        // Interpolate color using the color scale
                        return colorScale(adjustedPValue);
                    });

                // Transition existing circles to new positions
                dots.transition()
                    .duration(1000)
                    .attr("cx", function (d) { return x(d.Gene_count); })
                    .attr("cy", function (d) { return y(d.Term) + y.bandwidth() / 2; })
                    .attr("r", function (d) { return d.Gene_ratio * scalingFactor; }) // Adjust radius as per Gene_ratio and updated scaling factor
                    .style("fill", function (d) {
                        // Access the Adjusted.P.value property using bracket notation
                        adjustedPValue = d['Adjusted.P.value'];

                        // Interpolate color using the color scale
                        return colorScale(adjustedPValue);
                    });


                // Update legend
                legendScale.domain([d3.min(data, function (d) { return d['Adjusted.P.value']; }), d3.max(data, function (d) { return d['Adjusted.P.value']; })]);
                var tickValues = [d3.min(data, function (d) { return d['Adjusted.P.value']; }), d3.max(data, function (d) { return d['Adjusted.P.value']; })];
                legendAxis.tickValues(tickValues);
                axis.call(legendAxis);

                // Apply style to axis ticks to make them white
                axis.selectAll("text").style("fill", "white").style("font-size", "13px");
                axis.selectAll("line").style("stroke", "white");

                // Remove the domain path
                axis.select(".domain").remove();
                // Function to update the dots with the new scaling factor
                function updateDots() {
                    svg.selectAll("circle")
                        .attr("r", function (d) { return d.Gene_ratio * scalingFactor; }); // Adjust radius based on scaling factor
                }
            }

            // Define the event handler for the change event
            selectDot.on("change", function () {
                var selectedOption = d3.select(this).property("value");
                update(selectedOption, data);
            });
        }

        function createDotPlot1(data) {
            data_disgen = data.annotation_top
            var minValue = d3.min(data_disgen, function (d) { return d['Adjusted.P.value']; });
            var maxValue = d3.max(data_disgen, function (d) { return d['Adjusted.P.value']; });
            data_disgen.sort((a, b) => b.Gene_count - a.Gene_count);

            // Define a linear color scale from red to blue based on the calculated domain
            var colorScale = d3.scaleLinear()
                .domain([minValue, maxValue])
                .range(["red", "blue"]);

            var options = ["DisGenNet", "Bio. Process", "Molecular function", "KEGG"]

            // Create the select element
            var selectDot = d3.select("#select_dot1").append('select');

            // Bind the data to options and enter the new options
            selectDot.selectAll('myOptions') // Next 4 lines add 6 options = 6 colors
                .data(options)
                .enter()
                .append('option')
                .text(function (d) { return d; }) // text showed in the menu
                .attr("value", function (d) { return d; }) // corresponding value returned by the button

            // Define dimensions and margins
            var margin = { top: 20, right: 120, bottom: 50, left: 220 },
                width = 650 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // Append SVG to the dotplot div
            var svg = d3.select("#dotplot1")
                .html("")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Define scales
            var x = d3.scaleLinear()
                .domain([0, d3.max(data_disgen, function (d) { return d.Gene_count; })])
                .range([0, width]);

            var y = d3.scaleBand()
                .domain(data_disgen.map(function (d) { return d.Term; }))
                .range([0, height])
                .padding(0.1);


            // Define axes
            var xAxis = svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x)
                    .tickSize(-height) // Add gridlines along the x-axis
                );

            var yAxis = svg.append("g")
                .attr("class", "y axis")
                .call(d3.axisLeft(y)
                    .tickSize(-width) // Add gridlines along the y-axis
                );

            // Add title
            var title = svg.append("text")
                .attr("x", width / 2)
                .attr("y", -3)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("DOWN Genes DisGenNet ")
                .style("fill", "white");


            // Add label for x-axis
            svg.append("text")
                .attr("class", "x-axis-label")
                .attr("transform", "translate(" + (width / 2) + " ," + (height + margin.top + 20) + ")")
                .style("text-anchor", "middle")
                .style("fill", "white") // Set text color to white
                .text("Gene Count");



            // Style axes and gridlines
            svg.selectAll(".axis line")
                .style("stroke", "white");

            svg.selectAll(".axis path")
                .style("stroke", "white");

            yAxis.selectAll(".tick line")
                .style("fill", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            xAxis.selectAll(".tick line")
                .style("fill", "white");

            xAxis.selectAll("text")
                .style("fill", "white");

            // Sort the data array based on gene count in descending order

            console.log(data)
            // Define a scaling factor that the user can adjust
            var scalingFactor = 20; // Default scaling factor

            // Add an input element for the user to adjust the scaling factor
            var scalingFactorInput = d3.select("#slider_dot_polot1")
                .html("")
                .append("input")
                .attr("type", "range")
                .attr("min", 0) // Minimum scaling factor
                .attr("max", 100) // Maximum scaling factor
                .attr("value", scalingFactor) // Default scaling factor
                .on("input", function () {
                    scalingFactor = +this.value;
                    updateDots(); // Update the dots with the new scaling factor
                });

            // Function to update the dots with the new scaling factor
            function updateDots() {
                svg.selectAll(".dot")
                    .attr("r", function (d) { return d.Gene_ratio * scalingFactor; }); // Adjust radius based on scaling factor
            }

            // Add dots with tooltips
            var dot = svg.selectAll(".dot")
                .data(data_disgen)
                .enter().append("circle")
                .attr("class", "dot")
                .attr("cx", function (d) { return x(d.Gene_count); })
                .attr("cy", function (d) { return y(d.Term) + y.bandwidth() / 2; })
                .attr("r", function (d) { return d.Gene_ratio * scalingFactor; }) // Adjust radius as per Gene_ratio and scaling factor
                .style("fill", function (d) {
                    // Access the Adjusted.P.value property using bracket notation
                    adjustedPValue = d['Adjusted.P.value'];

                    // Interpolate color using the color scale
                    return colorScale(adjustedPValue);
                })
                .on("mouseover", function (d) {
                    // Show tooltip on mouseover
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html("Gene Ratio: " + d.Gene_ratio)
                        .style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 28) + "px")
                        .style("color", "white");

                    // Add black stroke on mouseover
                    d3.select(this).style("stroke", "black")
                        .style("stroke-width", "2px");
                })
                .on("mouseout", function (d) {
                    // Hide tooltip on mouseout
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);

                    // Remove black stroke on mouseout
                    d3.select(this).style("stroke", "none");
                });

            // Append tooltip to the body
            var tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);




            // Define the legend dimensions and margins
            var legendWidth = 20,
                legendHeight = 150,
                legendMargin = { top: 20, right: 10, bottom: 30, left: 10 };

            // Append the legend SVG
            var legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (width + legendMargin.left + legendMargin.right) + "," + legendMargin.top + ")");

            // Append a defs (for definition) element to your SVG
            var defs = legend.append("defs");

            // Append a linearGradient element to the defs and give it a unique id
            var linearGradient = defs.append("linearGradient")
                .attr("id", "linear-gradient1")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%");

            // Add color stops to the linear gradient
            linearGradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", "blue");

            linearGradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "red");

            // Draw the rectangle and fill with the linear gradient
            legend.append("rect")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .style("fill", "url(#linear-gradient1)");

            console.log(minValue, maxValue)
            // Define the scale for the legend axis
            var legendScale = d3.scaleLinear()
                .domain([minValue, maxValue])
                .range([legendHeight, 0]);

            // Define the scale for the legend axis
            var legendScale = d3.scaleLinear()
                .domain([minValue, maxValue])
                .range([legendHeight, 0]);

            // Generate tick values for the legend axis
            var tickValues = [minValue, maxValue];

            // Append and style the legend axis
            var legendAxis = d3.axisRight(legendScale)
                .tickValues(tickValues)
                .tickFormat(d3.format(".2e")); // Preserve scientific notation with two decimal places


            var axis = legend.append("g")
                .attr("class", "legend-axis")
                .attr("transform", "translate(" + (legendWidth + 2) + ",0)") // Adjust position as needed
                .call(legendAxis);



            // Apply style to axis ticks to make them white
            axis.selectAll("text").style("fill", "white").style("font-size", "13px")
            axis.selectAll("line").style("stroke", "white");

            // Remove the domain path
            axis.select(".domain").remove();



            function update(selectedGroup, data) {
                var minValue;
                var maxValue;

                // Adjust data based on selected group
                if (selectedGroup == 'DisGenNet') {
                    data = data.annotation_top;
                    data.sort((a, b) => b.Gene_count - a.Gene_count);
                    minValue = d3.min(data, function (d) { return d['Adjusted.P.value']; });
                    maxValue = d3.max(data, function (d) { return d['Adjusted.P.value']; });
                } else if (selectedGroup == 'Bio. Process') {
                    data = data.annotation_top1;
                    data.sort((a, b) => b.Gene_count - a.Gene_count);
                    minValue = d3.min(data, function (d) { return d['Adjusted.P.value']; });
                    maxValue = d3.max(data, function (d) { return d['Adjusted.P.value']; });
                } else if (selectedGroup == 'Molecular function') {
                    data = data.annotation_top2;
                    console.log("MOLECULAR FUNCTION", data)
                    data.sort((a, b) => b.Gene_count - a.Gene_count);
                    minValue = d3.min(data, function (d) { return d['Adjusted.P.value']; });
                    maxValue = d3.max(data, function (d) { return d['Adjusted.P.value']; });
                }
                else if (selectedGroup == 'KEGG') {
                    data = data.annotation_top3;
                    data.sort((a, b) => b.Gene_count - a.Gene_count);
                    minValue = d3.min(data, function (d) { return d['Adjusted.P.value']; });
                    maxValue = d3.max(data, function (d) { return d['Adjusted.P.value']; });
                }
                title.text("DOWN Genes " + selectedGroup);

                // Define a scaling factor that the user can adjust
                var scalingFactor = 20; // Default scaling factor

                // Add an input element for the user to adjust the scaling factor
                var scalingFactorInput = d3.select("#slider_dot_polot1")
                    .html("")
                    .append("input")
                    .attr("type", "range")
                    .attr("min", 0) // Minimum scaling factor
                    .attr("max", 100) // Maximum scaling factor
                    .attr("value", scalingFactor) // Default scaling factor
                    .on("input", function () {
                        scalingFactor = +this.value;
                        updateDots(); // Update the dots with the new scaling factor
                    });

                var colorScale = d3.scaleLinear()
                    .domain([minValue, maxValue])
                    .range(["red", "blue"]);

                // Update x scale
                var x = d3.scaleLinear()
                    .domain([0, d3.max(data, function (d) { return d.Gene_count; })])
                    .range([0, width]);

                // Update y scale
                var y = d3.scaleBand()
                    .domain(data.map(function (d) { return d.Term; }))
                    .range([0, height])
                    .padding(0.1);

                // Update x-axis
                xAxis.transition()
                    .duration(1000)
                    .call(d3.axisBottom(x)
                        .tickSize(-height) // Add gridlines along the x-axis
                    );

                // Update y-axis
                yAxis.transition()
                    .duration(1000)
                    .call(d3.axisLeft(y)
                        .tickSize(-width) // Add gridlines along the y-axis
                    );

                // Style axes and gridlines
                svg.selectAll(".axis line")
                    .style("stroke", "white");

                svg.selectAll(".axis path")
                    .style("stroke", "white");

                yAxis.selectAll(".tick line")
                    .style("fill", "white");

                yAxis.selectAll("text")
                    .style("fill", "white");

                xAxis.selectAll(".tick line")
                    .style("fill", "white");

                xAxis.selectAll("text")
                    .style("fill", "white");


                // Update dots
                var dots = svg.selectAll("circle")
                    .data(data);

                // Remove existing circles
                dots.exit().remove();

                // Append new circles for any new data points
                dots.enter().append("circle")
                    .transition()
                    .duration(1000)
                    .attr("cx", function (d) { return x(d.Gene_count); })
                    .attr("cy", function (d) { return y(d.Term) + y.bandwidth() / 2; })
                    .attr("r", function (d) { return d.Gene_ratio * scalingFactor; }) // Adjust radius as per Gene_ratio and scaling factor
                    .style("fill", function (d) {
                        // Access the Adjusted.P.value property using bracket notation
                        adjustedPValue = d['Adjusted.P.value'];

                        // Interpolate color using the color scale
                        return colorScale(adjustedPValue);
                    });

                // Transition existing circles to new positions
                dots.transition()
                    .duration(1000)
                    .attr("cx", function (d) { return x(d.Gene_count); })
                    .attr("cy", function (d) { return y(d.Term) + y.bandwidth() / 2; })
                    .attr("r", function (d) { return d.Gene_ratio * scalingFactor; }) // Adjust radius as per Gene_ratio and updated scaling factor
                    .style("fill", function (d) {
                        // Access the Adjusted.P.value property using bracket notation
                        adjustedPValue = d['Adjusted.P.value'];

                        // Interpolate color using the color scale
                        return colorScale(adjustedPValue);
                    });

                // Update legend
                legendScale.domain([d3.min(data, function (d) { return d['Adjusted.P.value']; }), d3.max(data, function (d) { return d['Adjusted.P.value']; })]);
                var tickValues = [d3.min(data, function (d) { return d['Adjusted.P.value']; }), d3.max(data, function (d) { return d['Adjusted.P.value']; })];
                legendAxis.tickValues(tickValues);
                axis.call(legendAxis);

                // Apply style to axis ticks to make them white
                axis.selectAll("text").style("fill", "white").style("font-size", "13px");
                axis.selectAll("line").style("stroke", "white");

                // Remove the domain path
                axis.select(".domain").remove();

                function updateDots() {
                    svg.selectAll("circle")
                        .attr("r", function (d) { return d.Gene_ratio * scalingFactor; }); // Adjust radius based on scaling factor
                }
            }

            // Define the event handler for the change event
            selectDot.on("change", function () {
                var selectedOption = d3.select(this).property("value");
                update(selectedOption, data);
            });
        }




        document.getElementById("thresholdSlider").addEventListener("input", function () {
            // Update the threshold value on slider change
            prc_IQR = parseFloat(this.value);
            document.getElementById("thresholdValue").innerText = prc_IQR;

            // Calculate the quantile
            thr_prc = ss.quantile(variation_data_copy, prc_IQR);
            updateHistogram(variation_data);
            console.log(variation_data)

            const ind = variation_data_copy.reduce((result, entry, index) => {

                if (entry < thr_prc) {
                    result.push(index);
                }
                return result;
            }, []);

            console.log(ind)

            dataC_copy1 = dataC_original
            dataN_copy1 = dataN_original
            data_copy1 = data_original

            console.log("geni tolti con IQR", ind.length)
            if (ind.length > 0) {
                // Remove entries corresponding to ind from dataC
                dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from data
                dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));

                data_copy1 = data_original.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from genes
                //genes = genes.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from logFC
                //parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));

            }
            // Update the gene count display
            // const geneCountDiv = document.getElementById('geneCount');
            // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${dataC_copy1.length}`;

            first_filter_number_genes = dataC_copy.length

            parsedLogFC_origin = calculateLogFC(dataC_copy1, dataN_copy1);
            parsedLogFC = parsedLogFC_origin


            //console.log(parsedLogFC_origin)
            updateLogFCHistogram(parsedLogFC_origin)


            // Calculate the quantile
            log_thr_fc = Math.log2(thr_fc);
            //console.log(log_thr_fc)
            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {

                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                    result.push(index);

                }
                return result;
            }, []);

            console.log("geni da togliere con il logFC da IQR", ind2.length)
            console.log("ora rimuovo questi geni da data che partiva da", data_copy1.length)

            // console.log("parsed log before ",parsedLogFC.length)
            // console.log("data copy beforeC ",dataC_copy.length)
            // console.log("data copy beforeN ",dataN_copy.length)

            // console.log("parsed log origin ",parsedLogFC_origin.length)
            /////////////////////// 

            //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE

            //////////////////////

            // console.log(parsedLogFC_origin)
            // console.log(data_copy1)

            dataC_copy = dataC_copy1
            dataN_copy = dataN_copy1
            data_copy = data_copy1
            parsedLogFC = parsedLogFC_origin

            if (ind2.length > 0) {
                //console.log("ind2")
                // Remove entries corresponding to ind from dataN
                dataC_copy = dataC_copy1.filter((entry, index) => !ind2.includes(index));

                // Remove entries corresponding to ind from dataN
                dataN_copy = dataN_copy1.filter((entry, index) => !ind2.includes(index));

                data_copy = data_copy1.filter((entry, index) => !ind2.includes(index));

                parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind2.includes(index));
            }

            console.log("ho rimosso", ind2.length, " GENI da data e ne rimangono ", data_copy.length)
            updateCounter()
            // console.log(parsedLogFC)
            // console.log(data_copy)

            // log_thr_fc = Math.log2(thr_fc);  
            //       const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {

            //           if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
            //             result.push(index);
            //           }
            //           return result;
            //       }, []);


            // const geneCountDiv2 = document.getElementById('geneCount2');
            // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length - ind2.length}`;

        });

        document.getElementById("thresholdSlider").addEventListener("change", function () {
            document.getElementById("loadingOverlay").style.display = "block";
            if (chosen_statistic == 't-test') {
                console.log("data copy in iqr prima di chiamare pval", data_copy)
                var req = ocpu.call("pval", {
                    data: data_copy,
                    N: normal_number,
                    M: case_number
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);


                            const ind = old_p_adj.reduce((result, entry, index) => {

                                if (entry.pval_adj > threshold) {
                                    result.push(index);
                                }
                                return result;
                            }, []);
                            console.log("geni con pval minore di thr nel iqr slider", ind.length)
                            console.log("thr pval ", threshold)
                            dataC_copy_pval = dataC_copy
                            dataN_copy_pval = dataN_copy
                            data_copy_pval = data_copy

                            if (ind.length > 0) {

                                //console.log(parsedLogFC.length)

                                // Remove entries corresponding to ind from dataN

                                // Remove entries corresponding to ind from dataN
                                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from dataN
                                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from logFC
                                parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                console.log("geni passati a box dal IQR slider", parsedLogFC.length)
                            }
                            updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)



                            var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                            var mostUpregulatedGene = sortedLogFC[0];
                            var secondMostUpregulatedGene = sortedLogFC[1];

                            var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                            var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                            var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                            //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                            var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                            //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                            genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
                            if (selectedGeneData == []) {
                                selectedGeneData.push(mostUpregulatedGeneName)
                                selectedGeneData.push(mostDownregulatedGeneName)

                            }
                            else {
                                // Filter out genes that are not present in dataC_copy or dataN_copy
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });
                            }


                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }


                            // dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy_pval, first_dims)
                            updateCounter()
                            var pc1Values = [];
                            var pc2Values = [];
                            var groupValues = [];
                            var req = ocpu.call("pca", {
                                data: data_copy_pval,
                                dataN: dataN_copy_pval,
                                dataC: dataC_copy_pval
                            }, function (session) {
                                var filteredDataURL = session.loc + "/R/.val/json";
                                //console.log(session);
                                // Fetch the filtered data from the URL
                                fetch(filteredDataURL)
                                    .then(response => response.json())
                                    .then(data => {
                                        json = data
                                        console.log(filteredDataURL)
                                        console.log(json)

                                        var pc1Key = "PC1";
                                        var pc2Key = "PC2";
                                        var groupKey = "Group";

                                        // Arrays to store PC1 and PC2 values


                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            pc1Values.push(obj[pc1Key]);
                                            pc2Values.push(obj[pc2Key]);
                                            groupValues.push(obj[groupKey]);
                                        });
                                        // console.log(pc1Values)

                                        // Extract metadata categories from the values of the first column
                                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                        console.log("Metadata categories:", metadataCategories);

                                        // Initialize pca_data array
                                        pca_data = [];

                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Retrieve additional data from metadata based on _row
                                            var gsm = obj._row;
                                            var group = obj.Group;
                                            var pc1 = obj.PC1;
                                            var pc2 = obj.PC2;

                                            // Create an object with the required fields
                                            var newObj = {
                                                GSM: gsm,
                                                group: group,
                                                pc1: pc1,
                                                pc2: pc2
                                            };

                                            // Add metadata values for each category to the newObj
                                            metadataCategories.forEach((category, index) => {
                                                newObj[category] = metadata[index][gsm];
                                            });

                                            // Push the new object to the pca_data array
                                            pca_data.push(newObj);
                                        });

                                        heatmap_data = []
                                        json.scores_var.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            var gene = obj._row
                                            var pc1 = obj.PC1
                                            var pc2 = obj.PC2
                                            var pc3 = obj.PC3
                                            var pc4 = obj.PC4
                                            var pc5 = obj.PC5
                                            var pc6 = obj.PC6

                                            var newObj = {
                                                gene: gene,
                                                pc1: pc1,
                                                pc2: pc2,
                                                pc3: pc3,
                                                pc4: pc4,
                                                pc5: pc5,
                                                pc6: pc6
                                            };
                                            heatmap_data.push(newObj);
                                        })

                                        // Display the newData array
                                        console.log(pca_data);


                                        pca(pca_data);
                                        heatmap(heatmap_data)

                                    })



                                // DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)


                            })
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    return "green";

                                });



                        });
                })

            } else if (chosen_statistic == 'limma') {
                console.log("data copy in iqr prima di chiamare limma", data_copy)
                var req = ocpu.call("limmaDE", {
                    dataC: dataC_copy,  // Pass your processed case data
                    dataN: dataN_copy   // Pass your processed normal data
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    //console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            console.log(session);
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            // Rename '_row' to 'Gene'
                            data.forEach(entry => {
                                if (entry.hasOwnProperty('_row')) {
                                    entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                    delete entry._row; // Remove '_row' property
                                }
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);



                            const ind = old_p_adj.reduce((result, entry, index) => {

                                if (entry.pval_adj > threshold) {
                                    result.push(index);
                                }
                                return result;
                            }, []);
                            console.log("geni con pval minore di thr nel iqr slider", ind.length)
                            console.log("thr pval ", threshold)
                            dataC_copy_pval = dataC_copy
                            dataN_copy_pval = dataN_copy
                            data_copy_pval = data_copy

                            if (ind.length > 0) {

                                //console.log(parsedLogFC.length)

                                // Remove entries corresponding to ind from dataN

                                // Remove entries corresponding to ind from dataN
                                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from dataN
                                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from logFC
                                parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                console.log("geni passati a box dal IQR slider", parsedLogFC.length)
                            }
                            updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)



                            var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                            var mostUpregulatedGene = sortedLogFC[0];
                            var secondMostUpregulatedGene = sortedLogFC[1];

                            var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                            var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                            var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                            //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                            var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                            //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                            genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
                            if (selectedGeneData == []) {
                                selectedGeneData.push(mostUpregulatedGeneName)
                                selectedGeneData.push(mostDownregulatedGeneName)

                            }
                            else {
                                // Filter out genes that are not present in dataC_copy or dataN_copy
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });
                            }

                            console.log(selectedGeneData)

                            // Find the select element
                            var selectElement = document.getElementById("selectButton");

                            // Clear existing options
                            selectElement.innerHTML = "";

                            // Add the new options dynamically
                            var option1 = document.createElement("option");
                            option1.value = mostUpregulatedGene.Gene;
                            option1.text = `Most Upregulated (${mostUpregulatedGene.Gene})`;
                            option1.selected = true;
                            selectElement.appendChild(option1);

                            var option2 = document.createElement("option");
                            option2.value = mostDownregulatedGene.Gene;
                            option2.text = `Most Downregulated (${mostDownregulatedGene.Gene})`;
                            selectElement.appendChild(option2);

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }



                            //dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy_pval, first_dims)


                            updateCounter()
                            var pc1Values = [];
                            var pc2Values = [];
                            var groupValues = [];
                            var req = ocpu.call("pca", {
                                data: data_copy_pval,
                                dataN: dataN_copy_pval,
                                dataC: dataC_copy_pval
                            }, function (session) {
                                var filteredDataURL = session.loc + "/R/.val/json";
                                //console.log(session);
                                // Fetch the filtered data from the URL
                                fetch(filteredDataURL)
                                    .then(response => response.json())
                                    .then(data => {
                                        json = data
                                        console.log(filteredDataURL)
                                        console.log(json)

                                        var pc1Key = "PC1";
                                        var pc2Key = "PC2";
                                        var groupKey = "Group";

                                        // Arrays to store PC1 and PC2 values


                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            pc1Values.push(obj[pc1Key]);
                                            pc2Values.push(obj[pc2Key]);
                                            groupValues.push(obj[groupKey]);
                                        });
                                        // console.log(pc1Values)

                                        // Extract metadata categories from the values of the first column
                                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                        console.log("Metadata categories:", metadataCategories);

                                        // Initialize pca_data array
                                        pca_data = [];

                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Retrieve additional data from metadata based on _row
                                            var gsm = obj._row;
                                            var group = obj.Group;
                                            var pc1 = obj.PC1;
                                            var pc2 = obj.PC2;

                                            // Create an object with the required fields
                                            var newObj = {
                                                GSM: gsm,
                                                group: group,
                                                pc1: pc1,
                                                pc2: pc2
                                            };

                                            // Add metadata values for each category to the newObj
                                            metadataCategories.forEach((category, index) => {
                                                newObj[category] = metadata[index][gsm];
                                            });

                                            // Push the new object to the pca_data array
                                            pca_data.push(newObj);
                                        });

                                        heatmap_data = []
                                        json.scores_var.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            var gene = obj._row
                                            var pc1 = obj.PC1
                                            var pc2 = obj.PC2
                                            var pc3 = obj.PC3
                                            var pc4 = obj.PC4
                                            var pc5 = obj.PC5
                                            var pc6 = obj.PC6

                                            var newObj = {
                                                gene: gene,
                                                pc1: pc1,
                                                pc2: pc2,
                                                pc3: pc3,
                                                pc4: pc4,
                                                pc5: pc5,
                                                pc6: pc6
                                            };
                                            heatmap_data.push(newObj);
                                        })

                                        // Display the newData array
                                        console.log(pca_data);


                                        pca(pca_data);
                                        heatmap(heatmap_data)

                                    })



                                // DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)


                            })
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    return "green";

                                });



                        });
                })

            }



            // const geneCountDiv2 = document.getElementById('geneCount2');
            // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;

        });


        document.getElementById("log_thresholdSlider").addEventListener("input", function () {
            // Update the threshold value on slider change
            thr_fc = parseFloat(this.value);
            document.getElementById("log_thresholdSliderValue").innerText = thr_fc;

            // Calculate the quantile
            log_thr_fc = Math.log2(thr_fc);
            //console.log(log_thr_fc)
            const ind = parsedLogFC_origin.reduce((result, entry, index) => {

                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                    result.push(index);

                }
                return result;
            }, []);

            if (ind.length > 0) {

                // Remove entries corresponding to ind from dataN
                dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from dataN
                dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));

                data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

                parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
            }

            updateCounter()
            updateLogFCHistogram(parsedLogFC_origin);

        });

        document.getElementById("log_thresholdSlider").addEventListener("change", function () {
            document.getElementById("loadingOverlay").style.display = "block";
            dataC_copy_pval = dataC_copy
            dataN_copy_pval = dataN_copy
            data_copy_pval = data_copy
            updateCounter()

            if (chosen_statistic == 't-test') {

                var req = ocpu.call("pval", {
                    data: data_copy,
                    N: normal_number,
                    M: case_number
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }

                            selectedGeneData = selectedGeneData.filter(function (gene) {
                                // Check if the gene is present in dataC_copy or dataN_copy
                                return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                    dataN_copy.some(function (d) { return d.gene === gene; });
                            });

                            console.log(selectedGeneData)

                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                            const ind = old_p_adj.reduce((result, entry, index) => {

                                if (entry.pval_adj > threshold) {
                                    result.push(index);
                                }
                                return result;
                            }, []);
                            dataC_copy_pval = dataC_copy
                            dataN_copy_pval = dataN_copy
                            data_copy_pval = data_copy

                            console.log("geni con pval minore di thr nel logFC slider", ind.length)

                            if (ind.length > 0) {

                                //console.log(parsedLogFC.length)

                                // Remove entries corresponding to ind from dataN

                                // Remove entries corresponding to ind from dataN
                                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from dataN
                                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));

                                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from logFC
                                parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));


                                updateBoxPlot(last_box, parsedLogFC_pval, dataN_copy_pval, dataC_copy_pval)
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });

                                console.log(selectedGeneData)

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                                console.log(dataN_copy.length)
                            }
                            updateCounter()

                            //   var pc1Values = [];
                            // var pc2Values = [];
                            // var groupValues = [];
                            var req = ocpu.call("pca", {
                                data: data_copy_pval,
                                dataN: dataN_copy_pval,
                                dataC: dataC_copy_pval
                            }, function (session) {
                                var filteredDataURL = session.loc + "R/.val/json";
                                //console.log(session);
                                // Fetch the filtered data from the URL
                                fetch(filteredDataURL)
                                    .then(response => response.json())
                                    .then(data => {
                                        json = data
                                        console.log(filteredDataURL)
                                        console.log(json)

                                        var pc1Key = "PC1";
                                        var pc2Key = "PC2";
                                        var groupKey = "Group";

                                        // Arrays to store PC1 and PC2 values


                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            pc1Values.push(obj[pc1Key]);
                                            pc2Values.push(obj[pc2Key]);
                                            groupValues.push(obj[groupKey]);
                                        });
                                        // console.log(pc1Values)

                                        // Extract metadata categories from the values of the first column
                                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                        console.log("Metadata categories:", metadataCategories);

                                        // Initialize pca_data array
                                        pca_data = [];

                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Retrieve additional data from metadata based on _row
                                            var gsm = obj._row;
                                            var group = obj.Group;
                                            var pc1 = obj.PC1;
                                            var pc2 = obj.PC2;

                                            // Create an object with the required fields
                                            var newObj = {
                                                GSM: gsm,
                                                group: group,
                                                pc1: pc1,
                                                pc2: pc2
                                            };

                                            // Add metadata values for each category to the newObj
                                            metadataCategories.forEach((category, index) => {
                                                newObj[category] = metadata[index][gsm];
                                            });

                                            // Push the new object to the pca_data array
                                            pca_data.push(newObj);
                                        });

                                        // Display the newData array
                                        console.log(pca_data);
                                        heatmap_data = []
                                        json.scores_var.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            var gene = obj._row
                                            var pc1 = obj.PC1
                                            var pc2 = obj.PC2
                                            var pc3 = obj.PC3
                                            var pc4 = obj.PC4
                                            var pc5 = obj.PC5
                                            var pc6 = obj.PC6

                                            var newObj = {
                                                gene: gene,
                                                pc1: pc1,
                                                pc2: pc2,
                                                pc3: pc3,
                                                pc4: pc4,
                                                pc5: pc5,
                                                pc6: pc6
                                            };
                                            heatmap_data.push(newObj);
                                        })

                                        pca(pca_data);
                                        heatmap(heatmap_data)
                                    })

                                //DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)

                            })





                        });
                })
            } else if (chosen_statistic == 'limma') {

                var req = ocpu.call("limmaDE", {
                    dataC: dataC_copy,  // Pass your processed case data
                    dataN: dataN_copy   // Pass your processed normal data
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    //console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            console.log(session);
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            // Rename '_row' to 'Gene'
                            data.forEach(entry => {
                                if (entry.hasOwnProperty('_row')) {
                                    entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                    delete entry._row; // Remove '_row' property
                                }
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }

                            selectedGeneData = selectedGeneData.filter(function (gene) {
                                // Check if the gene is present in dataC_copy or dataN_copy
                                return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                    dataN_copy.some(function (d) { return d.gene === gene; });
                            });

                            console.log(selectedGeneData)

                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                            const ind = old_p_adj.reduce((result, entry, index) => {

                                if (entry.pval_adj > threshold) {
                                    result.push(index);
                                }
                                return result;
                            }, []);
                            dataC_copy_pval = dataC_copy
                            dataN_copy_pval = dataN_copy
                            data_copy_pval = data_copy

                            console.log("geni con pval minore di thr nel logFC slider", ind.length)

                            if (ind.length > 0) {

                                //console.log(parsedLogFC.length)

                                // Remove entries corresponding to ind from dataN

                                // Remove entries corresponding to ind from dataN
                                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from dataN
                                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));

                                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from logFC
                                parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                console.log(dataN_copy_pval[0])

                                updateBoxPlot(last_box, parsedLogFC_pval, dataN_copy_pval, dataC_copy_pval)
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });

                                console.log(selectedGeneData)

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                                console.log(dataN_copy.length)
                            }
                            updateCounter()

                            //   var pc1Values = [];
                            // var pc2Values = [];
                            // var groupValues = [];
                            var req = ocpu.call("pca", {
                                data: data_copy_pval,
                                dataN: dataN_copy_pval,
                                dataC: dataC_copy_pval
                            }, function (session) {
                                var filteredDataURL = session.loc + "R/.val/json";
                                //console.log(session);
                                // Fetch the filtered data from the URL
                                fetch(filteredDataURL)
                                    .then(response => response.json())
                                    .then(data => {
                                        json = data
                                        console.log(filteredDataURL)
                                        console.log(json)

                                        var pc1Key = "PC1";
                                        var pc2Key = "PC2";
                                        var groupKey = "Group";

                                        // Arrays to store PC1 and PC2 values


                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            pc1Values.push(obj[pc1Key]);
                                            pc2Values.push(obj[pc2Key]);
                                            groupValues.push(obj[groupKey]);
                                        });
                                        // console.log(pc1Values)

                                        // Extract metadata categories from the values of the first column
                                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                                        console.log("Metadata categories:", metadataCategories);

                                        // Initialize pca_data array
                                        pca_data = [];

                                        // Iterate over each object in the JSON array
                                        json.scores_df.forEach(function (obj) {
                                            // Retrieve additional data from metadata based on _row
                                            var gsm = obj._row;
                                            var group = obj.Group;
                                            var pc1 = obj.PC1;
                                            var pc2 = obj.PC2;

                                            // Create an object with the required fields
                                            var newObj = {
                                                GSM: gsm,
                                                group: group,
                                                pc1: pc1,
                                                pc2: pc2
                                            };

                                            // Add metadata values for each category to the newObj
                                            metadataCategories.forEach((category, index) => {
                                                newObj[category] = metadata[index][gsm];
                                            });

                                            // Push the new object to the pca_data array
                                            pca_data.push(newObj);
                                        });

                                        // Display the newData array
                                        console.log(pca_data);
                                        heatmap_data = []
                                        json.scores_var.forEach(function (obj) {
                                            // Push PC1, PC2, and Group values to the arrays
                                            var gene = obj._row
                                            var pc1 = obj.PC1
                                            var pc2 = obj.PC2
                                            var pc3 = obj.PC3
                                            var pc4 = obj.PC4
                                            var pc5 = obj.PC5
                                            var pc6 = obj.PC6

                                            var newObj = {
                                                gene: gene,
                                                pc1: pc1,
                                                pc2: pc2,
                                                pc3: pc3,
                                                pc4: pc4,
                                                pc5: pc5,
                                                pc6: pc6
                                            };
                                            heatmap_data.push(newObj);
                                        })

                                        pca(pca_data);
                                        heatmap(heatmap_data)
                                    })

                                //DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)

                            })





                        });
                })

            }



            //updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            // console.log("parsed log ",parsedLogFC.length)
            // console.log("data copy beforeC ",dataC_copy.length)
            // console.log("data copy beforeN",dataN_copy.length)

            // const geneCountDiv = document.getElementById('geneCount2');
            // geneCountDiv.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length}`;

            // Now, dataN, dataC, data, genes, and logFC are updated
        })

        // Assuming newdataNJSON, newdataCJSON, and newdataJSON are your arrays of data
        document.getElementById('thresholdSelect').addEventListener('change', function () {
            //console.log(dataC_copy)
            //console.log(data_copy)
            //console.log(dataN_copy)

            document.getElementById("loadingOverlay").style.display = "block";


            threshold = parseFloat(this.value);

            const ind = old_p_adj.reduce((result, entry, index) => {

                if (entry.pval_adj > threshold) {
                    result.push(index);
                }
                return result;
            }, []);

            if (currentPlot === 'volcano') {
                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            } else {
                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            }            // dataC_copy_pval=dataC_copy
            // dataN_copy_pval=dataN_copy
            // data_copy_pval=data_copy


            if (ind.length > 0) {

                //console.log(parsedLogFC.length)

                // Remove entries corresponding to ind from dataN

                // Remove entries corresponding to ind from dataN
                dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from dataN
                dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));


                data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));

                // Remove entries corresponding to ind from logFC
                parsedLogFC_pval = parsedLogFC.filter((entry, index) => !ind.includes(index));

                updateCounter()

                updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                var pc1Values = [];
                var pc2Values = [];
                var groupValues = [];
                var req = ocpu.call("pca", {
                    data: data_copy_pval,
                    dataN: dataN_copy_pval,
                    dataC: dataC_copy_pval
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    //console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            json = data
                            console.log(filteredDataURL)
                            console.log(json)

                            var pc1Key = "PC1";
                            var pc2Key = "PC2";
                            var groupKey = "Group";

                            // Iterate over each object in the JSON array
                            json.scores_df.forEach(function (obj) {
                                // Push PC1, PC2, and Group values to the arrays
                                pc1Values.push(obj[pc1Key]);
                                pc2Values.push(obj[pc2Key]);
                                groupValues.push(obj[groupKey]);
                            });
                            // console.log(pc1Values)

                            // Extract metadata categories from the values of the first column
                            var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                            console.log("Metadata categories:", metadataCategories);

                            // Initialize pca_data array
                            pca_data = [];

                            // Iterate over each object in the JSON array
                            json.scores_df.forEach(function (obj) {
                                // Retrieve additional data from metadata based on _row
                                var gsm = obj._row;
                                var group = obj.Group;
                                var pc1 = obj.PC1;
                                var pc2 = obj.PC2;

                                // Create an object with the required fields
                                var newObj = {
                                    GSM: gsm,
                                    group: group,
                                    pc1: pc1,
                                    pc2: pc2
                                };

                                // Add metadata values for each category to the newObj
                                metadataCategories.forEach((category, index) => {
                                    newObj[category] = metadata[index][gsm];
                                });

                                // Push the new object to the pca_data array
                                pca_data.push(newObj);
                            });

                            heatmap_data = []
                            json.scores_var.forEach(function (obj) {
                                // Push PC1, PC2, and Group values to the arrays
                                var gene = obj._row
                                var pc1 = obj.PC1
                                var pc2 = obj.PC2
                                var pc3 = obj.PC3
                                var pc4 = obj.PC4
                                var pc5 = obj.PC5
                                var pc6 = obj.PC6

                                var newObj = {
                                    gene: gene,
                                    pc1: pc1,
                                    pc2: pc2,
                                    pc3: pc3,
                                    pc4: pc4,
                                    pc5: pc5,
                                    pc6: pc6
                                };
                                heatmap_data.push(newObj);
                            })

                            // Display the newData array
                            console.log(pca_data);


                            pca(pca_data);
                            heatmap(heatmap_data)

                        })




                    // DEG(data_copy_pval,parsedLogFC_pval,old_p_adj)



                })

            } else {
                document.getElementById("loadingOverlay").style.display = "none";
            }

        })

        function pca(pca_data) {
            console.log("update pca")
            pc1Values = []
            pc2Values = []
            groupValues = []
            smokerValues = []
            stageValues = []

            console.log(pca_data)

            // Iterate over the newData array
            pca_data.forEach(function (obj) {
                // Access pc1, pc2, and group values from each object
                var pc1Value = obj.pc1;
                var pc2Value = obj.pc2;
                var groupValue = obj.group;
                var gsmValue = obj.GSM; // Assuming GSM is a property in the object

                pc1Values.push(pc1Value);
                pc2Values.push(pc2Value);
                groupValues.push(groupValue);
                // Use the values as needed
                //console.log("PC1:", pc1Value, ", PC2:", pc2Value, ", Group:", groupValue);
            });

            var margin = { top: 20, right: 20, bottom: 50, left: 60 };
            var width = 600;
            var height = 400;

            // Create x and y scales
            var xScale = d3.scaleLinear()
                .domain(d3.extent(pc1Values))
                .range([0, width]);

            var yScale = d3.scaleLinear()
                .domain(d3.extent(pc2Values))
                .range([height, 0]);

            // Create SVG container
            var svg = d3.select("#pca")
                .html("")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Add circles for each data point
            svg.selectAll(".data-circle")
                .data(pca_data) // Bind data directly to the circles
                .enter().append("circle")
                .attr("class", "data-circle") // Assign the class "data-circle" to the circles
                .attr("cx", function (d) { return xScale(d.pc1); })
                .attr("cy", function (d) { return yScale(d.pc2); })
                .attr("r", 5) // Adjust the radius as needed
                .style("fill", function (d) {
                    // console.log(d)
                    // console.log(selectedRowName)
                    // console.log(d[selectedRowName])
                    if (d[selectedRowName] == chosen_meta1) {
                        return d3.schemeSet1[0];
                    } else {
                        return d3.schemeSet1[2]
                    }
                })
                .attr("stroke", function (d) {
                    // Set stroke color based on presence in gsmList
                    return gsmList.includes(d.GSM) ? "black" : null;
                })
                .attr("stroke-width", function (d) {
                    // Set stroke width based on presence in gsmList
                    return gsmList.includes(d.GSM) ? 4 : null;
                })
                .on("click", function (d) {
                    // On click, select the circle and add the GSM value to the list
                    d3.select(this).attr("stroke", "black").attr("stroke-width", 2);
                    var selectedGSM = d.GSM; // Assuming GSM is a property in the object
                    console.log("Selected GSM:", selectedGSM);
                    gsmList.push(selectedGSM);
                    console.log("GSM List:", gsmList);

                    // Check if the selected GSM is in the transposedData list
                    var selectedData = transposedData.find(function (data) {
                        return data.GSM === selectedGSM;
                    });

                });

            // Add x-axis
            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");

            // Add y-axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Principal Component Analysis")
                .style("fill", "white");


            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("PC1");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("PC2");

            // Define brush function
            var brush = d3.brush()
                .extent([[0, 0], [width, height]])
                .on("end", brushended);

            // Append brush to SVG
            svg.append("g")
                .attr("class", "brush")
                .call(brush);

            // Function to handle brushend event
            function brushended() {
                var selection = d3.event.selection; // Get the brush selection
                var selectedCircles; // Initialize variable to store selected circles

                if (!selection) {
                    // If there's no selection (brush is removed)
                    // Deselect all circles and clear the GSM list
                    selectedCircles = d3.selectAll(".data-circle").each(function () {
                        d3.select(this)
                            .attr("stroke", null) // Remove stroke
                            .attr("stroke-width", null); // Remove stroke width
                    });
                    gsmList = []; // Clear GSM list
                } else {
                    // If there's a selection, proceed as before to handle selected circles
                    selectedCircles = d3.selectAll(".data-circle").filter(function () {
                        var cx = d3.select(this).attr("cx"); // Get the x-coordinate of the circle
                        var cy = d3.select(this).attr("cy"); // Get the y-coordinate of the circle
                        return cx >= selection[0][0] && cx <= selection[1][0] && cy >= selection[0][1] && cy <= selection[1][1];
                    });

                    // Handle selected circles
                    selectedCircles.each(function () {
                        var circle = d3.select(this); // Select the circle
                        var circleGSM = circle.datum().GSM; // Get the GSM value associated with the circle

                        // Add circle's GSM to the list
                        gsmList.push(circleGSM);
                        console.log("Selected GSM:", circleGSM);

                        // Select the circle visually
                        circle.attr("stroke", "black")
                            .attr("stroke-width", 4);

                    });
                }
                // Define legend items

                // Update parallel plot or any other function with the updated GSM list
                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);


                updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

            }
            var legendItems = [
                { label: chosen_meta2, color: d3.schemeSet1[2] },
                { label: chosen_meta1, color: d3.schemeSet1[0] }
            ];

            // Create legend group
            var legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (width - 580) + "," + 20 + ")")
                .call(d3.drag()
                    .on("drag", function (event) {
                        d3.select(this).attr("transform", function () {
                            return "translate(" + (d3.event.x) + "," + (d3.event.y) + ")";
                        });
                    })
                );

            // Calculate total height of legend
            var legendHeight = legendItems.length * 17.3; // Assuming each legend item has a height of 20 units

            // Calculate width based on the longest label
            var longestLabelWidth = d3.max(legendItems, function (d) { return d.label.length; }) * 5.4; // Assuming each character width is 8 units

            // Append white transparent rectangle around the legend
            legend.append("rect")
                .attr("x", -5)
                .attr("y", -5)
                .attr("width", longestLabelWidth + 20) // Add padding to the longest label width
                .attr("height", legendHeight + 20) // Add padding to the legend height
                .style("fill", "none")
                .style("stroke", "white")  // Add stroke attribute
                .style("stroke-width", 1);  // Set stroke width

            // Change cursor to pointer when mouse enters the legend rectangle
            legend.on("mouseover", function (event) {
                d3.select(this).style("cursor", "move");
            });

            // Define maximum length for legend labels before truncating
            var maxLabelLength = 18; // You can adjust this value as needed

            // Append legend circles and text
            legend.selectAll("circle.legend-item")
                .data(legendItems)
                .enter().append("circle")
                .attr("class", "legend-item")
                .attr("cx", 5) // Adjust the x-coordinate as needed
                .attr("cy", function (d, i) { return i * 20 + 5; }) // Adjust the y-coordinate as needed
                .attr("r", 4) // Adjust the radius as needed
                .style("fill", function (d) { return d.color; });

            legend.selectAll("text.legend-item")
                .data(legendItems)
                .enter().append("text")
                .attr("class", "legend-item")
                .attr("x", 15)
                .attr("y", function (d, i) { return i * 20 + 10; })
                .text(function (d) {
                    // Truncate the label if it exceeds the maximum length
                    var text = d.label;
                    if (text.length > maxLabelLength) {
                        return text.slice(0, maxLabelLength) + '...'; // Truncate and add ellipsis
                    }
                    return text;
                })
                .style("font-size", "12px")
                .style("fill", "white")
                .append("title") // Add tooltip with the full text
                .text(function (d) { return d.label; }); // Full text for tooltip

        }

        function updateHistogram(variation_data) {
            console.log(variation_data)
            // Filter data based on the threshold
            const filteredData = variation_data.filter(variation => variation >= thr_prc);

            // Create histogram using D3.js
            const svgWidth = 600;
            const svgHeight = 300;
            const margin = { top: 20, right: 20, bottom: 40, left: 50 };
            const width = svgWidth - margin.left - margin.right;
            const height = svgHeight - margin.top - margin.bottom;

            const svg = d3.select("#IQR")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create histogram
            const histogram = d3.histogram()
                .value(variation => variation)
                .domain(d3.extent(variation_data))
                .thresholds(100);

            const bins = histogram(variation_data);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(variation_data))
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .range([height, 0]);

            // Add histogram bars
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", d => xScale(d.x0))
                .attr("y", d => yScale(d.length))
                .attr("width", d => xScale(d.x1) - xScale(d.x0))
                .attr("height", d => height - yScale(d.length))
                .attr("fill", d => {
                    const thresholdPosition = xScale(thr_prc);
                    if (xScale(d.x1) < thresholdPosition) {
                        return "grey"; // Set the color to grey if d.x1 is less than the threshold
                    } else {
                        return "darkgreen"; // Set the original bar color
                    }
                });

            // Add overlay for colored portion
            svg.selectAll(".overlay")
                .data(bins)
                .enter()
                .append("rect")
                .attr("class", "overlay")
                .attr("x", d => {
                    const thresholdPosition = xScale(thr_prc);
                    return xScale(d.x0); // Start the overlay from the beginning of the bar
                })
                .attr("y", d => yScale(d.length))
                .attr("width", d => {
                    const thresholdPosition = xScale(thr_prc);
                    const barWidth = xScale(d.x1) - xScale(d.x0);
                    if (xScale(d.x0) < thresholdPosition && xScale(d.x1) > thresholdPosition) {
                        // Calculate the width of the portion to color
                        return thresholdPosition - xScale(d.x0); // Only color the left portion
                    } else {
                        return 0; // Set width to 0 for bars where threshold is not in range
                    }
                })
                .attr("height", d => height - yScale(d.length))
                .attr("fill", "grey") // Color the left portion of the overlay
                .attr("opacity", 1); // Set opacity for transparency

            // Add x-axis
            var xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");

            // Add y-axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");


            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("IQR value");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 12)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("Frequency");


            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top * 0.1)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("fill", "white")
                .text("IQR Frequency distribution");

            // Add a red line indicating the threshold
            const thresholdLine = svg.append("line")
                .attr("y1", 0)
                .attr("y2", height)
                .attr("stroke", "darkred")
                .attr("stroke-width", 2);

            // Update the position of the threshold line
            thresholdLine.attr("x1", xScale(thr_prc))
                .attr("x2", xScale(thr_prc));


            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width - 150) + "," + 20 + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 5)  // Adjusted x-coordinate to provide some padding
                .attr("y", 5)  // Adjusted y-coordinate to provide some padding
                .attr("width", 160)  // Adjusted width to encapsulate the legend content
                .attr("height", 70)  // Adjusted height to encapsulate the legend content
                .style("stroke", "white")  // Border color
                .style("fill", "none")  // No fill for the rectangle
                .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

            // Add Remaining genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 10)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "darkgreen");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 18)
                .text("Remaining genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");

            // Add Filtered genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 35)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "grey");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 45)
                .text("Filtered genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");


        }

        function updateLogFCHistogram(logFCData) {
            // Extract logFC values and convert them to numbers
            const logFCValues = logFCData.map(entry => entry.logFC);

            // Define histogram parameters
            const svgWidth = 600;
            const svgHeight = 300;
            const margin = { top: 30, right: 20, bottom: 40, left: 50 };
            const width = svgWidth - margin.left - margin.right;
            const height = svgHeight - margin.top - margin.bottom;

            // Create SVG container
            const svg = d3.select("#logFCHistogram")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create histogram using D3.js
            const histogram = d3.histogram()
                .value(d => d)
                .domain(d3.extent(logFCValues))
                .thresholds(100); // Number of bins

            const bins = histogram(logFCValues);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(logFCValues))
                .nice()
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .nice()
                .range([height, 0]);

            // Add histogram bars
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", d => xScale(d.x0))
                .attr("y", d => yScale(d.length))
                .attr("width", d => xScale(d.x1) - xScale(d.x0))
                .attr("height", d => height - yScale(d.length))
                .attr("fill", "orange");

            // Add x-axis
            var xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
            xAxis.selectAll("line, path")
                .style("stroke", "white");
            xAxis.selectAll("text")
                .style("fill", "white");
            // .append("text")
            // .attr("x", width / 2)
            // .attr("y", margin.bottom * 0.8)
            // .attr("text-anchor", "middle")
            // .text("logFC");


            // Add y-axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale))
            // .append("text")
            // .attr("transform", "rotate(-90)")
            // .attr("y", -margin.left * 0.7)
            // .attr("x", -height / 2)
            // .attr("text-anchor", "middle")
            // .text("frequency");

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            // Add X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("Log fold change");

            // Add Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 12)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .text("Frequency");



            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top * 0.1)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("fill", "white")
                .text("FC (logarithmic) frequency distribution");

            // Add ablines
            svg.append("line")
                .attr("x1", xScale(-Math.log2(thr_fc)))
                .attr("y1", 0)
                .attr("x2", xScale(-Math.log2(thr_fc)))
                .attr("y2", height)
                .style("stroke", "darkred")
                .style("stroke-width", "2");

            svg.append("line")
                .attr("x1", xScale(Math.log2(thr_fc)))
                .attr("y1", 0)
                .attr("x2", xScale(Math.log2(thr_fc)))
                .attr("y2", height)
                .style("stroke", "darkred")
                .style("stroke-width", "2");

            // Add overlay for colored portion
            svg.selectAll(".overlay")
                .data(bins)
                .enter()
                .append("rect")
                .attr("class", "overlay")
                .attr("x", d => {
                    const thresholdPosition = xScale(-Math.log2(thr_fc)); // Position of the left abline
                    return thresholdPosition < xScale(d.x0) ? xScale(d.x0) : thresholdPosition; // Start the overlay from the greater of the two positions
                })
                .attr("y", d => yScale(d.length)) // Start from the bottom of each bin
                .attr("width", d => {
                    const thresholdPositionLeft = xScale(-Math.log2(thr_fc)); // Position of the left abline
                    const thresholdPositionRight = xScale(Math.log2(thr_fc)); // Position of the right abline
                    const barWidth = xScale(d.x1) - xScale(d.x0);
                    // Calculate the width of the portion to color
                    return Math.max(0, Math.min(thresholdPositionRight, xScale(d.x1)) - Math.max(thresholdPositionLeft, xScale(d.x0)));
                })
                .attr("height", d => height - yScale(d.length)) // Set the height based on the height of each bin
                .attr("fill", "grey") // Color the portion of the overlay
                .attr("opacity", 1); // Set opacity for transparency


            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width - 150) + "," + 20 + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 5)  // Adjusted x-coordinate to provide some padding
                .attr("y", 5)  // Adjusted y-coordinate to provide some padding
                .attr("width", 160)  // Adjusted width to encapsulate the legend content
                .attr("height", 70)  // Adjusted height to encapsulate the legend content
                .style("stroke", "white")  // Border color
                .style("fill", "none")  // No fill for the rectangle
                .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

            // Add Remaining genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 10)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "orange");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 18)
                .text("Remaining genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");

            // Add Filtered genes
            legend.append("rect")
                .attr("x", 10)
                .attr("y", 35)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", "grey");

            legend.append("text")
                .attr("x", 30)
                .attr("y", 45)
                .text("Filtered genes")
                .attr("text-anchor", "left")
                .style("fill", "white")
                .style("alignment-baseline", "middle");



        }

        function updateVolcanoPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

            var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
                return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
            }, parsed[0]);

            var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
                return currentGene.logFC < minGene.logFC ? currentGene : minGene;
            }, parsed[0]);

            //console.log(mostUpregulatedGene)
            var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
            var mostDownregulatedGeneName = mostDownregulatedGene.Gene;


            // Create circles for each gene
            var data = Object.keys(averageExpressionsN).map(function (gene) {
                // Find the corresponding logFC value from parsedLogFC_origin
                var logFCObj = parsed.find(d => d.Gene === gene) || null;
                var logFC = logFCObj ? logFCObj.logFC : null;

                if (logFC <= log_thr_fc) {
                    var type = "down"
                }
                else {
                    var type = "up"
                }

                var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
                var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

                return { gene: gene, Normal: averageExpressionsN[gene], Case: averageExpressionsC[gene], logFC: logFC, pval_adj: pval_adj, type: type };
            });

            console.log(data);

            // Set up margin, width, and height
            var margin = { top: 10, right: 100, bottom: 40, left: 60 };
            var width = 1000 - margin.left - margin.right;
            var height = 600 - margin.top - margin.bottom;

            // Create SVG container
            var svg = d3.select("#scatterPlot")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Create x and y scales
            var xScale = d3.scaleLinear()
                .domain([
                    d3.min(data, d => d.logFC) - 0.5,
                    d3.max(data, d => d.logFC) + 0.5
                ])
                .range([0, width]);

            yScale = d3.scaleLinear()
                .domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20)))])
                .range([height, 0])
                .nice();

            // Add X axis
            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");

            // Add Y axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            var clip = svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            svg.select("#scatter").selectAll("*").remove();
            scatter = svg.append('g')
                .attr("id", "scatter")
                .attr("clip-path", "url(#clip)");

            // Set the zoom and Pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")  // Set pointer-events to "all" here
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            // Attach click event to the reset button
            d3.select("#resetButton")
                .on("click", resetZoom);

            // Add X axis label with logarithmic notation
            xlab = svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

            // Add Y axis label with logarithmic notation
            ylab = svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
                .style("fill", "white");

            // Add title
            svg.append("text")
                .attr("id", "plotTitle")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Volcano Plot")
                .style("fill", "white");

            // Create circles for each gene
            var tooltip = d3.select("#tooltip");

            svg.select("#scatter").selectAll("*").remove();

            var circles = scatter.selectAll("circle")
                .data(data);

            // Enter new circles
            circles.enter().append("circle")
                .attr("cx", function (d) {
                    if (d.pval_adj !== null) {
                        return xScale(d.logFC)
                    }
                })
                .attr("cy", function (d) {
                    if (d.pval_adj !== null) {
                        return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                    }
                })
                .attr("r", 3) // Start with radius 0 for initial transition effect
                .style("fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "darkred"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "royalblue"; // Downregulated
                        } else {
                            return "grey"; // Not significant
                        }
                    } else {
                        return "grey"; // Not significant
                    }
                })
                .attr("data-initial-fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "darkred"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "royalblue"; // Downregulated
                        } else {
                            return "grey"; // Not significant
                        }
                    } else {
                        return "grey"; // Not significant
                    }
                })
                .classed('pulse', d => {
                    return selectedGeneData.some(selectedGene => selectedGene === d.gene);
                })
                .on("mouseover", function (d) {
                    d3.select(this)
                        .style("stroke", "black")
                        .style("stroke-width", 2);

                    tooltip.transition()
                        .style("opacity", .9);

                    tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                        .style("left", (d3.event.pageX + 15) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function (d) {
                    // Remove the highlight and hide tooltip on mouseout
                    d3.select(this)
                        .style("stroke", "none");

                    tooltip.transition()
                        .style("opacity", 0)
                        .style("visibility", "none")
                        .style("pointer-events", "none"); // Disable pointer events for the tooltip
                })
                .on("click", function (d) {
                    var selectedElement = d3.select(this);
                    var currentFill = selectedElement.style("fill");

                    // Check if the element is already filled with grey
                    if (currentFill === "grey") {
                        return; // If grey, do nothing
                    }

                    // Check if the element is already highlighted
                    var isHighlighted = selectedElement.classed('pulse');

                    if (isHighlighted) {
                        // If already highlighted, remove the highlighting
                        selectedElement.style("fill", d => {
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                return "darkred";
                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                return "royalblue";
                            } else {
                                return "grey";
                            }
                        })
                            .classed('pulse', false)
                            .classed("pulse1", false);

                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                        // Find and remove the corresponding option from the select element
                        var select = document.getElementById("selectButton");
                        var options = select.options;

                        for (var i = 0; i < options.length; i++) {
                            if (!selectedGeneData.includes(options[i].value)) {
                                select.removeChild(options[i]);
                                break; // Exit the loop once the option is removed
                            }
                        }

                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                    } else {
                        // If not highlighted, apply the highlighting
                        selectedElement
                            .style("fill", "green")
                            .style("stroke-width", 2)
                            .classed('pulse', true)
                            .classed('pulse1', false)
                            .raise();  // Move this element to the top

                        // Find the corresponding scatterplot circle and toggle its selection
                        var correspondingSquare = square
                            .filter(function (squaredata) {
                                return squaredata.gene === d.gene;
                            });

                        correspondingSquare.style("stroke", "none");

                        // On click, filter data for the selected gene
                        selectedGeneData.push(d.gene);

                        // Get the select element
                        var select = document.getElementById("selectButton");

                        // Add new options for the genes in selectedGeneData that are not already in the select element
                        selectedGeneData.forEach(function (gene) {
                            if (!Array.from(select.options).some(option => option.value === gene)) {
                                var option = document.createElement("option");
                                option.value = gene;
                                option.text = gene;
                                select.appendChild(option);
                            }
                        });

                        synchronizeAnimations(this);

                        // Call a function to create parallel coordinates plot using selectedGeneData
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                    }
                })
                .each(function (d) {
                    if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        d3.select(this).raise();
                    }
                })


            // Update existing circles with transition
            circles.transition()
                .duration(750)
                .attr("cx", function (d) {
                    if (d.pval_adj !== null) {
                        return xScale(d.logFC)
                    }
                })
                .attr("cy", function (d) {
                    if (d.pval_adj !== null) {
                        return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                    }
                })
                .style("fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "darkred"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "royalblue"; // Downregulated
                        } else {
                            return "grey"; // Not significant
                        }
                    } else {
                        return "grey"; // Not significant
                    }
                })
                .attr("data-initial-fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "darkred"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "royalblue"; // Downregulated
                        } else {
                            return "grey"; // Not significant
                        }
                    } else {
                        return "grey"; // Not significant
                    }
                })
                .attr("r", 3);

            // Exit old circles
            circles.exit()
                .transition()
                .duration(750)
                .attr("r", 0)
                .remove();

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Synchronize the current time of the animation with the target animation
                    if (currentAnimation) {
                        currentAnimation.currentTime = targetTime;
                    }
                });
            }

            function findAnimByName(targetElement, animationName) {
                // Retrieve all the animations associated with the target element
                const animations = targetElement.getAnimations();

                // Find the animation object for the 'pulse' animation
                return animations.find(animation => animation.animationName === animationName);
            }
            function updateChart() {
                // recover the new scale
                var newX = d3.event.transform.rescaleX(xScale);
                var newY = d3.event.transform.rescaleY(yScale);

                // update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX));
                yAxis.call(d3.axisLeft(newY));

                xAxis.selectAll("line, path")
                    .style("stroke", "white");

                xAxis.selectAll("text")
                    .style("fill", "white");

                yAxis.selectAll("line, path")
                    .style("stroke", "white");

                yAxis.selectAll("text")
                    .style("fill", "white");

                // update circle position
                scatter
                    .selectAll("circle")
                    .attr('cx', function (d) { if (d.pval_adj !== null) { return newX(d.logFC); } })
                    .attr('cy', function (d) { if (d.pval_adj !== null) { return newY(-Math.log10(d.pval_adj.toExponential(20))); } });
            }

            // Define the resetZoom function
            function resetZoom() {
                // Reset the zoom transformation
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);
            }

            function SwitchingPlot(structure, choice) {

                if (choice == "volcano") {
                    // Create x and y scales
                    xScale.domain([
                        d3.min(data, d => d.logFC) - 0.5,
                        d3.max(data, d => d.logFC) + 0.5
                    ]);

                    yScale.domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20)))]);

                    // Reset zoom (assuming resetZoom is a function you have defined elsewhere)
                    resetZoom();

                    // Update the zoom behavior to call updateChart1 (assuming updateChart1 is a function you have defined elsewhere)
                    zoom.on("zoom", updateChart);

                    // Apply zoom behavior to the svg
                    svg.call(zoom);

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    xAxis.selectAll("text")
                        .style("fill", "white");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    yAxis.selectAll("text")
                        .style("fill", "white");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Volcano Plot")
                        .style("fill", "white");


                    // Update dots
                    var dot = svg
                        .selectAll('circle')
                        .data(structure)
                    // Remove existing circles
                    dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            return selectedGeneData.some(selectedGene => selectedGene === d.gene);
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            } else {
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("fill", "green")
                                    .style("stroke-width", 2)
                                    .classed('pulse', true)
                                    .classed('pulse1', false)
                                    .raise();  // Move this element to the top

                                // Find the corresponding scatterplot circle and toggle its selection
                                var correspondingSquare = square
                                    .filter(function (squaredata) {
                                        return squaredata.gene === d.gene;
                                    });

                                correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                var select = document.getElementById("selectButton");

                                // Add new options for the genes in selectedGeneData that are not already in the select element
                                selectedGeneData.forEach(function (gene) {
                                    if (!Array.from(select.options).some(option => option.value === gene)) {
                                        var option = document.createElement("option");
                                        option.value = gene;
                                        option.text = gene;
                                        select.appendChild(option);
                                    }
                                });

                                synchronizeAnimations(this);

                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            }
                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) {
                            if (d.pval_adj !== null) {
                                return xScale(d.logFC)
                            }
                        })
                        .attr("cy", function (d) {
                            if (d.pval_adj !== null) {
                                return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                            }
                        })
                        .attr("r", 2) // Start with radius 0 for initial transition effect
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "darkred"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "royalblue"; // Downregulated
                                } else {
                                    return "grey"; // Not significant
                                }
                            } else {
                                return "grey"; // Not significant
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "darkred"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "royalblue"; // Downregulated
                                } else {
                                    return "grey"; // Not significant
                                }
                            } else {
                                return "grey"; // Not significant
                            }
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })



                    function updateChart1() {
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "white");

                        xAxis.selectAll("text")
                            .style("fill", "white");

                        yAxis.selectAll("line, path")
                            .style("stroke", "white");

                        yAxis.selectAll("text")
                            .style("fill", "white");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) { if (d.pval_adj !== null) { return newX(d.logFC); } })
                            .attr('cy', function (d) { if (d.pval_adj !== null) { return newY(-Math.log10(d.pval_adj.toExponential(20))); } });
                    }
                    xlab.html("")
                    ylab.html("")

                    // Add X axis label with logarithmic notation
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "white")
                        .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

                    // Add Y axis label with logarithmic notation
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
                        .style("fill", "white");
                }

                else {

                    xScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsN)))
                        .range([0, width]);
                    //console.log("Domain:", xScale.domain());


                    //console.log(averageExpressionsN);
                    //console.log(averageExpressionsC);
                    yScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsC)))
                        .range([height, 0])
                        .nice()
                    //console.log(yScale);

                    resetZoom()
                    zoom.on("zoom", updateChart1);
                    svg.call(zoom)

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    xAxis.selectAll("text")
                        .style("fill", "white");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    yAxis.selectAll("text")
                        .style("fill", "white");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Scatter Plot")
                        .style("fill", "white");

                    xlab.html("")
                    ylab.html("")
                    // Add X axis label
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "white")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (Normal))</tspan>");

                    // Add Y axis label
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (Case))</tspan>")
                        .style("fill", "white");

                    //svg.select("#scatter").selectAll("*").remove();

                    // Update dots
                    var dot = svg
                        .selectAll('circle')
                        .data(structure)
                    // Remove existing circles
                    //dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                return true;
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                return true;
                            } else {
                                return false;
                            }

                        })
                        .on("mouseover", function (d) {
                            // Highlight the gene on mouseover
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            // Display tooltip on mouseover
                            tooltip.transition()
                                .style("opacity", .9);

                            const parts = d.gene.split('|');
                            // Use the first part as the gene name
                            const geneName = parts[0];

                            tooltip.html(`<strong>Gene:</strong> ${geneName}<br><strong>Normal:</strong> ${d.Normal.toFixed(2)}<br><strong>Case:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? formatPValue(d.pval_adj) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                console.log("sono verde")
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }

                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);
                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                            } else {
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("fill", "green")
                                    .style("stroke-width", 2)
                                    .classed('pulse', true)
                                    .classed('pulse1', false)
                                    .raise();  // Move this element to the top

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                var select = document.getElementById("selectButton");

                                // Add new options for the genes in selectedGeneData that are not already in the select element
                                selectedGeneData.forEach(function (gene) {
                                    if (!Array.from(select.options).some(option => option.value === gene)) {
                                        var option = document.createElement("option");
                                        option.value = gene;
                                        option.text = gene;
                                        select.appendChild(option);
                                    }
                                });

                                synchronizeAnimations(this);

                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                            }


                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", d => {
                            // Log the value of d['Normal'] to inspect its format
                            if (isNaN(d['Normal'])) {
                                console.log("NaN value found in 'Normal':", d['Normal']);
                            }
                            // Convert the value to a number, assuming it's a string
                            return xScale(parseFloat(d['Normal']));
                        })
                        .attr("cy", d => yScale(d['Case']))
                        .attr("r", d => {
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            } else if (d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            } else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "4"
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName) {
                                return "4"
                            }
                        })
                        .style("fill", d => {

                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                                return "green";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                                return "green";
                            }
                            else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {

                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {

                                return "royalblue";
                            }
                            else {
                                return "grey";
                            }
                        })
                        .attr("data-initial-fill", d => {

                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                currentCircleFill = "green"
                                return "green";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                currentCircleFill = "green"
                                return "green";
                            }
                            else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                currentCircleFill = "darkred"
                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                currentCircleFill = "royalblue"
                                return "royalblue";
                            }
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })

                    function updateChart1() {
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "white");

                        xAxis.selectAll("text")
                            .style("fill", "white");

                        yAxis.selectAll("line, path")
                            .style("stroke", "white");

                        yAxis.selectAll("text")
                            .style("fill", "white");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) { return newX(d.Normal); })
                            .attr('cy', function (d) { return newY(d.Case); });
                    }



                }

            }



            d3.select("#switchButton").on("click", function () {
                if (currentPlot === 'volcano') {
                    currentPlot = 'scatter';
                    SwitchingPlot(data, currentPlot)
                } else {
                    currentPlot = 'volcano';
                    SwitchingPlot(data, currentPlot)
                }
            });

            //dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

        }

        function updateScatterPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

            //console.log(parsed)

            var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
                return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
            }, parsed[0]);

            var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
                return currentGene.logFC < minGene.logFC ? currentGene : minGene;
            }, parsed[0]);

            //console.log(mostUpregulatedGene)
            var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
            var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

            // Set up margin, width, and height
            var margin = { top: 10, right: 100, bottom: 40, left: 60 };
            var width = 1000 - margin.left - margin.right;
            var height = 600 - margin.top - margin.bottom;

            // Create SVG container
            var svg = d3.select("#scatterPlot")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Create x and y scales
            var xScale = d3.scaleLinear()
                .domain(d3.extent(Object.values(averageExpressionsN)))
                .range([0, width]);
            console.log("Domain:", xScale.domain());

            var yScale = d3.scaleLinear()
                .domain(d3.extent(Object.values(averageExpressionsC)))
                .range([height, 0])
                .nice()
            //console.log(yScale);

            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale))

            xAxis.selectAll("line, path")
                .style("stroke", "white");

            xAxis.selectAll("text")
                .style("fill", "white");
            // Add Y axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale))

            yAxis.selectAll("line, path")
                .style("stroke", "white");

            yAxis.selectAll("text")
                .style("fill", "white");

            // Customization

            var clip = svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            svg.select("#scatter").selectAll("*").remove();
            scatter = svg.append('g')
                .attr("id", "scatter")
                .attr("clip-path", "url(#clip)");

            // Set the zoom and Pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")  // Set pointer-events to "all" here
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            // Attach click event to the reset button
            d3.select("#resetButton")
                .on("click", resetZoom);

            // Add X axis label
            xlab = svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "white")
                .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (Normal))</tspan>");

            // Add Y axis label
            ylab = svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (Case))</tspan>")
                .style("fill", "white");

            // Add title
            svg.append("text")
                .attr("id", "plotTitle")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Scatter Plot")
                .style("fill", "white");

            // Create circles for each gene
            var data = Object.keys(averageExpressionsN).map(function (gene) {
                // Find the corresponding logFC value from parsedLogFC_origin
                var logFCObj = parsed.find(d => d.Gene === gene) || null;
                var logFC = logFCObj ? logFCObj.logFC : null;

                if (logFC <= log_thr_fc) {
                    var type = "down"
                }
                else {
                    var type = "up"
                }

                var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
                var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

                return { gene: gene, Normal: averageExpressionsN[gene], Case: averageExpressionsC[gene], logFC: logFC, pval_adj: pval_adj, type: type };
            });

            console.log(averageExpressionsN.length)
            //console.log(data.length)

            // Merge data by Gene
            let mergedData = old_p_adj.map(d => {
                let log = parsed.find(p => p.Gene === d.Gene);
                return {
                    Gene: d.Gene,
                    logFC: log.logFC,
                    pval_adj: d.pval_adj ? d.pval_adj : null
                };
            })
            mergedData = mergedData.filter(d => d.logFC !== null && d.pval_adj !== null);

            console.log(mergedData);

            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + (width - 75) + "," + (height - 250) + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Add a rectangle around the legend with shadow
            var legendRect = legend.append("rect")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", 160)
                .attr("height", 210)
                .style("stroke", "white")
                .style("fill", "none")
                .style("filter", "url(#legendShadow)")
                .style("pointer-events", "none");

            // Append legend for upregulated genes (LogFC > log2(thr_fc) and pval_adj < threshold)
            var upregulatedLegend = legend.append("g")
                .attr("transform", "translate(0,0)");

            upregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "darkred");

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "white")
                .style("font-size", "20px")
                .text("Upregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "12px") // Smaller font size for subtitle
                .text("LogFC > log2(" + thr_fc + ") and");

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "white")
                .text("pval_adj < " + threshold)
                .style("font-size", "12px"); // Smaller font size for subtitle

            // Calculate the height of the first legend item
            var legendItemHeight = upregulatedLegend.node().getBBox().height;

            // Append legend for downregulated genes (LogFC < -log2(thr_fc) and pval_adj < threshold)
            var downregulatedLegend = legend.append("g")
                .attr("transform", "translate(0," + 2 * legendItemHeight + ")");

            downregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 65)
                .attr("r", 6)
                .style("fill", "royalblue");

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 68)
                .style("fill", "white")
                .style("font-size", "20px")
                .text("Downregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "12px") // Smaller font size for subtitle
                .text("LogFC < -log2(" + thr_fc + ") and");

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 96)
                .style("fill", "white")
                .text("pval_adj < " + threshold)
                .style("font-size", "12px"); // Smaller font size for subtitle

            // Append legend for not significant genes (abs(LogFC) < log2(thr_fc) OR pval_adj > threshold)
            var notSignificantLegend = legend.append("g")
                .attr("transform", "translate(0," + legendItemHeight + ")");

            notSignificantLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 40)
                .attr("r", 6)
                .style("fill", "grey");

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 40)
                .style("fill", "white")
                .style("font-size", "20px")
                .text("Not Significant")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "12px") // Smaller font size for subtitle
                .text("|LogFC| < log2(" + thr_fc + ") or");

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 68)
                .style("fill", "white")
                .text("pval_adj > " + threshold)
                .style("font-size", "12px"); // Smaller font size for subtitle

            // Add circles to the scatter plot
            var tooltip = d3.select("#tooltip");
            //console.log(data)
            svg.select("#scatter").selectAll("*").remove();
            scatter.selectAll("circle")
                .data(data)
                .enter().append("circle")
                .attr("cx", d => {
                    // Log the value of d['Normal'] to inspect its format
                    if (isNaN(d['Normal'])) {
                        console.log("NaN value found in 'Normal':", d['Normal']);
                    }
                    // Convert the value to a number, assuming it's a string
                    return xScale(parseFloat(d['Normal']));
                })
                .attr("cy", d => yScale(d['Case']))
                .attr("r", d => {
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    } else if (d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "2";
                    } else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                        return "4"
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName) {
                        return "4"
                    }
                })
                .style("fill", d => {

                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                        return "green";
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                        return "green";
                    }
                    else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {

                        return "darkred";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {

                        return "royalblue";
                    }
                    else {
                        return "grey";
                    }
                })
                .attr("data-initial-fill", d => {

                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        currentCircleFill = "green"
                        return "green";
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        currentCircleFill = "green"
                        return "green";
                    }
                    else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                        currentCircleFill = "darkred"
                        return "darkred";
                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                        currentCircleFill = "royalblue"
                        return "royalblue";
                    }
                }

                )
                .classed('pulse', d => {
                    // Check if logFC is greater than or equal to the threshold
                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        return true;
                    }
                    else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        return true;
                    } else {
                        return false;
                    }

                })
                .on("mouseover", function (d) {
                    // Highlight the gene on mouseover
                    d3.select(this)
                        .style("stroke", "black")
                        .style("stroke-width", 2);

                    // Display tooltip on mouseover
                    tooltip.transition()
                        .style("opacity", .9);

                    const parts = d.gene.split('|');
                    // Use the first part as the gene name
                    const geneName = parts[0];

                    tooltip.html(`<strong>Gene:</strong> ${geneName}<br><strong>Normal:</strong> ${d.Normal.toFixed(2)}<br><strong>Case:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? formatPValue(d.pval_adj) : 'NA'}`)
                        .style("left", (d3.event.pageX + 15) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function (d) {
                    // Remove the highlight and hide tooltip on mouseout
                    d3.select(this)
                        .style("stroke", "none");

                    tooltip.transition()
                        .style("opacity", 0)
                        .style("visibility", "none")
                        .style("pointer-events", "none"); // Disable pointer events for the tooltip
                })
                .on("click", function (d) {
                    var selectedElement = d3.select(this);
                    var currentFill = selectedElement.style("fill");

                    // Check if the element is already filled with grey
                    if (currentFill === "grey") {
                        return; // If grey, do nothing
                    }

                    // Check if the element is already highlighted
                    var isHighlighted = selectedElement.classed('pulse');

                    if (isHighlighted) {
                        console.log("sono verde")
                        // If already highlighted, remove the highlighting
                        selectedElement.style("fill", d => {
                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                return "royalblue";
                            } else {
                                return "grey";
                            }

                        })
                            .classed('pulse', false)
                            .classed("pulse1", false);
                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                        // Find and remove the corresponding option from the select element
                        var select = document.getElementById("selectButton");
                        var options = select.options;

                        for (var i = 0; i < options.length; i++) {
                            if (!selectedGeneData.includes(options[i].value)) {
                                select.removeChild(options[i]);
                                break; // Exit the loop once the option is removed
                            }
                        }

                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                    } else {
                        // If not highlighted, apply the highlighting
                        selectedElement
                            .style("fill", "green")
                            .style("stroke-width", 2)
                            .classed('pulse', true)
                            .classed('pulse1', false)
                            .raise();  // Move this element to the top

                        // On click, filter data for the selected gene
                        selectedGeneData.push(d.gene);

                        // Get the select element
                        var select = document.getElementById("selectButton");

                        // Add new options for the genes in selectedGeneData that are not already in the select element
                        selectedGeneData.forEach(function (gene) {
                            if (!Array.from(select.options).some(option => option.value === gene)) {
                                var option = document.createElement("option");
                                option.value = gene;
                                option.text = gene;
                                select.appendChild(option);
                            }
                        });

                        synchronizeAnimations(this);

                        // Call a function to create parallel coordinates plot using selectedGeneData
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                    }
                })
                .each(function (d) {
                    if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                        d3.select(this).raise();
                    }
                })

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }

            function updateChart() {
                // recover the new scale
                var newX = d3.event.transform.rescaleX(xScale);
                var newY = d3.event.transform.rescaleY(yScale);

                // update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX));
                yAxis.call(d3.axisLeft(newY));

                xAxis.selectAll("line, path")
                    .style("stroke", "white");

                xAxis.selectAll("text")
                    .style("fill", "white");

                yAxis.selectAll("line, path")
                    .style("stroke", "white");

                yAxis.selectAll("text")
                    .style("fill", "white");

                // update circle position
                scatter
                    .selectAll("circle")
                    .attr('cx', function (d) { return newX(d.Normal); })
                    .attr('cy', function (d) { return newY(d.Case); });
            }

            // Define the resetZoom function
            function resetZoom() {
                // Reset the zoom transformation
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);
            }


            function SwitchingPlot(structure, choice) {

                if (choice == "volcano") {
                    // Create x and y scales
                    xScale.domain([
                        d3.min(data, d => d.logFC) - 0.5,
                        d3.max(data, d => d.logFC) + 0.5
                    ]);

                    yScale.domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20))) + 1]);

                    // Reset zoom (assuming resetZoom is a function you have defined elsewhere)
                    resetZoom();

                    // Update the zoom behavior to call updateChart1 (assuming updateChart1 is a function you have defined elsewhere)
                    zoom.on("zoom", updateChart1);

                    // Apply zoom behavior to the svg
                    svg.call(zoom);

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    xAxis.selectAll("text")
                        .style("fill", "white");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    yAxis.selectAll("text")
                        .style("fill", "white");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Volcano Plot")
                        .style("fill", "white");


                    // Update dots
                    var dot = svg
                        .selectAll('circle')
                        .data(structure)
                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            return selectedGeneData.some(selectedGene => selectedGene === d.gene);
                        })
                    // Remove existing circles
                    dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            return selectedGeneData.some(selectedGene => selectedGene === d.gene);
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            } else {
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("fill", "green")
                                    .style("stroke-width", 2)
                                    .classed('pulse', true)
                                    .classed('pulse1', false)
                                    .raise();  // Move this element to the top

                                // Find the corresponding scatterplot circle and toggle its selection
                                var correspondingSquare = square
                                    .filter(function (squaredata) {
                                        return squaredata.gene === d.gene;
                                    });

                                correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                var select = document.getElementById("selectButton");

                                // Add new options for the genes in selectedGeneData that are not already in the select element
                                selectedGeneData.forEach(function (gene) {
                                    if (!Array.from(select.options).some(option => option.value === gene)) {
                                        var option = document.createElement("option");
                                        option.value = gene;
                                        option.text = gene;
                                        select.appendChild(option);
                                    }
                                });

                                synchronizeAnimations(this);

                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            }
                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) {
                            if (d.pval_adj !== null) {
                                return xScale(d.logFC)
                            }
                        })
                        .attr("cy", function (d) {
                            if (d.pval_adj !== null) {
                                return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                            }
                        })
                        .attr("r", 3)
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "darkred"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "royalblue"; // Downregulated
                                } else {
                                    return "grey"; // Not significant
                                }
                            } else {
                                return "grey"; // Not significant
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "darkred"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "royalblue"; // Downregulated
                                } else {
                                    return "grey"; // Not significant
                                }
                            } else {
                                return "grey"; // Not significant
                            }
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })



                    function updateChart1() {
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "white");

                        xAxis.selectAll("text")
                            .style("fill", "white");

                        yAxis.selectAll("line, path")
                            .style("stroke", "white");

                        yAxis.selectAll("text")
                            .style("fill", "white");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) {
                                if (d.pval_adj !== null && !isNaN(d.pval_adj)) {
                                    return newX(d.logFC);
                                } else {
                                    return null;
                                }
                            })
                            .attr('cy', function (d) {
                                if (d.pval_adj !== null && !isNaN(d.pval_adj)) {
                                    const pvalAdjLog = -Math.log10(d.pval_adj);
                                    if (!isNaN(pvalAdjLog)) {
                                        return newY(pvalAdjLog);
                                    }
                                }
                                return null;
                            });
                    }
                    xlab.html("")
                    ylab.html("")

                    // Add X axis label with logarithmic notation
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "white")
                        .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

                    // Add Y axis label with logarithmic notation
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
                        .style("fill", "white");
                }

                else {

                    xScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsN)))
                        .range([0, width]);
                    //console.log("Domain:", xScale.domain());


                    //console.log(averageExpressionsN);
                    //console.log(averageExpressionsC);
                    yScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsC)))
                        .range([height, 0])
                        .nice()
                    //console.log(yScale);

                    resetZoom()
                    zoom.on("zoom", updateChart);
                    svg.call(zoom)

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    xAxis.selectAll("text")
                        .style("fill", "white");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "white");

                    yAxis.selectAll("text")
                        .style("fill", "white");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Scatter Plot")
                        .style("fill", "white");

                    xlab.html("")
                    ylab.html("")
                    // Add X axis label
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "white")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (Normal))</tspan>");

                    // Add Y axis label
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (Case))</tspan>")
                        .style("fill", "white");

                    //svg.select("#scatter").selectAll("*").remove();

                    // Update dots
                    var dot = svg
                        .selectAll('circle')
                        .data(structure)

                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            return selectedGeneData.some(selectedGene => selectedGene === d.gene);
                        })

                    // Remove existing circles
                    dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .classed('pulse', d => {
                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                return true;
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                return true;
                            } else {
                                return false;
                            }

                        })
                        .on("mouseover", function (d) {
                            // Highlight the gene on mouseover
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            // Display tooltip on mouseover
                            tooltip.transition()
                                .style("opacity", .9);

                            const parts = d.gene.split('|');
                            // Use the first part as the gene name
                            const geneName = parts[0];

                            tooltip.html(`<strong>Gene:</strong> ${geneName}<br><strong>Normal:</strong> ${d.Normal.toFixed(2)}<br><strong>Case:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? formatPValue(d.pval_adj) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with grey
                            if (currentFill === "grey") {
                                return; // If grey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                console.log("sono verde")
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }

                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);
                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                var select = document.getElementById("selectButton");
                                var options = select.options;

                                for (var i = 0; i < options.length; i++) {
                                    if (!selectedGeneData.includes(options[i].value)) {
                                        select.removeChild(options[i]);
                                        break; // Exit the loop once the option is removed
                                    }
                                }

                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                            } else {
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("fill", "green")
                                    .style("stroke-width", 2)
                                    .classed('pulse', true)
                                    .classed('pulse1', false)
                                    .raise();  // Move this element to the top

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                var select = document.getElementById("selectButton");

                                // Add new options for the genes in selectedGeneData that are not already in the select element
                                selectedGeneData.forEach(function (gene) {
                                    if (!Array.from(select.options).some(option => option.value === gene)) {
                                        var option = document.createElement("option");
                                        option.value = gene;
                                        option.text = gene;
                                        select.appendChild(option);
                                    }
                                });

                                synchronizeAnimations(this);

                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                            }
                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", d => {
                            // Log the value of d['Normal'] to inspect its format
                            if (isNaN(d['Normal'])) {
                                console.log("NaN value found in 'Normal':", d['Normal']);
                            }
                            // Convert the value to a number, assuming it's a string
                            return xScale(parseFloat(d['Normal']));
                        })
                        .attr("cy", d => yScale(d['Case']))
                        .attr("r", d => {
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            } else if (d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "2";
                            } else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
                                return "4"
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName) {
                                return "4"
                            }
                        })
                        .style("fill", d => {

                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                                return "green";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

                                return "green";
                            }
                            else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {

                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {

                                return "royalblue";
                            }
                            else {
                                return "grey";
                            }
                        })
                        .attr("data-initial-fill", d => {

                            // Check if logFC is greater than or equal to the threshold
                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                currentCircleFill = "green"
                                return "green";
                            }
                            else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                currentCircleFill = "green"
                                return "green";
                            }
                            else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                currentCircleFill = "darkred"
                                return "darkred";
                            } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                currentCircleFill = "royalblue"
                                return "royalblue";
                            }
                        })
                        .each(function (d) {
                            if (selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
                                d3.select(this).raise();
                            }
                        })


                }

            }



            d3.select("#switchButton").on("click", function () {
                if (currentPlot === 'volcano') {
                    currentPlot = 'scatter';
                    SwitchingPlot(data, currentPlot)
                } else {
                    currentPlot = 'volcano';
                    SwitchingPlot(data, currentPlot)
                }
            });
            // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

        }


        function formatPValue(pval) {
            // Check if the p-value is too small to be displayed without scientific notation
            if (pval < 0.01) {
                // Use toExponential to format the p-value in scientific notation with two decimal places
                return pval.toExponential(3);
            } else {
                // Otherwise, use toFixed to format the p-value with two decimal places
                return pval.toFixed(2);
            }
        }


        let last_box = ""

        function updateBoxPlot(genename, parsedLogFC, dataN, dataC) {
            console.log(genename)
            if (combinedData.length == 0) {
                last_box = genename
                geneNameUP = genename;

                console.log(dataN_copy_pval[0])


                var geneDataN = dataN_copy.filter(d => d.gene === geneNameUP)
                var geneDataC = dataC_copy.filter(d => d.gene === geneNameUP)


                console.log(geneDataC)

                // Extract GSM values for each gene
                var gsmValuesC = Object.keys(geneDataC[0]).filter(key => !key.startsWith('gene'));
                var gsmValuesN = Object.keys(geneDataN[0]).filter(key => !key.startsWith('gene'));


                function computeBoxPlotStatistics(data1) {
                    var expressionValues = data1.map(entry => entry.expression);

                    // Sort the data for calculating quartiles
                    expressionValues.sort((a, b) => a - b);

                    // Calculate quartiles and median
                    var q1 = d3.quantile(expressionValues, 0.25);
                    var q3 = d3.quantile(expressionValues, 0.75);
                    var median = d3.median(expressionValues);

                    // Calculate interquartile range (IQR)
                    var iqr = q3 - q1;


                    var min = q1 - 1.5 * iqr
                    var max = q3 + 1.5 * iqr

                    return {
                        q1: q1,
                        median: median,
                        q3: q3,
                        iqr: iqr,
                        min: min,
                        max: max
                    };
                }

                let expressionValuesC
                geneDataC.forEach(entry => {
                    expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

                })

                //console.log(expressionValuesC)

                let expressionValuesN
                geneDataN.forEach(entry => {
                    expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

                })
                // Assuming you have expressionValuesC and expressionValuesN

                // Create a new array to store the combined data
                //combinedData;

                // Iterate over expressionValuesC and add objects to combinedData with type 'case'
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: 'Case' });
                });

                // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: 'Normal' });
                });

                console.log(combinedData)

                var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


                sumstat = d3.nest()
                    .key(function (d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
                    .rollup(function (d) {
                        q1 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.25);
                        median = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.5);
                        q3 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.75);
                        interQuantileRange = q3 - q1;
                        min = q1 - 1.5 * interQuantileRange;
                        max = q3 + 1.5 * interQuantileRange;

                        return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
                    })
                    .entries(combinedData);

                var margin = { top: 10, right: 30, bottom: 30, left: 50 },
                    width = 500,
                    height = 330;


                var svg = d3.select("#boxPlot")
                    .html("")  // Clear previous content
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");

                var x = d3.scaleBand()
                    .range([0, width])
                    .domain(["Normal", "Case"])
                    .paddingInner(1)
                    .paddingOuter(.5)

                var xAxis = svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x))
                xAxis.selectAll("line, path")
                    .style("stroke", "white");
                xAxis.selectAll("text")
                    .style("fill", "white");

                var y = d3.scaleLinear()
                    .domain([boxPlotStatisticsC.min - 4, boxPlotStatisticsC.max + 4])
                    .range([height, 0])

                var yAxisGroup = svg.append("g")
                    .attr("class", "y-axis") // Assign a class to the group element
                    .call(d3.axisLeft(y));

                // Append the y-axis label
                yAxisGroup.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -40)  // Adjust the position as needed
                    .attr("x", -height / 2)
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .style("fill", "white")
                    .style("font-size", "14px")
                    .html("log<tspan dy='5'>2</tspan> <tspan dy ='-5'>(Expression)");


                // You can further customize the appearance of the axis elements if needed
                yAxisGroup.selectAll("line, path")
                    .style("stroke", "white");

                yAxisGroup.selectAll("text")
                    .style("fill", "white");

                // Add a title
                var title = svg.append("text")
                    .attr("class", "title")
                    .attr("x", width / 2)
                    .attr("y", margin.top)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .text("Gene " + geneNameUP)
                    .style("fill", "white");

                svg.selectAll(".vertLines")
                    .data(sumstat)
                    .transition()
                    .duration(1000)

                var line1 = svg
                    .selectAll(".vertLines")
                    .data(sumstat)
                    .enter()
                    .append("line")
                    .attr("class", "vertLines")
                    .attr("x1", function (d) { return (x(d.key)) })
                    .attr("x2", function (d) { return (x(d.key)) })
                    .attr("y1", function (d) { return (y(d.value.min)) })
                    .attr("y2", function (d) { return (y(d.value.max)) })
                    .attr("stroke", "black")
                    .style("width", 40)


                // rectangle for the main box
                var boxWidth = 100
                var box1 = svg
                    .selectAll(".boxes")
                    .data(sumstat)
                    .enter()
                    .append("rect")
                    .attr("class", "boxes")
                    .attr("x", function (d) { return (x(d.key) - boxWidth / 2) })
                    .attr("y", function (d) { return (y(d.value.q3)) })
                    .attr("height", function (d) { return (y(d.value.q1) - y(d.value.q3)) })
                    .attr("width", boxWidth)
                    .attr("stroke", "black")
                    .style("fill", function (d) {
                        if (d.key === "Case") {
                            return "#a05853"
                        }
                        else {
                            return "#118e91"
                        }
                    })
                var line2 = svg
                    .selectAll(".medianLines")
                    .data(sumstat)
                    .enter()
                    .append("line")
                    .attr("class", "medianLines")
                    .attr("x1", function (d) { return (x(d.key) - boxWidth / 2) })
                    .attr("x2", function (d) { return (x(d.key) + boxWidth / 2) })
                    .attr("y1", function (d) { return (y(d.value.median)) })
                    .attr("y2", function (d) { return (y(d.value.median)) })
                    .attr("stroke", "black")
                    .style("width", 80)

                var jitterWidth = 50
                var jitter = svg
                    .selectAll(".indPoints")
                    .data(combinedData)
                    .enter()
                    .append("circle")
                    .attr("class", function (d) {
                        // Add the pulse-red class if the GSM is in the gsmList
                        return gsmList.includes(d.GSM) ? "indPoints pulse-red" : "indPoints";
                    })
                    .attr("cx", function (d) { return (x(d.type) - jitterWidth / 2 + Math.random() * jitterWidth) })
                    .attr("cy", function (d) { return (y(d.expression)) })
                    .attr("r", 2)
                    .style("fill", "white")
                    .attr("stroke", function (d) {

                        return gsmList.includes(d.GSM) ? "black" : "black";

                    })
                    .attr("stroke-width", function (d) {
                        // Set stroke width based on presence in gsmList
                        return gsmList.includes(d.GSM) ? 3 : 1;
                    })
                    .on("click", function (d) {
                        // On click, select the circle and add the GSM value to the list
                        var selectedGSM = d.GSM;
                        var isSelected = gsmList.includes(selectedGSM);
                        // console.log(isSelected);

                        // Toggle selection state
                        if (!isSelected) {
                            gsmList.push(selectedGSM);

                        } else {
                            gsmList = gsmList.filter(gsm => gsm !== selectedGSM);
                        }

                        // Update class, stroke, and stroke-width
                        d3.select(this)
                            .classed("pulse-red", !isSelected)
                            .attr("stroke", isSelected ? "black" : "black")
                            .attr("stroke-width", isSelected ? 1 : 2);

                        synchronizeAnimations();

                        // Call necessary update functions
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                        console.log("PCA DATA IN BOXPLOT", pca_data)
                        pca(pca_data);


                    });


            } else {

                if (genename !== last_box) {
                    console.log(last_box)
                    last_box = genename
                    combinedData = []
                    geneNameUP = genename;
                    console.log(genename)

                    var geneDataN = dataN_copy.filter(d => d.gene === geneNameUP)
                    var geneDataC = dataC_copy.filter(d => d.gene === geneNameUP)



                    // Extract GSM values for each gene
                    console.log(geneDataC[0])
                    var gsmValuesC = Object.keys(geneDataC[0]).filter(key => !key.startsWith('gene'));
                    var gsmValuesN = Object.keys(geneDataN[0]).filter(key => !key.startsWith('gene'));
                    console.log(gsmValuesN)


                    function computeBoxPlotStatistics(data1) {
                        var expressionValues = data1.map(entry => entry.expression);

                        // Sort the data for calculating quartiles
                        expressionValues.sort((a, b) => a - b);

                        // Calculate quartiles and median
                        var q1 = d3.quantile(expressionValues, 0.25);
                        var q3 = d3.quantile(expressionValues, 0.75);
                        var median = d3.median(expressionValues);

                        // Calculate interquartile range (IQR)
                        var iqr = q3 - q1;


                        var min = q1 - 1.5 * iqr
                        var max = q3 + 1.5 * iqr

                        return {
                            q1: q1,
                            median: median,
                            q3: q3,
                            iqr: iqr,
                            min: min,
                            max: max
                        };
                    }

                    let expressionValuesC
                    geneDataC.forEach(entry => {
                        expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));
                    })

                    //console.log(expressionValuesC)

                    let expressionValuesN
                    geneDataN.forEach(entry => {
                        expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));
                    })
                    // Assuming you have expressionValuesC and expressionValuesN

                    // Create a new array to store the combined data
                    //combinedData;

                    // Iterate over expressionValuesC and add objects to combinedData with type 'case'
                    expressionValuesC.forEach((expression, i) => {
                        combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: 'Case' });
                    });

                    // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
                    expressionValuesN.forEach((expression, i) => {
                        combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: 'Normal' });
                    });

                    console.log(combinedData)

                    var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


                    sumstat = d3.nest()
                        .key(function (d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
                        .rollup(function (d) {
                            q1 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.25);
                            median = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.5);
                            q3 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.75);
                            interQuantileRange = q3 - q1;
                            min = q1 - 1.5 * interQuantileRange;
                            max = q3 + 1.5 * interQuantileRange;

                            return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
                        })
                        .entries(combinedData);
                    var margin = { top: 10, right: 30, bottom: 30, left: 50 },
                        width = 500,
                        height = 330;


                    // Select the SVG element
                    var svg = d3.select("#boxPlot").select("svg").select("g");

                    var x = d3.scaleBand()
                        .range([0, width])
                        .domain(["Normal", "Case"])
                        .paddingInner(1)
                        .paddingOuter(.5)

                    var y = d3.scaleLinear()
                        .domain([boxPlotStatisticsC.min - 4, boxPlotStatisticsC.max + 4])
                        .range([height, 0])

                    // Update y-axis
                    svg.select(".y-axis")
                        .transition()
                        .duration(1000)
                        .call(d3.axisLeft(y));

                    // Update axis styles
                    svg.selectAll(".y-axis line, .y-axis path")
                        .style("stroke", "white");

                    svg.selectAll(".y-axis text")
                        .style("fill", "white");


                    // Select the existing title element
                    var title = svg.select(".title");

                    // Update the title text and transition its position
                    title.text("Gene " + geneNameUP)
                        .transition()
                        .duration(1000)
                        .attr("x", width / 2)
                        .attr("y", margin.top);

                    var line1 = svg.selectAll(".vertLines")
                        .data(sumstat);

                    // Remove old lines
                    line1.exit().remove();

                    // Update existing lines
                    line1.transition()
                        .duration(1000)
                        .attr("x1", function (d) { return x(d.key); })
                        .attr("x2", function (d) { return x(d.key); })
                        .attr("y1", function (d) { return y(d.value.min); })
                        .attr("y2", function (d) { return y(d.value.max); })
                        .attr("stroke", "black")
                        .style("width", 40);

                    // Append new lines
                    line1.enter()
                        .append("line")
                        .attr("class", "vertLines")
                        .attr("x1", function (d) { return x(d.key); })
                        .attr("x2", function (d) { return x(d.key); })
                        .attr("y1", function (d) { return y(d.value.min); })
                        .attr("y2", function (d) { return y(d.value.max); })
                        .attr("stroke", "black")
                        .style("width", 40);

                    boxWidth = 100

                    // Define the initial position and size of the boxes
                    var box1 = svg.selectAll(".boxes")
                        .data(sumstat);

                    // Remove old boxes
                    box1.exit().remove();

                    // Update existing boxes
                    box1.transition()
                        .duration(1000)
                        .attr("x", function (d) {
                            return x(d.key) - boxWidth / 2;
                        })
                        .attr("y", function (d) {
                            return y(d.value.q3);
                        })
                        .attr("height", function (d) {
                            return y(d.value.q1) - y(d.value.q3);
                        })
                        .attr("width", boxWidth) // Keep width constant
                        .style("fill", function (d) {
                            return d.key === "Case" ? "#a05853" : "#118e91";
                        });

                    // Append new boxes and smoothly transition them to their new positions
                    box1.enter()
                        .append("rect")
                        .attr("class", "boxes")
                        .attr("stroke", "black")
                        .style("fill", function (d) {
                            return d.key === "Case" ? "#a05853" : "#118e91";
                        })
                        .attr("x", function (d) { return x(d.key) - boxWidth / 2; }) // Set initial position
                        .attr("y", function (d) { return y(d.value.q3); }) // Set initial position
                        .attr("height", 0) // Set initial height to 0
                        .attr("width", boxWidth) // Keep width constant
                        .transition() // Transition to new position and size
                        .duration(1000)
                        .attr("y", function (d) { return y(d.value.q3); }) // Transition to new y position
                        .attr("height", function (d) { return y(d.value.q1) - y(d.value.q3); }); // Transition to new height

                    // Select existing median lines and smoothly update them
                    var medianLines = svg.selectAll(".medianLines")
                        .data(sumstat);

                    // Remove old median lines
                    medianLines.exit().remove();

                    // Update existing median lines
                    medianLines.transition()
                        .duration(1000)
                        .attr("x1", function (d) { return x(d.key) - boxWidth / 2; })
                        .attr("x2", function (d) { return x(d.key) + boxWidth / 2; })
                        .attr("y1", function (d) { return y(d.value.median); })
                        .attr("y2", function (d) { return y(d.value.median); });

                    // Append new median lines
                    medianLines.enter()
                        .append("line")
                        .attr("class", "medianLines")
                        .attr("stroke", "black")
                        .style("width", 80)
                        .attr("x1", function (d) { return x(d.key) - boxWidth / 2; })
                        .attr("x2", function (d) { return x(d.key) + boxWidth / 2; })
                        .attr("y1", function (d) { return y(d.value.median); })
                        .attr("y2", function (d) { return y(d.value.median); });

                    // Select the existing title or append a new one if it doesn't exist
                    var title = svg.selectAll(".title")
                        .data([0]); // Use dummy data to ensure only one title is selected or appended

                    // Update existing title text
                    title.text("Gene " + geneNameUP);

                    // Append new title if it doesn't exist
                    title.enter()
                        .append("text")
                        .attr("class", "title")
                        .attr("x", width / 2)
                        .attr("y", margin.top)
                        .attr("text-anchor", "middle")
                        .style("font-size", "18px")
                        .style("fill", "white")
                        .text("Gene " + geneNameUP);

                    // Smoothly transition the title position
                    title.transition()
                        .duration(1000)
                        .attr("x", width / 2)
                        .attr("y", margin.top);

                    // Update jitter points
                    var jitterWidth = 50;
                    var jitter = svg.selectAll(".indPoints")
                        .data(combinedData);

                    jitter.enter()
                        .append("circle")
                        .attr("class", ".indPoints")
                        .attr("stroke", "black")
                        .style("fill", "white")
                        .attr("r", 2)
                        .merge(jitter)
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) { console.log("circle"); return x(d.type) - jitterWidth / 2 + Math.random() * jitterWidth; })
                        .attr("cy", function (d) { return y(d.expression); });

                    jitter.exit().remove();

                } else {
                    console.log(dataN_copy_pval[0])

                    console.log("Sono update box, gene ricevuto " + genename)

                    // Select the SVG element
                    var svg = d3.select("#boxPlot").select("svg").select("g");


                    var jitterWidth = 50
                    // Define the update selection for the jitter circles
                    var jitterUpdate = svg.selectAll(".indPoints")
                        .data(combinedData);

                    console.log(combinedData)

                    // Update the class, stroke, and stroke width based on the GSM list
                    jitterUpdate.attr("class", function (d) {
                        // console.log(gsmList.includes(d.GSM));
                        if (gsmList.includes(d.GSM)) {
                            // this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                        }
                        return gsmList.includes(d.GSM) ? "indPoints pulse-red" : "indPoints";
                    })
                        .attr("stroke", function (d) {
                            return gsmList.includes(d.GSM) ? "black" : "black";
                        })
                        .attr("stroke-width", function (d) {
                            return gsmList.includes(d.GSM) ? 3 : 1;
                        })
                        .on("click", function (d) {
                            console.log(d)
                            var selectedGSM = d.GSM;
                            var isSelected = gsmList.includes(selectedGSM);
                            // console.log(isSelected);

                            // Toggle selection state
                            if (!isSelected) {
                                gsmList.push(selectedGSM);
                            } else {
                                gsmList = gsmList.filter(gsm => gsm !== selectedGSM);
                            }

                            // Update class, stroke, and stroke-width
                            d3.select(this)
                                .classed("pulse-red", !isSelected)
                                .attr("stroke", isSelected ? "black" : "black")
                                .attr("stroke-width", isSelected ? 1 : 2);
                            synchronizeAnimations()
                            // Call necessary update functions
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                            console.log("PCA DATA IN BOXPLOT", pca_data)
                            pca(pca_data);
                        });

                    // Enter selection: No need to append new circles, as we're only updating existing ones

                    // Remove old circles
                    jitterUpdate.exit().remove();
                }
            }
            d3.select("#selectButton").on("change", function (d) {

                // recover the option that has been chosen
                var selectedOption = d3.select(this).property("value")
                console.log(selectedOption)
                updateBoxPlot(selectedOption, parsedLogFC, dataN_copy, dataC_copy)
            })

            synchronizeAnimations()


            function synchronizeAnimations() {
                // Retrieve all elements with the class 'pulse'
                const elements = document.querySelectorAll(".pulse-red")
                console.log(elements)
                if (elements.length === 0) {
                    return
                }

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(elements[0], 'pulseRedAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseRedAnimation');

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }
            // combinedData = []
        }

        function dynamicParallel(geneselected, data, dataC, dataN, first_dims, totalOrder) {

            let structureCombinedData = [];

            console.log(geneselected)

            geneselected.forEach(geneName => {
                var geneDataN = dataN.filter(d => d.gene === geneName);
                var geneDataC = dataC.filter(d => d.gene === geneName);

                if (geneDataN.length == 0) {
                    selectedGeneData = [];
                    geneselected = [];
                    return;
                }

                // Extract sample names for each gene
                var sampleKeysC = Object.keys(geneDataC[0]).filter(key => key !== "gene");
                var sampleKeysN = Object.keys(geneDataN[0]).filter(key => key !== "gene");

                let expressionValuesC = [];
                geneDataC.forEach(entry => {
                    expressionValuesC.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                let expressionValuesN = [];
                geneDataN.forEach(entry => {
                    expressionValuesN.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                var combinedData = [];
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ sample: sampleKeysC[i], expression: expression, type: chosen_meta2, index: i });
                });
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ sample: sampleKeysN[i], expression: expression, type: chosen_meta1, index: i });
                });

                structureCombinedData.push({
                    gene: geneName,
                    expressions: combinedData
                });
            });

            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 50, bottom: 10, left: 50 },
                width = 1000 - margin.left - margin.right,
                height = 320 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#parallelcoordinates")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var color;
            if (selectedVariable === "case") {
                color = d3.scaleOrdinal()
                    .domain([chosen_meta1, chosen_meta2])
                    .range(["#0d0887", "#fddb6d"]);
            }
            // Initialize y scale object
            var y = {};

            // Extract metadata categories from the values of the first column
            var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
            console.log("Metadata categories:", metadataCategories);
            var orderedCategories = Object.keys(colorScaleValues);
            console.log("Ordered categories:", orderedCategories);

            // Initialize y scale object
            var y = {};

            // Iterate through ordered categories to create y scales
            metadataCategories.forEach((category, i) => {
                if (colorScaleValues[category]) {
                    var values = Object.keys(colorScaleValues[category]); // Extract values for the current category
                    console.log("Values for", category, ":", values);
                    y[category] = d3.scaleOrdinal()
                        .domain(values) // Use unique values for the current category
                        .range([...Array(values.length).keys()].map(i => i * (height / (values.length - 1))));
                } else {
                    var values = Object.values(metadata[i]); // Extract values for the current category
                    values.shift(); // Remove the first value (Sample_source_name_ch1)
                    var uniqueValues = [...new Set(values)]; // Filter out duplicate
                    uniqueValues.sort()
                    uniqueValues.reverse()
                    console.log("Values for", category, ":", values);
                    // Calculate the step size for placing values on the y-axis
                    var stepSize = height / (uniqueValues.length + 1); // Adjust +1 to leave some space at the top

                    // Create ordinal scale using D3.js
                    y[category] = d3.scaleOrdinal()
                        .domain(uniqueValues) // Use unique values for the current category
                        .range([...Array(uniqueValues.length).keys()].map(i => (i + 1) * stepSize)); // Adjust the range
                }
            });

            // Now y scales are ordered according to colorScaleValues
            console.log("Y scales:", y);


            // Iterate through metadata categories to create y scales
            // metadataCategories.forEach((category, i) => {
            //     var values = Object.values(metadata[i]); // Extract values for the current category
            //     values.shift(); // Remove the first value (Sample_source_name_ch1)
            //     var uniqueValues = [...new Set(values)]; // Filter out duplicate
            //     console.log("Values for", category, ":", uniqueValues);
            //     y[category] = d3.scaleOrdinal()
            //         .domain(uniqueValues) // Use unique values for the current category
            //         .range([...Array(uniqueValues.length).keys()].map(i => height - i * (height / (uniqueValues.length - 1))));
            // });

            for (var i in geneselected) {
                var name = geneselected[i];
                y[name] = d3.scaleLinear()
                    .domain([0, 20])
                    .range([height, 0]);
            }
            console.log("Y scales:", y);

            // Initialize transposedData array
            var transposedData = [];

            // Iterate over each metadata category
            metadataCategories.forEach((category, index) => {
                // Skip the first category (Sample_geo_accession)
                if (index === 0) return;

                // Iterate over each sample in the metadata
                Object.keys(metadata[index]).forEach((sampleKey, sampleIndex) => {
                    // Skip the first key (Sample_geo_accession)
                    if (sampleIndex === 0) return;

                    // If transposedData is not initialized for this sample, initialize it
                    if (!transposedData[sampleKey]) {
                        transposedData[sampleKey] = { [metadataCategories[0]]: metadata[0][sampleKey] };
                    }

                    // Add metadata values for each category to the transposedData
                    transposedData[sampleKey][category] = metadata[index][sampleKey];
                });
            });

            // Extract gene names from structureCombinedData
            var geneNames = structureCombinedData.map(d => d.gene);

            // Combine metadata categories and gene names
            var allCategories = [...metadataCategories, ...geneNames];
            console.log("All Categories " + allCategories)

            if (totalOrder !== undefined) {
                dimensions = totalOrder
            } else {
                dimensions = first_dims.concat(geneselected);

            }

            var colorScale
            console.log(selectedVariable)

            function getColorScale(selectedVariable) {
                // Retrieve the predefined colors for the selected variable
                var variableColors = colorScaleValues[selectedVariable];

                // Get the unique values (keys) and their corresponding colors
                var uniqueValues = Object.keys(variableColors);
                var colors = uniqueValues.map(value => variableColors[value]);

                // Generate a color scale using the predefined colors
                colorScale = d3.scaleOrdinal()
                    .domain(uniqueValues)
                    .range(colors);

                // Log the domain and range of the color scale
                console.log("Color scale domain (unique values):", colorScale.domain());
                console.log("Color scale range (assigned colors):", colorScale.range());

                return colorScale;
            }


            getColorScale(selectedVariable)

            var legend = d3.select("#parallelLegend");
            legend.html(""); // Clear previous legend content

            // Define legend dimensions and position
            var legendWidth = 550;
            var legendHeight = 60;
            var legendX = 20;
            var legendY = 10;


            // Create legend
            legend = d3.select("#parallelLegend")
                .append("svg")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .append("g")
                .attr("class", "legendOrdinal")
                .attr("transform", "translate(" + legendX + "," + legendY + ")");

            // Define legend color scale
            var legendColor = d3.legendColor()
                .shapeWidth(60) // Adjust shape width as needed
                .orient('horizontal')
                .labelWrap(30)
                .scale(colorScale);

            // Append legend to the SVG
            legend.call(legendColor);

            // Truncate labels and add tooltips for full text
            legend.selectAll(".label")
                .each(function (d) {
                    var self = d3.select(this);
                    var textNode = self.node().childNodes[0]; // Get the text node
                    var text = textNode.textContent; // Get the text content
                    console.log(text)
                    var maxLength = 7; // Set the maximum length for the label before truncating
                    if (this.textContent.length > maxLength) {
                        var truncatedText = text.slice(0, maxLength) + '...';
                        self.text(truncatedText);
                        self.append("title").text(d); // Add full text as a tooltip
                    }
                });



            // Set legend label color and style
            legend.selectAll(".label")
                .style("fill", "white") // Set label color to white
                .style("font-size", "14px")  // Adjust font size
                .style("white-space", "pre")

            // Adjust label position
            legend.selectAll("text")
                .attr("dy", "-0.35em"); // Adjust vertical alignment

            console.log(dimensions)

            // Build the X scale -> it finds the best position for each Y axis
            var x = d3.scalePoint()
                .range([0, width])
                .domain(dimensions);

            // Iterate over each gene in structureCombinedData
            structureCombinedData.forEach(geneData => {
                // Loop through each sample in the gene's expression data
                geneData.expressions.forEach(sampleData => {
                    const sampleKey = sampleData.sample;

                    // If transposedData is not initialized for this sample, initialize it
                    if (!transposedData[sampleKey]) {
                        transposedData[sampleKey] = { [metadataCategories[0]]: metadata[0][sampleKey] };
                    }

                    // Add gene expression values for each gene to the transposedData
                    transposedData[sampleKey][geneData.gene] = sampleData.expression;
                });
            });


            // Log transposedData
            console.log("Transposed Data:", transposedData);
            var test = 0;
            var gsmPaths = svg.selectAll(".gsm-path")
                .data(Object.keys(transposedData))
                .enter()
                .append("path")
                .attr("class", function (d) {
                    // Add the pulse-red class if the GSM is in the gsmList
                    return gsmList.includes(d) ? "gsm-path pulse-red" : "gsm-path";
                })
                .attr("d", function (d) {
                    // Construct the path string using the order of dimensions specified by metadataCategories
                    return pathString(transposedData[d]);
                })
                .style("fill", "none")
                .style("stroke", function (d) {
                    var selectedValue = transposedData[d][selectedVariable];
                    // Add logic here to set stroke color based on sampleSource
                    return colorScale(selectedValue);
                    // Add logic here to set stroke color based on selectedVariable
                });

            // Function to construct the path string
            // Initialize an empty array to store coordinates
            function pathString(sampleData) {
                // Initialize an empty array to store coordinates
                var coordinates = [];
                // Loop through each dimension in metadataCategories
                dimensions.forEach(function (category) {
                    // Push the x and y coordinates to the coordinates array
                    coordinates.push([x(category), y[category](sampleData[category])]);
                });
                // Use D3's line generator to generate the path string
                return d3.line()(coordinates);
            }

            gsmPaths.on("click", function (d) {
                console.log(d)
                var clickedGSM = d; // Get the GSM value of the clicked path

                // Check if the clicked GSM is already in gsmList
                var index = gsmList.indexOf(clickedGSM);
                if (index === -1) {
                    // If not in the list, add it
                    gsmList.push(clickedGSM);
                    synchronizeAnimations(this)
                } else {
                    // If already in the list, remove it
                    gsmList.splice(index, 1);
                }
                console.log(gsmList)

                // Update the class of the clicked path based on its presence in gsmList
                d3.select(this)
                    .classed("pulse-red", gsmList.includes(clickedGSM));

                console.log("PCA DATA IN PARRALLEL", pca_data)

                pca(pca_data)

                updateBoxPlot(last_box, parsedLogFC, dataN_copy, dataC_copy)



            });

            function path(d) {
                return d3.line()(dimensions.map(function (geneName) { return [x(geneName), y[geneName](d[geneName])]; }));
            }

            svg.selectAll(".gsm-path").each(function (data, i) {
                // Reorder the SVG elements to bring paths with selected GSM to the front
                gsmPaths.each(function () {
                    var selectedGSM = d3.select(this).datum();
                    if (gsmList.includes(selectedGSM)) {
                        this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                    }
                });

                //console.log("Data bound to path " + (i + 1) + ":", data);
            });

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = document.querySelectorAll(".pulse-red")


                console.log(elements)

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseRedAnimation');

                if (!targetAnimation) {
                    return
                }

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseRedAnimation');

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }


            // Draw the axis:
            var axis = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    d3.select(this).call(d3.axisLeft().scale(y[d]));
                });

            axis.append("text")
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    return d;
                    // Set the label text for "Type" axis
                    //return d === "type" ? "Type" : d;
                })
                .style("fill", "white");

            axis.selectAll(".domain")
                .attr("stroke", "white");

            axis.selectAll(".tick text")
                .style("fill", "white");
            axis.selectAll(".tick line")
                .attr("stroke", "white");

            // Add truncated y-axis labels with tooltips
            axis.selectAll(".tick text")
                .each(function (d) {
                    var self = d3.select(this);
                    var text = d; // Full label text from the data bound
                    var maxLength = 5; // Set the maximum length for the label before truncating

                    // Add tooltip
                    self.append("title").text(text); // Add full text as a tooltip

                    // Truncate text if necessary
                    if (text.length > maxLength) {
                        var truncatedText = text.slice(0, maxLength) + '...';
                        self.text(truncatedText);
                    }
                });


            // Define drag behavior
            var drag = d3.drag()
                .on("start", dragstart)
                .on("drag", dragmove)
                .on("end", dragend);

            // Draw the axis:
            var axisGroups = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("class", "axis-group")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    d3.select(this).call(d3.axisLeft().scale(y[d]));
                })
                .call(drag); // Apply drag behavior to each axis group;

            axisGroups.append("text")
                .attr("class", "dragging") // Add the axis-label class
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    // Set the label text for "Type" axis
                    return d;
                })
                .style("fill", "white");

            axisGroups.selectAll(".domain")
                .attr("stroke", "white");

            axisGroups.selectAll(".tick text")
                .style("fill", "white");

            axisGroups.selectAll(".tick line")
                .attr("stroke", "white");

            // Add truncated y-axis labels with tooltips
            axisGroups.selectAll(".tick text")
                .each(function (d) {
                    var self = d3.select(this);
                    var text = d; // Full label text from the data bound
                    var maxLength = 5; // Set the maximum length for the label before truncating

                    // Add tooltip
                    self.append("title").text(text); // Add full text as a tooltip

                    // Truncate text if necessary
                    if (text.length > maxLength) {
                        var truncatedText = text.slice(0, maxLength) + '...';
                        self.text(truncatedText);
                    }
                });



            // Drag start function
            function dragstart(d) {
                // Raise the dragged axis to the front
                d3.select(this).raise().classed("active", true);
                d3.select(this).classed("dragging", true);

            }

            // Drag move function
            function dragmove(d) {
                // Update the position of the dragged axis
                var newPosition = d3.event.x;
                d3.select(this).attr("transform", "translate(" + newPosition + ")");
            }

            function dragend(d) {
                // Get the new positions of the axis groups
                var newPositions = [];
                svg.selectAll(".axis-group").each(function (d) {
                    var transform = d3.select(this).attr("transform");
                    var translateX = +transform.split("(")[1].split(")")[0];
                    console.log(translateX)
                    newPositions.push({ dimension: d, position: translateX });
                });

                // Sort newPositions array based on position
                newPositions.sort(function (a, b) {
                    return a.position - b.position;
                });

                // Separate dimensions into geneselected, metadata (first_dims), and total ordering
                var geneselectedOrder = [];
                var metadataOrder = [];
                totalOrder = [];
                newPositions.forEach(function (d) {
                    if (geneselected.includes(d.dimension)) {
                        geneselectedOrder.push(d.dimension);
                    } else if (first_dims.includes(d.dimension)) {
                        metadataOrder.push(d.dimension);
                    }
                    totalOrder.push(d.dimension);
                });
                console.log(totalOrder)

                // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
                var removedDimensions = [];
                newPositions.forEach(function (d) {
                    console.log(d.position)
                    if ((d.position < -100 || d.position > 1000) && geneselected.includes(d.dimension)) {
                        var index = geneselectedOrder.indexOf(d.dimension);
                        if (index !== -1) {
                            removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                            // Remove highlighting color in the scatter plot
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === d.dimension)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                });
                        }
                    }
                });

                // Remove corresponding data from transposedData
                // transposedData = transposedData.filter(function (d) {
                //     return !removedDimensions.includes(d.gene);
                // });

                // Update totalOrder by removing removedDimensions
                totalOrder = totalOrder.filter(function (d) {
                    return !removedDimensions.includes(d);
                });

                console.log("Geneselected order:", geneselectedOrder);
                console.log("Metadata order:", metadataOrder);
                console.log("Total order:", totalOrder);
                console.log("Removed dimensions:", removedDimensions);

                selectedGeneData = geneselectedOrder
                // Find and remove the corresponding option from the select element
                var select = document.getElementById("selectButton");
                var options = select.options;

                for (var i = 0; i < options.length; i++) {
                    if (removedDimensions[0] === options[i].value) {
                        select.removeChild(options[i]);
                        break; // Exit the loop once the option is removed
                    }
                }


                first_dims = metadataOrder

                ordering = totalOrder

                // Update dimensions with new order

                // Redraw the parallel coordinates plot
                // Call updateParallel or relevant function here with updated dimensions
                dynamicParallel(geneselectedOrder, data, dataC, dataN, metadataOrder, totalOrder);
                if (currentPlot === 'volcano') {
                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else {
                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } d3.selectAll(".axis-label").classed("dragging", false);

            }
            // var newPositions = [];
            // svg.selectAll(".axis-group").each(function (d) {
            //     var transform = d3.select(this).attr("transform");
            //     var translateX = +transform.split("(")[1].split(")")[0];
            //     console.log(translateX)
            //     newPositions.push({ dimension: d, position: translateX });
            // });
            // console.log(newPositions)

            // // Sort newPositions array based on position
            // newPositions.sort(function (a, b) {
            //     return a.position - b.position;
            // });

            // // Separate dimensions into geneselected, metadata (first_dims), and total ordering
            // var geneselectedOrder = [];
            // var metadataOrder = [];
            // totalOrder = [];
            // newPositions.forEach(function (d) {
            //     if (geneselected.includes(d.dimension)) {
            //         geneselectedOrder.push(d.dimension);
            //     } else if (first_dims.includes(d.dimension)) {
            //         metadataOrder.push(d.dimension);
            //     }
            //     totalOrder.push(d.dimension);
            // });

            // // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
            // var removedDimensions = [];
            // newPositions.forEach(function (d) {
            //     if (d.position < -100 && geneselected.includes(d.dimension)) {
            //         var index = geneselectedOrder.indexOf(d.dimension);
            //         if (index !== -1) {
            //             removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
            //             // Remove highlighting color in the scatter plot
            //             scatter.selectAll("circle")
            //                 .filter(circleData => circleData.gene === d.dimension)
            //                 .style("fill", d => {
            //                     // Check if logFC is greater than or equal to the threshold
            //                     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
            //                         return "darkred";
            //                     } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
            //                         return "royalblue";
            //                     } else {
            //                         return "grey";
            //                     }
            //                 });
            //         }
            //     }
            // });

            // // // Remove corresponding data from transposedData
            // // transposedData = transposedData.filter(function (d) {
            // //     return !removedDimensions.includes(d.gene);
            // // });

            // // Update totalOrder by removing removedDimensions
            // totalOrder = totalOrder.filter(function (d) {
            //     return !removedDimensions.includes(d);
            // });

            // console.log("Geneselected order:", geneselectedOrder);
            // console.log("Metadata order:", metadataOrder);
            // console.log("Total order:", totalOrder);
            // console.log("Removed dimensions:", removedDimensions);

            // selectedGeneData = geneselectedOrder


            // first_dims = metadataOrder

            // ordering = totalOrder
            // Function to handle mouseover event
            function highlight(d) {
                // Determine the value to highlight based on the selected variable
                var selected_reg = transposedData[d][selectedVariable];

                // First, every group turns grey and reduces opacity
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        // Highlight only the selected category, reduce opacity for others
                        return transposedData[data][selectedVariable] === selected_reg ? colorScale(selected_reg) : "lightgrey";
                    })
                    .style("opacity", function (data) {
                        // Set opacity based on whether it's the selected category or not
                        return transposedData[data][selectedVariable] === selected_reg ? "1" : "0.2";
                    });

                // Apply pulsing effect directly to the hovered element
                d3.select(this)
                    .classed("pulse-red", true);
                this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
            }

            // Function to handle mouseout event
            function doNotHighlight() {
                // Reset stroke color and opacity for all lines
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        var selectedValue = transposedData[data][selectedVariable];
                        // Add logic here to set stroke color based on sampleSource
                        return colorScale(selectedValue);
                        // Set stroke color based on the selected variable
                    })
                    .style("opacity", "1"); // Reset opacity to 1

                // Pulsing effect for paths with GSM in gsmList
                d3.selectAll(".gsm-path")
                    .filter(function (data) {
                        return !gsmList.includes(data);
                    })
                    .classed("pulse-red", false);
            }

            // Bind mouseover and mouseleave events to all lines
            svg.selectAll(".gsm-path")
                .on("mouseover", highlight)
                .on("mouseleave", doNotHighlight);


        }



        function updateParallel(geneselected, data, dataC, dataN, first_dims, totalOrder) {
            let structureCombinedData = [];

            geneselected.forEach(geneName => {
                var geneDataN = dataN.filter(d => d.gene === geneName);
                var geneDataC = dataC.filter(d => d.gene === geneName);

                // Extract GSM values for each gene
                var gsmValuesC = Object.keys(geneDataC[0]).filter(key => key.startsWith('GSM'));
                var gsmValuesN = Object.keys(geneDataN[0]).filter(key => key.startsWith('GSM'));

                let expressionValuesC = [];
                geneDataC.forEach(entry => {
                    expressionValuesC.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                let expressionValuesN = [];
                geneDataN.forEach(entry => {
                    expressionValuesN.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                var combinedData = [];
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: 'Case', index: i });
                });
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: 'Normal', index: i });
                });

                structureCombinedData.push({
                    gene: geneName,
                    expressions: combinedData
                });
            });

            //console.log(structureCombinedData);

            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 50, bottom: 10, left: 50 },
                width = 1000 - margin.left - margin.right,
                height = 320 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#parallelcoordinates")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            //var selectedVariable = document.querySelector('input[name="variable"]:checked').value;


            var color;
            if (selectedVariable === "case") {
                color = d3.scaleOrdinal()
                    .domain(["Normal", "Case"])
                    .range(["#0d0887", "#fddb6d"]);
            } else if (selectedVariable === "Smoker") {
                color = d3.scaleOrdinal()
                    .domain(["Never Smoked", "Former Smoker", "Current Smoker"])
                    .range(["#0d0887", "#bd3786", "#fddb6d"]);
            } else if (selectedVariable === "Gender") {
                color = d3.scaleOrdinal()
                    .domain(["Male", "Female"]) // Set the domain based on the age data
                    .range(["#0d0887", "#fddb6d"]);
            } else if (selectedVariable === "Stage") {
                color = d3.scaleOrdinal()
                    .domain(["Normal", "IA", "IB", "IIA", "IIB", "IIIA", "IIIB", "IV"])
                    .range(["#0d0887", "#46039f", "#7201a8", "#9c179e", "#bd3786", "#d8576b", "#ed7953", "#fddb6d"]);
            }

            var ageAtDiagnosisValues = metadata['Age at Diagnosis:ch1'];

            if (totalOrder !== undefined) {
                dimensions = totalOrder
            } else {
                dimensions = first_dims.concat(geneselected);

            }

            var y = {};
            for (var i in dimensions) {
                var name = dimensions[i];
                y[name] = d3.scaleLinear()
                    .domain([0, 20])
                    .range([height, 0]);
            }
            // Extract age data from metadata
            var ageData = metadata["Age at Diagnosis:ch1"];
            var genderData = metadata["Gender:ch1"];
            var smokerData = metadata["Cigarette Smoking Status:ch1"];
            var stageData = metadata["Stage:ch1"];

            // Convert age data to numbers
            ageData = ageData.map(function (age) {
                return parseFloat(age);
            });

            // Determine the age domain
            var ageDomain = d3.extent(ageData);

            // Update the y-scale for the age dimension
            y["Age at Diagnosis"] = d3.scaleLinear()
                .domain([30, 90]) // Set the domain based on the age data
                .range([height, 0]);

            // Update the y-scale for the age dimension
            y["Gender"] = d3.scaleOrdinal()
                .domain(["Male", "Female"]) // Set the domain based on the age data
                .range([height, 0]);

            // Update the y-scale for Cigarette Smoking Status
            y["Smoking Status"] = d3.scaleOrdinal()
                .domain(["Never Smoked", "Former Smoker", "Current Smoker"])
                .range([height, height / 2, 0])

            var interval = height / 7;

            y["Stage"] = d3.scaleOrdinal()
                .domain(["Normal", "IA", "IB", "IIA", "IIB", "IIIA", "IIIB", "IV"])
                .range([height, height - interval, height - 2 * interval, height - 3 * interval, height - 4 * interval, height - 5 * interval, height - 6 * interval, 0]);

            // Update the y-scale for type
            y["type"] = d3.scaleOrdinal()
                .domain(["Normal", "Case"])
                .range([height, 0])


            // Build the X scale -> it finds the best position for each Y axis
            var x = d3.scalePoint()
                .range([0, width])
                .domain(dimensions);

            //console.log(metadata)

            var legend = d3.select("#parallelLegend");
            legend.html(""); // Clear previous legend content

            // Define legend dimensions and position
            var legendWidth = 550;
            var legendHeight = 60;
            var legendX = 20;
            var legendY = 10;


            // Create legend
            legend = d3.select("#parallelLegend")
                .append("svg")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .append("g")
                .attr("class", "legendOrdinal")
                .attr("transform", "translate(" + legendX + "," + legendY + ")");

            // Define legend color scale
            var legendColor = d3.legendColor()
                .shapeWidth(60) // Adjust shape width as needed
                .orient('horizontal')
                .labelWrap(30)
                .scale(color);

            // Append legend to the SVG
            legend.call(legendColor);

            // Set legend label color and style
            legend.selectAll(".label")
                .style("fill", "white") // Set label color to white
                .style("font-size", "14px")  // Adjust font size

            // Adjust label position
            legend.selectAll("text")
                .attr("dy", "-0.35em"); // Adjust vertical alignment

            // Transpose the structureCombinedData
            transposedData = [];
            if (geneselected.length > 0) {
                // Use geneselected when it's not empty
                geneselected.forEach(function (geneName) {
                    var geneData = structureCombinedData.find(d => d.gene === geneName);
                    geneData.expressions.forEach(function (expression, i) {
                        if (!transposedData[i]) transposedData[i] = { GSM: expression.GSM }; // Use GSM value from expression
                        transposedData[i][geneName] = expression.expression;
                        transposedData[i].type = expression.type; // Add the type property to each observation
                        // Find the index of the GSM in the metadata's geo_accession array
                        var gsmIndex = metadata.geo_accession.findIndex(item => item === expression.GSM);
                        if (gsmIndex !== -1) {
                            // If the GSM is found in metadata, insert the corresponding Age at Diagnosis
                            transposedData[i]['Age at Diagnosis'] = metadata['Age at Diagnosis:ch1'][gsmIndex];
                            transposedData[i]['Gender'] = metadata['Gender:ch1'][gsmIndex];
                            transposedData[i]['Smoking Status'] = metadata['Cigarette Smoking Status:ch1'][gsmIndex];
                            transposedData[i]['Stage'] = metadata['Stage:ch1'][gsmIndex];
                        }
                    });
                });
            } else {
                // Use first_dims when geneselected is empty
                transposedData = metadata.geo_accession.map((gsm, i) => ({
                    GSM: gsm,
                    'Age at Diagnosis': metadata['Age at Diagnosis:ch1'][i],
                    'Gender': metadata['Gender:ch1'][i],
                    'Smoking Status': metadata['Cigarette Smoking Status:ch1'][i],
                    'Stage': metadata['Stage:ch1'][i],
                    type: metadata['Stage:ch1'][i] === "Normal" ? "Normal" : "Case"
                }));
            }
            //console.log(transposedData);
            // Select all paths with the class "gsm-path"
            var gsmPaths = svg.selectAll(".gsm-path")
                .data(transposedData)
                .enter()
                .append("path")
                .attr("class", function (d) {
                    // Add the pulse-red class if the GSM is in the gsmList
                    return gsmList.includes(d.GSM) ? "gsm-path pulse-red" : "gsm-path";
                })
                .attr("d", function (d) {
                    var pathString = path(d);
                    return pathString;
                })
                .style("fill", "none")
                .style("stroke", function (d) {
                    if (selectedVariable === "case") {
                        return color(d.type);
                    } else if (selectedVariable === "Smoker") {
                        return color(d['Smoking Status']);
                    } else if (selectedVariable === "Gender") {
                        return color(d['Gender']);
                    } else if (selectedVariable === "Stage") {
                        return color(d['Stage']);
                    }
                })

            gsmPaths.on("click", function (d) {
                var clickedGSM = d.GSM; // Get the GSM value of the clicked path

                // Check if the clicked GSM is already in gsmList
                var index = gsmList.indexOf(clickedGSM);
                if (index === -1) {
                    // If not in the list, add it
                    gsmList.push(clickedGSM);
                    synchronizeAnimations(this)
                } else {
                    // If already in the list, remove it
                    gsmList.splice(index, 1);
                }

                // Update the class of the clicked path based on its presence in gsmList
                d3.select(this)
                    .classed("pulse-red", gsmList.includes(clickedGSM));


                pca(pca_data)

                updateBoxPlot(last_box, parsedLogFC, dataN_copy, dataC_copy)



                console.log("GSM List:", gsmList);
            });

            function path(d) {
                return d3.line()(dimensions.map(function (geneName) { return [x(geneName), y[geneName](d[geneName])]; }));
            }

            svg.selectAll(".gsm-path").each(function (data, i) {
                // Reorder the SVG elements to bring paths with selected GSM to the front
                gsmPaths.each(function () {
                    var selectedGSM = d3.select(this).datum().GSM;
                    if (gsmList.includes(selectedGSM)) {
                        this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                    }
                });

                //console.log("Data bound to path " + (i + 1) + ":", data);
            });

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = document.querySelectorAll(".pulse-red")


                console.log(elements)

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseRedAnimation');

                if (!targetAnimation) {
                    return
                }

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseRedAnimation');

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }




            // Draw the axis:
            var axis = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    if (d === "Smoking Status") {
                        // For "Smoking Status" dimension, customize the tick format
                        d3.select(this).call(d3.axisLeft().scale(y[d]).tickFormat(function (d) {
                            // Customize the tick format here
                            return d === "Never Smoked" ? "Never" : d === "Former Smoker" ? "Former" : "Current";
                        }));
                    } else {
                        d3.select(this).call(d3.axisLeft().scale(y[d]));
                    }
                });

            axis.append("text")
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    // Set the label text for "Type" axis
                    return d === "type" ? "Type" : d;
                })
                .style("fill", "white");

            axis.selectAll(".domain")
                .attr("stroke", "white");

            axis.selectAll(".tick text")
                .style("fill", "white");
            axis.selectAll(".tick line")
                .attr("stroke", "white");


            // Define drag behavior
            var drag = d3.drag()
                .on("start", dragstart)
                .on("drag", dragmove)
                .on("end", dragend);

            // Draw the axis:
            var axisGroups = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("class", "axis-group")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    if (d === "Smoking Status") {
                        // For "Smoking Status" dimension, customize the tick format
                        d3.select(this).call(d3.axisLeft().scale(y[d]).tickFormat(function (d) {
                            // Customize the tick format here
                            return d === "Never Smoked" ? "Never" : d === "Former Smoker" ? "Former" : "Current";
                        }));
                    } else {
                        d3.select(this).call(d3.axisLeft().scale(y[d]));
                    }
                })
                .call(drag); // Apply drag behavior to each axis group;

            axisGroups.append("text")
                .attr("class", "dragging") // Add the axis-label class
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    // Set the label text for "Type" axis
                    return d === "type" ? "Type" : d;
                })
                .style("fill", "white");

            axisGroups.selectAll(".domain")
                .attr("stroke", "white");

            axisGroups.selectAll(".tick text")
                .style("fill", "white");
            axisGroups.selectAll(".tick line")
                .attr("stroke", "white");



            // Drag start function
            function dragstart(d) {
                // Raise the dragged axis to the front
                d3.select(this).raise().classed("active", true);
                d3.select(this).classed("dragging", true);

            }

            // Drag move function
            function dragmove(d) {
                // Update the position of the dragged axis
                var newPosition = d3.event.x;
                d3.select(this).attr("transform", "translate(" + newPosition + ")");
            }

            function dragend(d) {
                // Get the new positions of the axis groups
                var newPositions = [];
                svg.selectAll(".axis-group").each(function (d) {
                    var transform = d3.select(this).attr("transform");
                    var translateX = +transform.split("(")[1].split(")")[0];
                    console.log(translateX)
                    newPositions.push({ dimension: d, position: translateX });
                });

                // Sort newPositions array based on position
                newPositions.sort(function (a, b) {
                    return a.position - b.position;
                });

                // Separate dimensions into geneselected, metadata (first_dims), and total ordering
                var geneselectedOrder = [];
                var metadataOrder = [];
                totalOrder = [];
                newPositions.forEach(function (d) {
                    if (geneselected.includes(d.dimension)) {
                        geneselectedOrder.push(d.dimension);
                    } else if (first_dims.includes(d.dimension)) {
                        metadataOrder.push(d.dimension);
                    }
                    totalOrder.push(d.dimension);
                });

                // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
                var removedDimensions = [];
                newPositions.forEach(function (d) {
                    console.log(d.position)
                    if ((d.position < -100 || d.position > 1000) && geneselected.includes(d.dimension)) {
                        var index = geneselectedOrder.indexOf(d.dimension);
                        if (index !== -1) {
                            removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                            // Remove highlighting color in the scatter plot
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === d.dimension)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "darkred";
                                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                        return "royalblue";
                                    } else {
                                        return "grey";
                                    }
                                });
                        }
                    }
                });

                // Remove corresponding data from transposedData
                transposedData = transposedData.filter(function (d) {
                    return !removedDimensions.includes(d.gene);
                });

                // Update totalOrder by removing removedDimensions
                totalOrder = totalOrder.filter(function (d) {
                    return !removedDimensions.includes(d);
                });

                console.log("Geneselected order:", geneselectedOrder);
                console.log("Metadata order:", metadataOrder);
                console.log("Total order:", totalOrder);
                console.log("Removed dimensions:", removedDimensions);

                selectedGeneData = geneselectedOrder

                selectedGeneData = geneselectedOrder
                // Find and remove the corresponding option from the select element
                var select = document.getElementById("selectButton");
                var options = select.options;

                for (var i = 0; i < options.length; i++) {
                    if (removedDimensions[0] === options[i].value) {
                        select.removeChild(options[i]);
                        break; // Exit the loop once the option is removed
                    }
                }


                first_dims = metadataOrder

                ordering = totalOrder

                // Update dimensions with new order

                // Redraw the parallel coordinates plot
                // Call updateParallel or relevant function here with updated dimensions
                updateParallel(geneselectedOrder, data, dataC, dataN, metadataOrder, totalOrder);
                if (currentPlot === 'volcano') {
                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else {
                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } d3.selectAll(".axis-label").classed("dragging", false);

            }
            var newPositions = [];
            svg.selectAll(".axis-group").each(function (d) {
                var transform = d3.select(this).attr("transform");
                var translateX = +transform.split("(")[1].split(")")[0];
                console.log(translateX)
                newPositions.push({ dimension: d, position: translateX });
            });
            console.log(newPositions)

            // Sort newPositions array based on position
            newPositions.sort(function (a, b) {
                return a.position - b.position;
            });

            // Separate dimensions into geneselected, metadata (first_dims), and total ordering
            var geneselectedOrder = [];
            var metadataOrder = [];
            totalOrder = [];
            newPositions.forEach(function (d) {
                if (geneselected.includes(d.dimension)) {
                    geneselectedOrder.push(d.dimension);
                } else if (first_dims.includes(d.dimension)) {
                    metadataOrder.push(d.dimension);
                }
                totalOrder.push(d.dimension);
            });

            // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
            var removedDimensions = [];
            newPositions.forEach(function (d) {
                if (d.position < -100 && geneselected.includes(d.dimension)) {
                    var index = geneselectedOrder.indexOf(d.dimension);
                    if (index !== -1) {
                        removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                        // Remove highlighting color in the scatter plot
                        scatter.selectAll("circle")
                            .filter(circleData => circleData.gene === d.dimension)
                            .style("fill", d => {
                                // Check if logFC is greater than or equal to the threshold
                                if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                    return "darkred";
                                } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                    return "royalblue";
                                } else {
                                    return "grey";
                                }
                            });
                    }
                }
            });

            // Remove corresponding data from transposedData
            transposedData = transposedData.filter(function (d) {
                return !removedDimensions.includes(d.gene);
            });

            // Update totalOrder by removing removedDimensions
            totalOrder = totalOrder.filter(function (d) {
                return !removedDimensions.includes(d);
            });

            console.log("Geneselected order:", geneselectedOrder);
            console.log("Metadata order:", metadataOrder);
            console.log("Total order:", totalOrder);
            console.log("Removed dimensions:", removedDimensions);

            selectedGeneData = geneselectedOrder


            first_dims = metadataOrder

            ordering = totalOrder
            // Function to handle mouseover event
            function highlight(d) {
                // Determine the value to highlight based on the selected variable
                var selected_reg;
                if (selectedVariable === "case") {
                    selected_reg = d.type;
                } else if (selectedVariable === "Smoker") {
                    selected_reg = d['Smoking Status'];
                } else if (selectedVariable === "Gender") {
                    selected_reg = d['Gender'];
                } else if (selectedVariable === "Stage") {
                    selected_reg = d['Stage']; // Set default value
                }

                // First, every group turns grey and reduces opacity
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        // Highlight only the selected category, reduce opacity for others
                        if (selectedVariable === "case") {
                            return data.type === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Smoker") {
                            return data['Smoking Status'] === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Gender") {
                            return data['Gender'] === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Stage") {
                            return data['Stage'] === selected_reg ? color(selected_reg) : "lightgrey";
                        }
                    })
                    .style("opacity", function (data) {
                        // Set opacity based on whether it's the selected category or not
                        if (selectedVariable === "case") {
                            return data.type === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Smoker") {
                            return data['Smoking Status'] === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Gender") {
                            return data['Gender'] === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Stage") {
                            return data['Stage'] === selected_reg ? "1" : "0.2";
                        }
                    });

                // Apply pulsing effect directly to the hovered element
                d3.select(this)
                    .classed("pulse-red", true);
                this.parentNode.appendChild(this); // Append to the parent node to bring it to the front

            }

            // Function to handle mouseout event
            function doNotHighlight() {
                // Reset stroke color and opacity for all lines
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        // Set stroke color based on the selected variable
                        if (selectedVariable === "case") {
                            return color(data.type);
                        } else if (selectedVariable === "Smoker") {
                            return color(data['Smoking Status']);
                        } else if (selectedVariable === "Gender") {
                            return color(data['Gender']);
                        } else if (selectedVariable === "Stage") {
                            return color(data['Stage']);
                        }
                    })
                    .style("opacity", "1"); // Reset opacity to 1

                // Pulsing effect for paths with GSM in gsmList
                d3.selectAll(".gsm-path")
                    .filter(function (data) {
                        return !gsmList.includes(data.GSM);
                    })
                    .classed("pulse-red", false);
            }

            // Bind mouseover and mouseleave events to all lines
            svg.selectAll(".gsm-path")
                .on("mouseover", highlight)
                .on("mouseleave", doNotHighlight);


        }

        function heatmap(heatmap_data) {
            document.getElementById("loadingOverlay").style.display = "none";

            var heatmap_data_subset = heatmap_data.slice(0, 6);
            console.log(heatmap_data_subset)
            // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
            var myGroups = heatmap_data_subset.map(d => d.gene);
            var myVars = Object.keys(heatmap_data_subset[0]).filter(d => d !== "gene");
            // set the dimensions and margins of the graph

            var margin = { top: 40, right: 75, bottom: 30, left: 100 },
                width = 600 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#heatmap")
                .html("")
                .append("svg")
                .attr("width", 670)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + (margin.left + 46) + "," + margin.top + ")");

            // Build X scales and axis:
            var x = d3.scaleBand()
                .range([0, width])
                .domain(myVars)
                .padding(0.05);
            svg.append("g")
                .style("font-size", 15)
                .attr("transform", "translate(0,0)")
                .call(d3.axisTop(x).tickSize(0))
                .select(".domain").remove();

            // Add click event listener to the X-axis tick texts
            svg.selectAll(".tick text")
                .style("fill", "white")
                .style("text-transform", "uppercase")

            // Build Y scales and axis:
            var y = d3.scaleBand()
                .range([0, height])
                .domain(myGroups)
                .padding(0.05);
            svg.append("g")
                .style("font-size", 15)
                .style("fill", "white")
                .call(d3.axisLeft(y).tickSize(0))
                .select(".domain").remove();

            // Select and style the tick text for the Y axis
            svg.selectAll(".tick text").style("fill", "white");

            // Add title text
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -25)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Heatmap")
                .style("fill", "white");
            // Build color scale
            var myColor = d3.scaleSequential()
                .interpolator(d3.interpolateInferno)
                .domain([d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v])),
                d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v]))]);

            // create a tooltip
            var tooltip = d3.select("#heatmap")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px");

            // Three functions that change the tooltip when user hover / move / leave a cell
            var mouseover = function (d) {
                tooltip
                    .style("opacity", 1);

                if (d3.select(this).style("stroke") === "none") {
                    d3.select(this)
                        .style("stroke", "yellow")
                        .style("opacity", 1);
                }

            };

            var mousemove = function (d) {
                var valueString;
                if (d.value < 0.01) {
                    valueString = d.value.toExponential(2) + "%";
                } else {
                    valueString = (d.value).toFixed(2) + "%";
                }
                // Calculate the position of the tooltip
                var xPosition = d3.event.pageX + 10; // 10 pixels to the right of the mouse pointer
                var yPosition = d3.event.pageY - 10; // 10 pixels above the mouse pointer

                var variableUppercase = d.variable.toUpperCase();

                tooltip
                    .html("The contribution percentage of<br>" + d.gene + " in " + variableUppercase + " is: " + valueString)
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px");
            };

            var mouseleave = function (d) {
                tooltip
                    .style("opacity", 0)
                    .style("pointer-events", "none"); // Disable pointer events for the tooltip

                if (d3.select(this).style("stroke") === "yellow") {

                    d3.select(this).style("stroke", "none")
                        .style("opacity", 0.8)

                }


            };

            // add the squares
            square = svg.selectAll(".heatmap-rect")
                .data(heatmap_data_subset.flatMap(d => myVars.map(v => ({ gene: d.gene, variable: v, value: d[v] }))))
                .enter()
                .append("rect")
                .attr("x", function (d) { return x(d.variable); })
                .attr("y", function (d) { return y(d.gene); })
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", function (d) { return myColor(d.value); })
                .style("stroke-width", 4)
                .style("stroke", "none")
                .style("opacity", 0.8)
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseout", mouseleave)
                .on("click", function (d) {
                    var selectedElement = d3.select(this);

                    // Check if the rectangle is already stroked
                    var isRectangleStroked = selectedElement.style("stroke") === "red";

                    // Find the corresponding scatterplot circle and toggle its selection
                    var correspondingCircle = scatter.selectAll("circle")
                        .filter(function (circleData) {
                            return circleData.gene === d.gene;
                        });

                    // Store the selected rectangle's variable
                    var selectedVariable = d.variable;

                    // Remove stroke from all rectangles of the current gene
                    svg.selectAll("rect")
                        .filter(function (rectData) {
                            if (rectData !== undefined) {
                                return rectData.gene === d.gene;
                            }
                        })
                        .style("stroke", "none");

                    // Toggle the stroke of the selected rectangle
                    selectedElement.style("stroke", "red");

                    // If the rectangle is already stroked, remove the stroke and revert circle's fill color
                    if (isRectangleStroked) {
                        var initialCircleFill = correspondingCircle.attr("data-initial-fill"); // Retrieve the initial fill color
                        selectedElement.style("stroke", "none");
                        correspondingCircle.style("fill", initialCircleFill)
                            .classed("pulse1", false)
                        synchronizeAnimations(correspondingCircle.node(), true)
                    } else {
                        // If the rectangle is not stroked, toggle the stroke and set circle's fill color
                        currentCircleFill = correspondingCircle.attr("data-initial-fill");
                        console.log(correspondingCircle)
                        console.log(currentCircleFill)
                        correspondingCircle.attr("data-initial-fill", currentCircleFill); // Save the initial fill color
                        selectedElement.style("stroke", "red");
                        correspondingCircle.style("fill", myColor(d.value)).classed("pulse1", true);
                        console.log(correspondingCircle)
                        synchronizeAnimations(correspondingCircle.node(), false)
                    }
                });

            function synchronizeAnimations(targetElement, banana) {

                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];
                let targetAnimation
                if (banana) {
                    targetAnimation = findAnimByName(targetElement, 'pulseAnimation');
                }
                else {
                    targetAnimation = findAnimByName(targetElement, 'pulseAnimation1');
                }
                // Retrieve the Animation object of the target element

                if (!targetAnimation) {
                    return
                }

                console.log("sono passato")

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }


            // Define the color scale for the legend
            var legendScale = d3.scaleLinear()
                .domain([d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v])),
                d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v]))])
                .range([0, 150]); // Adjust the range according to the height of the heatmap

            // Specify the tick values based on desired intervals
            var tickValues = [
                d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v])), // Minimum value
                (d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) - d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v]))) / 4, // 1/4 of maximum
                (d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) - d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v]))) / 2, // 2/4 of maximum
                (d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) - d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v]))) * 3 / 4, // 3/4 of maximum
                d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) // Maximum value
            ];

            // Create a separate SVG element for the legend
            var legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (450) + "," + 10 + ")");

            // Create color gradient for legend
            var defs = legend.append("defs");
            var linearGradient = defs.append("linearGradient")
                .attr("id", "linear-gradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%");

            // Add color stops based on the heatmap color scale
            myColor.ticks(10).forEach(function (t, i, n) {
                linearGradient.append("stop")
                    .attr("offset", (100 * i / n.length) + "%")
                    .attr("stop-color", myColor(t));
            });

            // Draw rectangle to display the legend
            legend.append("rect")
                .attr("width", 10)
                .attr("height", 150)
                .style("fill", "url(#linear-gradient)");

            legendAxis = d3.axisRight(legendScale)
                .tickValues(tickValues)
                .tickFormat(function (d) { return (d).toFixed(2) + "%"; }); // Format tick values with three digits after the comma and add a percentage symbol
            var axis = legend.append("g")
                .attr("class", "legend-axis")
                .attr("transform", "translate(20,0)")
                .call(legendAxis);

            // Apply style to axis ticks to make them white
            axis.selectAll("text").style("fill", "white").style("font-size", "13px")
            axis.selectAll("line").style("stroke", "white");


            // Remove the domain path
            axis.select(".domain").remove();

            document.getElementById("loadingOverlay").style.display = "none";
        }

        function calculateAverageExpressions(dataArray) {
            // Create an object to store the sum and count for each gene
            var geneSumCount = {};

            // Iterate through each gene object in the array
            dataArray.forEach(function (geneData) {
                var gene = geneData.gene;

                // Iterate through each property (sample) in the gene object
                for (var sample in geneData) {
                    if (sample !== 'gene') {
                        // If the gene is not in the sumCount object, initialize it
                        if (!geneSumCount[gene]) {
                            geneSumCount[gene] = { sum: 0, count: 0 };
                        }

                        // Add the expression value to the sum and increment the count
                        geneSumCount[gene].sum += parseFloat(geneData[sample]);
                        geneSumCount[gene].count++;
                    }
                }
            });

            // Calculate the average for each gene
            var averageExpressions = {};
            for (var gene in geneSumCount) {
                averageExpressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
            }

            return averageExpressions;
        }

        function calculateAverageLog10Expressions(dataArray) {
            // Create an object to store the sum and count for each gene
            var geneSumCount = {};

            // Iterate through each gene object in the array
            dataArray.forEach(function (geneData) {
                var gene = geneData.gene;

                // Iterate through each property (sample) in the gene object
                for (var sample in geneData) {
                    if (sample !== 'gene') {
                        // If the gene is not in the sumCount object, initialize it
                        if (!geneSumCount[gene]) {
                            geneSumCount[gene] = { sum: 0, count: 0 };
                        }

                        // Apply Math.log10 to the expression value before summing
                        var log10Expression = Math.log10(parseFloat(geneData[sample]) + 1);

                        // Add the log10 expression value to the sum and increment the count
                        geneSumCount[gene].sum += log10Expression;
                        geneSumCount[gene].count++;
                    }
                }
            });

            // Calculate the average log10 expression for each gene
            var averageLog10Expressions = {};
            for (var gene in geneSumCount) {
                averageLog10Expressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
            }

            return averageLog10Expressions;
        }

        // Function to handle checkbox change event
        function handleCheckboxChange() {
            var checkbox = document.getElementById("vehicle1");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Age at Diagnosis');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Age at Diagnosis');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeGender() {
            var checkbox = document.getElementById("vehicle3");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Gender');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Gender');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeCigarettes() {
            var checkbox = document.getElementById("vehicle2");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Smoking Status');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Smoking Status');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeStage() {
            var checkbox = document.getElementById("vehicle4");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('Stage');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('Stage');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Function to handle checkbox change event
        function handleCheckboxChangeType() {
            var checkbox = document.getElementById("vehicle5");
            var isChecked = checkbox.checked;

            if (isChecked) {
                // Add 'Age at Diagnosis' dimension to dimensions array
                first_dims.unshift('type');
            } else {
                // Remove 'Age at Diagnosis' dimension from dimensions array
                var index = first_dims.indexOf('type');
                if (index !== -1) {
                    first_dims.splice(index, 1);
                    if (first_dims === undefined) {
                        first_dims = []
                    }
                }
            }

            // Call updateParallel with the updated dimensions array
            updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        }

        // Attach event listener to the checkbox
        document.getElementById("vehicle1").addEventListener("change", handleCheckboxChange);
        document.getElementById("vehicle3").addEventListener("change", handleCheckboxChangeGender);
        document.getElementById("vehicle2").addEventListener("change", handleCheckboxChangeCigarettes);
        document.getElementById("vehicle4").addEventListener("change", handleCheckboxChangeStage);
        document.getElementById("vehicle5").addEventListener("change", handleCheckboxChangeType);

        var radioContainer = document.getElementById("radiobox");

        radioContainer.addEventListener("click", function (event) {
            var selectedRadio = event.target;
            var radioInput = selectedRadio.querySelector('input[type="radio"]');

            //console.log("value = ", radioInput.value)
            if (radioInput && radioInput.type === "radio") {
                console.log(radioInput.value);

                selectedVariable = radioInput.value;

                console.log("Geneselected order in radio:", selectedGeneData);
                console.log("Metadata order in radio:", first_dims);
                console.log("Total order in radio:", ordering);

                updateParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
            }
        });



        function updateCounter() {
            // Select the counter div
            var counterDiv = d3.select("#counter");
            var counterDiv1 = d3.select("#counter1");
            console.log(data_copy.length)
            console.log(data_copy_pval.length)
            if (data_copy_pval.length > data_copy.length) {
                // Update the content of the counter and apply margin-left to text
                counterDiv.html(
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Total number of genes:</span>" +
                    "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_original.length + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by IQR:</span>" +
                    "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_copy1.length + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by FC:</span>" +
                    "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_copy.length + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by p-val:</span>" +
                    "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_copy.length + "</span>"
                );
            }
            else {
                counterDiv.html(
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Total number of genes:</span>" +
                    "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_original.length + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by IQR:</span>" +
                    "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_copy1.length + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by FC:</span>" +
                    "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_copy.length + "</span><br>" +
                    "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by p-val:</span>" +
                    "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_copy_pval.length + "</span>"
                );

            }

            // Update the content of the counter and apply margin-left to text
            counterDiv.html(
                "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Total number of genes:</span>" +
                "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_original.length + "</span><br>" +
                "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by IQR:</span>" +
                "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_copy1.length + "</span><br>" +
                "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by FC:</span>" +
                "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_copy.length + "</span><br>" +
                "<span style='display: inline-block; width: 235px; margin-left: 10px; font-weight: bold; font-size : 13px;'>Genes retained after filtering by p-val:</span>" +
                "<span style='display: inline-block; width: 70px; text-align: center; font-weight: bold;'>" + data_copy_pval.length + "</span>"
            );

            counterDiv1.html(
                "<span style='display: inline-block; width: 200px; margin-left: 20px; font-weight: bold;'>Parameters:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'> </span><br>" +
                "<span style='display: inline-block; width: 200px; margin-left: 20px; font-weight: bold;'>IQR threshold:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'>" + thr_prc.toFixed(3) + "</span><br>" +
                "<span style='display: inline-block; width: 200px; margin-left: 20px; font-weight: bold;'>Log FC threshold:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'>" + log_thr_fc.toFixed(3) + "</span><br>" +
                "<span style='display: inline-block; width: 200px; margin-left: 20px; font-weight: bold;'>Significance level:</span>" +
                "<span style='display: inline-block; width: 100px; text-align: center; font-weight: bold;'>" + threshold + "</span>"
            );
        }

        document.getElementById("exportGenesButton").addEventListener("click", exportGenes);

        function exportGenes() {
            // Convert parsedLogFC array to CSV format
            const csvContent = "data:text/csv;charset=utf-8,Gene,LogFC\n" + parsedLogFC.map(gene => `${gene.Gene},${gene.logFC}`).join("\n");

            // Create a link element
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "genes.csv");

            // Append the link to the document body and click it programmatically to initiate download
            document.body.appendChild(link);
            link.click();
        }


        document.getElementById("importDatasetButton").addEventListener("click", showLoadCsvOverlayMod);

        // Function to show the CSV file loading overlay
        function showLoadCsvOverlayMod() {
            event.stopPropagation();

            document.getElementById("loadDatasetOverlay").style.display = "block";

            // Add event listener to detect clicks outside of the overlay
            document.body.addEventListener("click", hideLoadCsvOverlayOnClickOutside);
        }

        // Function to hide the CSV file loading overlay
        function hideLoadCsvOverlay() {
            document.getElementById("loadDatasetOverlay").style.display = "none";

            // Remove the click event listener from the body
            document.body.removeEventListener("click", hideLoadCsvOverlayOnClickOutside);
        }

        // Function to hide the overlay when clicking outside of it
        function hideLoadCsvOverlayOnClickOutside(event) {
            var loadDatasetOverlay = document.getElementById("containeDatasetOverlay");
            // Check if the click target is outside of the overlay
            if (!loadDatasetOverlay.contains(event.target)) {
                hideLoadCsvOverlay();
            }
        }

        // Function to filter and display search results
        function filterAndDisplayResults() {
            const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
            const searchResults = document.getElementById('searchResults');

            // Clear existing results before updating
            searchResults.innerHTML = '';

            if (searchTerm.length === 0) {
                searchResults.style.display = 'none';
                return;
            }

            console.log(data_copy_pval)
            console.log(old_p_adj)
            const matches = old_p_adj.filter(item => {
                // Filter logic based on your data structure
                // Assuming data_copy_pval is an array of objects with 'gene' property
                return item.Gene.toLowerCase().includes(searchTerm) && item.pval_adj < threshold;
            });

            // Display the matches in the results container
            for (let i = 0; i < matches.length && i < 5; i++) {
                const resultElement = document.createElement('a');
                resultElement.id = `result${i + 1}`;
                resultElement.classList.add('result-item');
                resultElement.textContent = matches[i].Gene;

                // Handle click on result to select it
                resultElement.addEventListener('click', (function (gene) {
                    return function (event) {
                        event.stopPropagation(); // Stop propagation to prevent other results from triggering

                        document.getElementById('searchInput').value = gene;

                        // Check if the gene is already in selectedGeneData
                        if (!selectedGeneData.includes(gene)) {
                            selectedGeneData.push(gene);

                            // Add selected Gene to boxplot dropdown menu 
                            // Get the select element
                            var select = document.getElementById("selectButton");

                            // Add new options for the genes in selectedGeneData that are not already in the select element
                            selectedGeneData.forEach(function (gene) {
                                if (!Array.from(select.options).some(option => option.value === gene)) {
                                    var option = document.createElement("option");
                                    option.value = gene;
                                    option.text = gene;
                                    select.appendChild(option);
                                }
                            });

                            dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims);
                            updateBoxPlot(last_box, parsedLogFC, dataN_copy, dataC_copy);
                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj);
                            } else {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj);
                            }
                        }
                        searchResults.style.display = 'none'; // Hide results after selection
                    };
                })(matches[i].Gene)); // Immediately invoked function to capture current gene value

                searchResults.appendChild(resultElement); // Append each result to the results container
            }

            // Show the results container if there are matches
            if (matches.length > 0) {
                searchResults.style.display = 'block';
            } else {
                searchResults.style.display = 'none';
            }
        }

        // Handle input in search input
        document.getElementById('searchInput').addEventListener('input', function () {
            filterAndDisplayResults();
        });

        // Handle focus on search input to show results
        document.getElementById('searchInput').addEventListener('focus', function () {
            filterAndDisplayResults();
        });

        // Handle blur on search input to hide results
        document.getElementById('searchInput').addEventListener('blur', function () {
            const searchResults = document.getElementById('searchResults');
            const relatedTarget = document.activeElement;

            if (!searchResults.contains(relatedTarget)) {
                searchResults.style.display = 'none';
            }
        });

        // Handle click inside search results container to prevent hiding
        document.getElementById('searchResults').addEventListener('mousedown', function (event) {
            event.preventDefault(); // Prevents focus change which would trigger blur
        });


    </script>

    <div id="tooltip"
        style="position: absolute; opacity: 0; background-color: white; border: 1px solid #ddd; padding: 5px;">
    </div>
    <div id="tTestResults"></div>

</body>

</html>